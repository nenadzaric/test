/*! (C) 2016 Conviva, Inc. All rights reserved. Confidential and proprietary. */ ! function(a, b) {
  if ("function" == typeof define && define.amd ? define(b) : "object" == typeof exports && (module.exports = b()), "undefined" != typeof a) {
    if (void 0 !== a.Conviva) return;
    if (a.ConvivaLoading) return;
    a.ConvivaLoading = !0,
      a.Conviva = b(), delete a.ConvivaLoading
  }
}(this, function() {
  var a = {};
  return function() {
    "use strict";
    var b = {};
    ! function() {
      var c = a.Client = function(b, g) {
        function i(a, b) {
          if (!(a instanceof d)) throw new Error("clientSettings parameter should be an instance of ClientSettings.");
          if (!(b instanceof f)) throw new Error("systemFactory parameter should be an instance of SystemFactory.");
          (a.gatewayUrl == d._httpsProtocol + d.defaultProductionGatewayDNS || a.gatewayUrl == d._httpProtocol + d.defaultProductionGatewayDNS) && (this.defaultGatewayURLError = !0),
          this._settings = a.clone(), this._systemFactory = b, this._systemFactory.configure("SDK", this._settings), this._exceptionCatcher = this._systemFactory.buildExceptionCatcher(), this._exceptionCatcher.runProtected("Client.init", function() {
            j._id = F.uinteger32(), j._logger = j._systemFactory.buildLogger(), j._logger.setModuleName("Client"), j.defaultGatewayURLError && j._logger.info("Gateway URL should not be set to https://cws.conviva.com or http://cws.conviva.com, therefore this call is ignored"),
              j._logger.info("init(): url=" + j._settings.gatewayUrl + " customerKey=" + j._settings.customerKey), j._config = j._systemFactory.buildConfig(), j._config.load(), j._sessionFactory = j._systemFactory.buildSessionFactory(j, j._settings, j._config),
              j._logger.info("init(): done.")
          }, function(a) {
            throw new Error("Client constructor failed: " + a.message)
          })
        }
        var j = this;
        this.defaultGatewayURLError = !1, this._logger = null, this._sessionFactory = null, this._systemFactory = null,
          this._globalSessionKey = -1, this._settings = null, this._systemSettings = null, this._exceptionCatcher = null, this._config = null, this._id = -1, this._released = !1, i.apply(this, arguments), this.release = function() {
            this._released || this._exceptionCatcher.runProtected("Client.release", function() {
              j._logger.info("release()"), j._sessionFactory.cleanup(), j._sessionFactory = null, j._globalSessionKey = -1, j._logger = null, j._id = -1, j._exceptionCatcher = null, j._settings = null, j._systemSettings = null, j._systemFactory = null,
                j._released = !0
            })
          }, this.createSession = function(a) {
            var b = c.NO_SESSION_KEY;
            return this._released ? b : null == a || a instanceof e ? (this._exceptionCatcher.runProtected("Client.createSession", function() {
              b = j._sessionFactory.makeVideoSession(a, u.SESSION_TYPE.VIDEO);
            }), b) : (j._logger.error("createSession(): expecting an instance of ContentMetadata for contentMetadata parameter"), b)
          }, this.createAdSession = function(a, b) {
            var d = c.NO_SESSION_KEY;
            return this._released ? d : null == b || b instanceof e ? (this._exceptionCatcher.runProtected("Client.createAdSession", function() {
              var c = j._sessionFactory.getVideoSession(a);
              null != c && (null == b && (b = new e), (null == b.applicationName || null == b.viewerId) && (null == b.viewerId && null != c._contentMetadata.viewerId && (b.viewerId = c._contentMetadata.viewerId), null == b.applicationName && null != c._contentMetadata.applicationName && (b.applicationName = c._contentMetadata.applicationName)), b.custom["c3.csid"] = C.ToString(c._id)), d = j._sessionFactory.makeVideoSession(b, u.SESSION_TYPE.AD);
            }), d) : (j._logger.error("createAdSession(): expecting an instance of ContentMetadata for adMetadata parameter"), d)
          }, this.reportError = function(b, c, d) {
            return this._released ? void 0 : C.isValidString(c) ? d !== a.Client.ErrorSeverity.FATAL && d !== a.Client.ErrorSeverity.WARNING ? void this._logger.error("reportError(): invalid error severity: " + d) : void this._exceptionCatcher.runProtected("Client.reportError", function() {
              var a = j._sessionFactory.getVideoSession(b);
              null != a && a.reportError(c, d)
            }) : void this._logger.error("reportError(): invalid error message string: " + c)
          }, this.updateContentMetadata = function(a, b) {
            return this._released ? void 0 : b instanceof e ? void this._exceptionCatcher.runProtected("Client.updateContentMetadata", function() {
              var c = j._sessionFactory.getVideoSession(a);
              if (null != c) {
                var d = b.clone();
                c.updateContentMetadata(d)
              }
            }) : void j._logger.error("updateContentMetadata(): expecting an instance of ContentMetadata for contentMetadata parameter");
          }, this.detachPlayer = function(a) {
            this._released || this._exceptionCatcher.runProtected("Client.detachPlayer", function() {
              var b = j._sessionFactory.getVideoSession(a);
              null != b && b.detachPlayer()
            })
          }, this.attachPlayer = function(a, b) {
            return this._released ? void 0 : b instanceof h ? void this._exceptionCatcher.runProtected("Client.attachPlayer", function() {
              var c = j._sessionFactory.getVideoSession(a);
              null != c && c.attachPlayer(b)
            }) : void j._logger.error("attachPlayer(): expecting an instance of PlayerStateManager for playerStateManager parameter");
          }, this.contentPreload = function(a) {
            this._released || this._exceptionCatcher.runProtected("Client.contentPreload", function() {
              var b = j._sessionFactory.getVideoSession(a);
              null != b && b.contentPreload()
            })
          }, this.contentStart = function(a) {
            this._released || this._exceptionCatcher.runProtected("Client.contentStart", function() {
              var b = j._sessionFactory.getVideoSession(a);
              null != b && b.contentStart()
            })
          }, this.sendCustomEvent = function(a, b, d) {
            return this._released ? void 0 : C.isValidString(b) ? void this._exceptionCatcher.runProtected("Client.sendCustomEvent", function() {
              if (a == c.NO_SESSION_KEY) {
                if (j._globalSessionKey < 0) {
                  var f = new e;
                  j._globalSessionKey = j._sessionFactory.makeGlobalSession(f, null)
                }
                a = j._globalSessionKey
              }
              var g = C.sanitizeStringToStringObject(d),
                h = j._sessionFactory.getSession(a);
              null != h && h.sendCustomEvent(b, g)
            }) : void j._logger.error("sendCustomEvent(): eventName parameter must be a valid string.")
          }, this.adStart = function(a, b, d, e) {
            return this._released ? void 0 : b !== c.AdStream.CONTENT && b !== c.AdStream.SEPARATE ? void this._logger.error("adStart(): ignored, invalid value for adStream parameter: " + b) : d !== c.AdPlayer.CONTENT && d !== c.AdPlayer.SEPARATE ? void this._logger.error("adStart(): ignored, invalid value for adPlayer parameter: " + d) : e !== c.AdPosition.BUMPER && e !== c.AdPosition.PREROLL && e !== c.AdPosition.MIDROLL && e !== c.AdPosition.POSTROLL ? void this._logger.error("adStart(): ignored, invalid value for adPosition parameter: " + e) : void this._exceptionCatcher.runProtected("Client.adStart", function() {
              var c = j._sessionFactory.getVideoSession(a);
              null != c && c.adStart(b, d, e)
            })
          }, this.adEnd = function(a) {
            this._released || this._exceptionCatcher.runProtected("Client.adEnd", function() {
              var b = j._sessionFactory.getVideoSession(a);
              null != b && b.adEnd()
            })
          }, this.cleanupSession = function(a) {
            return this._released ? void 0 : a === c.NO_SESSION_KEY ? void this._logger.warning("cleanupSession(): ignored, can't cleanup Client.NO_SESSION_KEY") : void this._exceptionCatcher.runProtected("Client.cleanupSession", function() {
              var b = j._sessionFactory.getVideoSession(a);
              null != b && j._sessionFactory.cleanupSession(a)
            })
          }, this.getAttachedPlayer = function(a) {
            var b = null;
            return this._released ? b : a === c.NO_SESSION_KEY ? (this._logger.warning("getAttachedPlayer(): ignored for Client.NO_SESSION_KEY"), b) : (this._exceptionCatcher.runProtected("Client.getAttachedPlayer", function() {
              var c = j._sessionFactory.getVideoSession(a);
              null != c && (b = c.getPlayerStateManager())
            }), b)
          }, this.isPlayerAttached = function(a) {
            return this._released ? !1 : null !== this.getAttachedPlayer(a) ? !0 : !1;
          }, this.getPlayerStateManager = function() {
            if (this._released) throw new Error("This instance of Conviva.Client has been released.");
            return new h(this._systemFactory)
          }, this.releasePlayerStateManager = function(a) {
            if (this._released) throw new Error("This instance of Conviva.Client has been released.");
            this._exceptionCatcher.runProtected("Client.releasePlayerStateManager", function() {
              a instanceof h && a.release()
            })
          },
          this.getSettings = function() {
            return this._settings
          }, this.getId = function() {
            return this._id
          }
      };
      c.version = "2.151.0.36995", c.NO_SESSION_KEY = -2, c.AdPosition = {
        BUMPER: "BUMPER",
        PREROLL: "PREROLL",
        MIDROLL: "MIDROLL",
        POSTROLL: "POSTROLL"
      }, c.AdStream = {
        CONTENT: "CONTENT",
        SEPARATE: "SEPARATE"
      }, c.AdPlayer = {
        CONTENT: "CONTENT",
        SEPARATE: "SEPARATE"
      }, c.ErrorSeverity = {
        FATAL: 0,
        WARNING: 1
      }, c.DeviceType = {
        DESKTOP: "DESKTOP",
        CONSOLE: "Console",
        SETTOP: "Settop",
        MOBILE: "Mobile",
        TABLET: "Tablet",
        SMARTTV: "SmartTV"
      }, c.AdTechnology = {
        CLIENT_SIDE: "Client Side",
        SERVER_SIDE: "Server Side"
      }, c.AdType = {
        BLACKOUT_SLATE: "Blackout slate",
        TECHNICAL_DIFFICULTIES_SLATE: "Technical Difficulties slate",
        COMMERCIAL_SLATE: "Commercial Break slate",
        OTHER_SLATE: "Other slate",
        VPAID: "VPAID",
        REGULAR: "Regular Ad"
      }, c.AdServingType = {
        INLINE: "Inline",
        WRAPPER: "Wrapper"
      }, c.DeviceCategory = {
        ANDROID_DEVICE: "AND",
        APPLE_DEVICE: "APL",
        CHROMECAST: "CHR",
        DESKTOP_APP: "DSKAPP",
        DEVICE_SIMULATOR: "SIMULATOR",
        LG_TV: "LGTV",
        NINTENDO: "NINTENDO",
        PLAYSTATION: "PS",
        ROKU: "RK",
        SAMSUNG_TV: "SAMSUNGTV",
        SMART_TV: "TV",
        SET_TOP_BOX: "STB",
        TIVO: "TIVO",
        WEB: "WEB",
        WINDOWS_DEVICE: "WIN",
        XBOX: "XB",
        KAIOS_DEVICE: "KAIOS"
      };
      var d = a.ClientSettings = function(a) {
        function b(a) {
          if (!C.isValidString(a)) throw new Error("customerKey must be valid");
          this.customerKey = a
        }

        function c(a) {
          if (C.isValidString(a)) {
            var b = a.split("://");
            if ("cws.conviva.com" != b[1] && ("https" == b[0] || "http" == b[0])) return a
          }
          return "https://" + e.customerKey + "." + d.defaultProductionGatewayDNS
        }
        var e = this;
        this._customerKey = null,
          C.defGet(this, "customerKey", function() {
            return this._customerKey
          }), C.defSet(this, "customerKey", function(a) {
            C.isValidString(a) && (this._customerKey = a)
          }), this._heartbeatInterval = d.defaultProductionHeartbeatInterval,
          C.defGet(this, "heartbeatInterval", function() {
            return this._heartbeatInterval
          }), C.defSet(this, "heartbeatInterval", function(a) {
            if ("number" == typeof a) {
              var b = C.NumberToUnsignedInt(a);
              b === a && (this._heartbeatInterval = b);
            }
          }), this._gatewayUrl = null, C.defGet(this, "gatewayUrl", function() {
            return this._gatewayUrl
          }), C.defSet(this, "gatewayUrl", function(a) {
            C.isValidString(a) && (this._gatewayUrl = a)
          }), b.apply(this, arguments), this.equals = function(a) {
            return this.customerKey === a.customerKey && this.gatewayUrl === a.gatewayUrl && this.heartbeatInterval === a.heartbeatInterval
          }, this.clone = function() {
            var a = new d(this.customerKey);
            return a.gatewayUrl = c(this.gatewayUrl),
              a.heartbeatInterval = this.heartbeatInterval, a
          }
      };
      d.defaultDevelopmentGatewayUrl = "https://conviva.testonly.conviva.com", d.defaultProductionGatewayUrl = "https://cws.conviva.com", d.defaultProductionGatewayDNS = "cws.conviva.com",
        d.defaultDevelopmentGatewayDNS = "conviva.testonly.conviva.com", d._httpsProtocol = "https://", d._httpProtocol = "http://", d.defaultDevelopmentHeartbeatInterval = 5, d.defaultProductionHeartbeatInterval = 20;
      var e = a.ContentMetadata = function() {
        function a() {
          return this._assetName
        }

        function b(a) {
          "string" == typeof a && (this._assetName = a)
        }

        function c() {
          return this._custom
        }

        function d(a) {
          "object" == typeof a && (this._custom = C.sanitizeStringToStringObject(a));
        }

        function f() {
          return this._defaultResource
        }

        function g(a) {
          "string" == typeof a && (this._defaultResource = a)
        }

        function h() {
          return this._viewerId
        }

        function i(a) {
          "string" == typeof a && (this._viewerId = a)
        }

        function j() {
          return this._applicationName
        }

        function k(a) {
          "string" == typeof a && (this._applicationName = a)
        }

        function l() {
          return this._streamUrl
        }

        function m(a) {
          "string" == typeof a && (this._streamUrl = a)
        }

        function n() {
          return this._streamType;
        }

        function o(a) {
          (a === e.StreamType.UNKNOWN || a === e.StreamType.VOD || a === e.StreamType.LIVE) && (this._streamType = a)
        }

        function p() {
          return this._duration
        }

        function q(a) {
          this._duration = G.sanitizeSpecialIntegerValue(a);
        }

        function r() {
          return this._encodedFrameRate
        }

        function s(a) {
          this._encodedFrameRate = G.sanitizeSpecialIntegerValue(a)
        }

        function t() {}
        this._assetName = null, C.defGet(this, "assetName", a), C.defSet(this, "assetName", b),
          this._custom = {}, C.defGet(this, "custom", c), C.defSet(this, "custom", d), this._defaultResource = null, C.defGet(this, "defaultResource", f), C.defSet(this, "defaultResource", g), this._viewerId = null, C.defGet(this, "viewerId", h),
          C.defSet(this, "viewerId", i), this._applicationName = null, C.defGet(this, "applicationName", j), C.defSet(this, "applicationName", k), this._streamUrl = null, C.defGet(this, "streamUrl", l), C.defSet(this, "streamUrl", m),
          this._streamType = e.StreamType.UNKNOWN, C.defGet(this, "streamType", n), C.defSet(this, "streamType", o), this._duration = -1, C.defGet(this, "duration", p), C.defSet(this, "duration", q), this._encodedFrameRate = -1, C.defGet(this, "encodedFrameRate", r),
          C.defSet(this, "encodedFrameRate", s), t.apply(this, arguments), this.clone = function() {
            var a = new e;
            a.assetName = this.assetName, a.applicationName = this.applicationName, a.streamUrl = this.streamUrl, a.viewerId = this.viewerId,
              a.defaultResource = this.defaultResource, a.streamType = this.streamType, a.duration = this.duration, a.encodedFrameRate = this.encodedFrameRate;
            for (var b in this.custom) a.custom[b] = this.custom[b];
            return a
          }
      };
      e.StreamType = {
        UNKNOWN: "UNKNOWN",
        LIVE: "LIVE",
        VOD: "VOD"
      };
      var f = (a.ErrorType = {
          ERROR_UNKNOWN: "ERROR_UNKNOWN",
          ERROR_IO: "ERROR_IO",
          ERROR_TIMEOUT: "ERROR_TIMEOUT",
          ERROR_NULL_ASSET: "ERROR_NULL_ASSET",
          ERROR_MISSING_PARAMETER: "ERROR_MISSING_PARAMETER",
          ERROR_NO_AD_AVAILABLE: "ERROR_NO_AD_AVAILABLE",
          ERROR_PARSE: "ERROR_PARSE",
          ERROR_INVALID_VALUE: "ERROR_INVALID_VALUE",
          ERROR_INVALID_SLOT: "ERROR_INVALID_SLOT",
          ERROR_3P_COMPONENT: "ERROR_3P_COMPONENT",
          ERROR_UNSUPPORTED_3P_FEATURE: "ERROR_UNSUPPORTED_3P_FEATURE",
          ERROR_DEVICE_LIMIT: "ERROR_DEVICE_LIMIT",
          ERROR_UNMATCHED_SLOT_SIZE: "ERROR_UNMATCHED_SLOT_SIZE"
        }, a.Events = {
          AD_REQUESTED: "Conviva.AdRequested",
          AD_RESPONSE: "Conviva.AdResponse",
          AD_SLOT_STARTED: "Conviva.SlotStarted",
          AD_ATTEMPTED: "Conviva.AdAttempted",
          AD_SLOT_ENDED: "Conviva.SlotEnded",
          AD_IMPRESSION_START: "Conviva.AdImpression",
          AD_START: "Conviva.AdStart",
          AD_FIRST_QUARTILE: "Conviva.AdFirstQuartile",
          AD_MID_QUARTILE: "Conviva.AdMidQuartile",
          AD_THIRD_QUARTILE: "Conviva.AdThirdQuartile",
          AD_COMPLETE: "Conviva.AdComplete",
          AD_END: "Conviva.AdEnd",
          AD_IMPRESSION_END: "Conviva.AdImpressionEnd",
          AD_SKIPPED: "Conviva.AdSkipped",
          AD_ERROR: "Conviva.AdError",
          AD_PROGRESS: "Conviva.AdProgress",
          AD_CLOSE: "Conviva.AdClose",
          CONTENT_PAUSED: "Conviva.PauseContent",
          CONTENT_RESUMED: "Conviva.ResumeContent",
          POD_START: "Conviva.PodStart",
          POD_END: "Conviva.PodEnd"
        }, a.SystemFactory = function(a, b) {
          function c(a, b) {
            if (!(a instanceof m)) throw new Error("systemInterface parameter should be an instance of SystemInterface.");
            this._systemInterface = a, this._timeInterface = this._systemInterface._timeInterface,
              this._timerInterface = this._systemInterface._timerInterface, this._httpInterface = this._systemInterface._httpInterface, this._storageInterface = this._systemInterface._storageInterface, this._metadataInterface = this._systemInterface._metadataInterface,
              this._loggingInterface = this._systemInterface._loggingInterface, b instanceof g ? this._settings = b.clone() : this._settings = new g
          }
          var d = this;
          c.apply(this, arguments), this.configure = function(a, b) {
            this._packageName = a,
              this._clientSettings = b
          }, this.release = function() {
            this._systemInterface.release(), this._systemInterface = null, this._packageName = null, this._settings = null, this._logBuffer = null
          };
          var e = {
            build: function() {
              return new I(d._loggingInterface, d._timeInterface, d.getSettings(), d._logBuffer, d._packageName);
            }
          };
          this.buildLogger = function() {
            return e.build()
          }, this.buildSessionFactory = function(a, b, c) {
            return new w(a, b, c, this)
          }, this.buildPing = function() {
            return new E(this.buildLogger(), this.buildHttpClient(), this._clientSettings);
          }, this.buildCallbackWithTimeout = function() {
            return new x(this.buildTimer())
          }, this.buildCallbackWithTimeoutNoPing = function() {
            var a = null,
              b = new A(this.buildLogger(), a, this.getSettings()),
              c = new M(this.buildLogger(), this._timerInterface, b);
            return new x(c)
          }, this.buildHttpClient = function() {
            return new H(this.buildLogger(), this._httpInterface, this.buildCallbackWithTimeoutNoPing(), this.getSettings())
          }, this.buildExceptionCatcher = function() {
            return new A(this.buildLogger(), this.buildPing(), this.getSettings());
          }, this.buildTime = function() {
            return new L(this._timeInterface, this.buildLogger())
          }, this.buildTimer = function() {
            return new M(this.buildLogger(), this._timerInterface, this.buildExceptionCatcher())
          }, this.buildStorage = function() {
            return new J(this.buildLogger(), this._storageInterface, this.buildCallbackWithTimeout(), this.getSettings())
          }, this.buildConfig = function() {
            return new y(this.buildLogger(), this.buildStorage(), this.buildJsonInterface());
          }, this.buildSystemMetadata = function() {
            return new K(this.buildLogger(), this._metadataInterface, this.buildExceptionCatcher())
          }, this.buildCwsProtocol = function() {
            return new r
          }, this.buildGatewayControl = function(a) {
            return new B(a, this.buildLogger(), this.buildHttpClient(), this.buildJsonInterface())
          }, this.buildCwsSession = function(a, b, c) {
            var d = this.buildGatewayControl(b);
            return new u(this.buildEventQueue(), a, b, this.buildLogger(), this.buildExceptionCatcher(), this.buildTimer(), d, this.buildCwsProtocol(), this.buildTime(), this.getLogBuffer(), c);
          }, this.buildSession = function(a, b, c, d, e, f) {
            var g = this.buildExceptionCatcher(),
              h = this.buildLogger(),
              i = b.clone(),
              j = this.buildCwsSession(a, i, c);
            return new v(d, e, f, c, this.buildSystemMetadata(), j, g, h)
          }, this.buildEventQueue = function() {
            return new z
          }, this.buildJsonInterface = function() {
            return new s
          }, this.getLogBuffer = function() {
            return this._logBuffer
          }, this.getSettings = function() {
            return this._settings
          }, this._logBuffer = new D
        }),
        g = a.SystemSettings = function() {
          function a() {}
          this._logLevel = g.defaultProductionLogLevel, C.defGet(this, "logLevel", function() {
            return this._logLevel
          }), C.defSet(this, "logLevel", function(a) {
            if ("number" == typeof a) {
              var b = C.NumberToUnsignedInt(a);
              b === a && b >= g.LogLevel.DEBUG && b <= g.LogLevel.ERROR && (this._logLevel = b)
            }
          }), this._allowUncaughtExceptions = g.defaultProductionAllowUncaughtExceptions, C.defGet(this, "allowUncaughtExceptions", function() {
            return this._allowUncaughtExceptions;
          }), C.defSet(this, "allowUncaughtExceptions", function(a) {
            C.isBoolean(a) && (this._allowUncaughtExceptions = a)
          }), this._storageTimeout = g.defaultStorageTimeout, C.defGet(this, "storageTimeout", function() {
            return this._storageTimeout;
          }), C.defSet(this, "storageTimeout", function(a) {
            if ("number" == typeof a) {
              var b = C.NumberToUnsignedInt(a);
              b === a && (this._storageTimeout = b)
            }
          }), this._httpTimeout = g.defaultHttpTimeout, C.defGet(this, "httpTimeout", function() {
            return this._httpTimeout
          }), C.defSet(this, "httpTimeout", function(a) {
            if ("number" == typeof a) {
              var b = C.NumberToUnsignedInt(a);
              b === a && (this._httpTimeout = b)
            }
          }), a.apply(this, arguments), this.equals = function(a) {
            return this.logLevel === a.logLevel && this.allowUncaughtExceptions === a.allowUncaughtExceptions && this.storageTimeout === a.storageTimeout && this.httpTimeout === a.httpTimeout
          }, this.clone = function() {
            var a = new g;
            return a.logLevel = this.logLevel,
              a.allowUncaughtExceptions = this.allowUncaughtExceptions, a.storageTimeout = this.storageTimeout, a.httpTimeout = this.httpTimeout, a
          }
        };
      g.LogLevel = {
          DEBUG: 0,
          INFO: 1,
          WARNING: 2,
          ERROR: 3,
          NONE: 4
        }, g.defaultDevelopmentLogLevel = g.LogLevel.DEBUG,
        g.defaultProductionLogLevel = g.LogLevel.ERROR, g.defaultDevelopmentAllowUncaughtExceptions = !0, g.defaultProductionAllowUncaughtExceptions = !1, g.defaultStorageTimeout = 10, g.defaultHttpTimeout = 10;
      var h = a.PlayerStateManager = function(c) {
        function d(a) {
          e._systemFactory = a, e._logger = e._systemFactory.buildLogger(), e._logger.setModuleName("PlayerStateManager"), e._exceptionCatcher = e._systemFactory.buildExceptionCatcher()
        }
        var e = this;
        e._monitorNotifier = null,
          e._bitrateKbps = -2, e._playerState = h.PlayerState.UNKNOWN, e._currentMetadata = {}, e._renderedFrameRate = -2, e._encodedFrameRate = -2, e._duration = -2, e._playerVersion = null, e._playerType = null, e._streamUrl = null, e._moduleName = null,
          e._moduleVersion = null, e._width = -1, e._height = -1, e._connectionType = null, e._linkEncryption = null, e._lastError = null, e._pendingErrors = [], e._released = !1, this.release = function() {
            e._released || e._exceptionCatcher.runProtected("PlayerStateManager.release", function() {
              null != e._monitorNotifier && e._monitorNotifier.onRelease(), e.removeMonitoringNotifier(), e._systemFactory = null, e._logger = null, e._exceptionCatcher = null, e._released = !0
            })
          }, this.setPlayheadTime = function(a) {},
          this.setBufferLength = function(a) {}, this.setRenderedFrameRate = function(a) {}, this.getEncodedFrameRate = function() {
            return e._encodedFrameRate
          }, this.setEncodedFrameRate = function(a) {
            e._released || e._exceptionCatcher.runProtected("PlayerStateManager.setEncodedFrameRate", function() {
              var b = G.sanitizeSpecialIntegerValue(a);
              b >= -1 && (e._encodedFrameRate = b, null != e._monitorNotifier && e._monitorNotifier.onEncodedFrameRateChange(e._encodedFrameRate))
            })
          }, this.getDuration = function() {
            return e._duration;
          }, this.setClientMeasureInterface = function(b) {
            C.validateInterface(b, new a.ClientMeasureInterface, "ClientMeasureInterface"), this._playerInterface = b
          }, this.getPHT = function() {
            return this._playerInterface && "function" == typeof this._playerInterface.getPHT ? this._playerInterface.getPHT() : h.DEFAULT_PHT;
          }, this.getBufferLength = function() {
            return this._playerInterface && "function" == typeof this._playerInterface.getBufferLength ? this._playerInterface.getBufferLength() : h.DEFAULT_BUFFER_LENGTH
          }, this.getSignalStrength = function() {
            return this._playerInterface && "function" == typeof this._playerInterface.getSignalStrength ? this._playerInterface.getSignalStrength() : h.DEFAULT_SIGNAL_STRENGTH
          }, this.getRenderedFrameRate = function() {
            return this._playerInterface && "function" == typeof this._playerInterface.getRenderedFrameRate ? this._playerInterface.getRenderedFrameRate() : h.DEFAULT_RENDERED_FRAME_RATE;
          }, this.setDuration = function(a) {
            e._released || e._exceptionCatcher.runProtected("PlayerStateManager.setDuration", function() {
              var b = G.sanitizeSpecialIntegerValue(a);
              b >= -1 && (e._duration = b, null != e._monitorNotifier && e._monitorNotifier.onContentLengthChange(e._duration));
            })
          }, this.getStreamUrl = function() {
            return e._streamUrl
          }, this.setStreamUrl = function(a) {
            e._released || e._exceptionCatcher.runProtected("PlayerStateManager.setStreamUrl", function() {
              null != a && (e._streamUrl = a, null != e._monitorNotifier && e._monitorNotifier.onStreamUrlChange(e._streamUrl));
            })
          }, this.getModuleName = function() {
            return e._moduleName
          }, this.getModuleVersion = function() {
            return e._moduleVersion
          }, this.setModuleNameAndVersion = function(a, b) {
            e._moduleName = a, e._moduleVersion = b
          }, this.getPlayerType = function() {
            return e._playerType
          }, this.setPlayerType = function(a) {
            e._released || e._exceptionCatcher.runProtected("PlayerStateManager.setPlayerType", function() {
              e._playerType = a, null != e._monitorNotifier && e._monitorNotifier.onPlayerTypeChange(e._playerType);
            })
          }, this.getPlayerVersion = function() {
            return e._playerVersion
          }, this.setPlayerVersion = function(a) {
            e._released || e._exceptionCatcher.runProtected("PlayerStateManager.setPlayerVersion", function() {
              e._playerVersion = a,
                null != e._monitorNotifier && e._monitorNotifier.onPlayerVersionChange(e._playerVersion)
            })
          }, this.setMonitoringNotifier = function(a, b) {
            return e._released ? void 0 : null != e._monitorNotifier ? !1 : (e._monitorNotifier = a, e._logger.setSessionId(b), !0)
          }, this.removeMonitoringNotifier = function() {
            e._released || (e._monitorNotifier = null, e._logger.setSessionId(null))
          }, this.pushCurrentState = function() {
            e.setPlayerState(e.getPlayerState()),
              e.setBitrateKbps(e.getBitrateKbps()), e.setDuration(e.getDuration()), e.setEncodedFrameRate(e.getEncodedFrameRate()), e.setStreamUrl(e.getStreamUrl()), e.setPlayerType(e.getPlayerType()), e.setPlayerVersion(e.getPlayerVersion());
            for (var a = 0; a < e._pendingErrors.length; a++) {
              var b = e._pendingErrors[a];
              e.setError(b)
            }
            e._pendingErrors = []
          }, this.getPlayerState = function() {
            return e._playerState
          }, this.setPlayerState = function(a) {
            e._released || e._exceptionCatcher.runProtected("PlayerStateManager.setPlayerState", function() {
              h.isValidPlayerState(a) ? (e._playerState = a, null != e._monitorNotifier && e._monitorNotifier.onPlayerStateChange(e._playerState)) : e._logger.error("PlayerStateManager.SetPlayerState(): invalid state: " + a)
            })
          },
          this.getBitrateKbps = function() {
            return e._bitrateKbps
          }, this.setBitrateKbps = function(a) {
            e._released || e._exceptionCatcher.runProtected("PlayerStateManager.setBitrateKbps", function() {
              var b = G.sanitizeSpecialIntegerValue(a);
              b >= -1 && (e._bitrateKbps = b, null != e._monitorNotifier && e._monitorNotifier.onBitrateChange(e._bitrateKbps))
            })
          }, this.setPlayerSeekStart = function(a) {
            e._released || e._exceptionCatcher.runProtected("PlayerStateManager.setPlayerSeekStart()", function() {
              null != e._monitorNotifier && e._monitorNotifier.onSeekEvent(h.SEEK_ACTIONS_TYPE.SEEK_START, a)
            })
          }, this.setPlayerSeekEnd = function() {
            e._released || e._exceptionCatcher.runProtected("PlayerStateManager.setPlayerSeekEnd()", function() {
              null != e._monitorNotifier && e._monitorNotifier.onSeekEvent(h.SEEK_ACTIONS_TYPE.SEEK_END, -1)
            })
          }, this.setUserSeekButtonUp = function() {
            e._released || e._exceptionCatcher.runProtected("PlayerStateManager.setUserSeekButtonUp()", function() {
              null != e._monitorNotifier && e._monitorNotifier.onSeekEvent(h.SEEK_ACTIONS_TYPE.BUTTON_UP, -1)
            })
          }, this.setUserSeekButtonDown = function() {
            e._released || e._exceptionCatcher.runProtected("PlayerStateManager.setUserSeekButtonDown()", function() {
              null != e._monitorNotifier && e._monitorNotifier.onSeekEvent(h.SEEK_ACTIONS_TYPE.BUTTON_DOWN, -1)
            })
          }, this.setVideoResolutionWidth = function(a) {
            e._released || e._exceptionCatcher.runProtected("PlayerStateManager.setVideoResolutionWidth()", function() {
              var b = G.sanitizeSpecialIntegerValue(a);
              b > 0 && (e._width = b), null != e._monitorNotifier && e._monitorNotifier.onStreamResolutionWidthChange(e._width)
            })
          }, this.setVideoResolutionHeight = function(a) {
            e._released || e._exceptionCatcher.runProtected("PlayerStateManager.setVideoResolutionHeight()", function() {
              var b = G.sanitizeSpecialIntegerValue(a);
              b > 0 && (e._height = b), null != e._monitorNotifier && e._monitorNotifier.onStreamResolutionHeightChange(e._height)
            })
          }, this.setConnectionType = function(a) {
            e._released || e._exceptionCatcher.runProtected("PlayerStateManager.setConnectionType()", function() {
              e._connectionType = a, null != e._monitorNotifier && e._monitorNotifier.onConnectionTypeChange(e._connectionType)
            })
          }, this.setLinkEncryption = function(a) {
            e._released || e._exceptionCatcher.runProtected("PlayerStateManager.setLinkEncryption()", function() {
              e._linkEncryption = a, null != e._monitorNotifier && e._monitorNotifier.onLinkEncryptionChange(e._linkEncryption)
            })
          }, this.setSignalStrength = function(a) {}, this.setError = function(a) {
            if (e._lastError = a, null != e._monitorNotifier) {
              var b = a.errorCode,
                c = a.severity;
              e._monitorNotifier.onError(b, c)
            } else e._pendingErrors.push(a)
          }, this.sendError = function(a, c) {
            e._released || e._exceptionCatcher.runProtected("PlayerStateManager.sendError", function() {
              var d = new b.StreamerError(a, c);
              e.setError(d)
            })
          }, this.reset = function() {
            e._released || e._exceptionCatcher.runProtected("PlayerStateManager.reset", function() {
              e._bitrateKbps = -2, e._playerState = h.PlayerState.UNKNOWN,
                e._currentMetadata = {}, e._renderedFrameRate = -1, e._encodedFrameRate = -1, e._duration = -1, e._playerVersion = null, e._playerType = null, e._streamUrl = null, e._lastError = null, e._pendingErrors = []
            })
          }, this.setCDNServerIP = function(a) {
            e._released || e._exceptionCatcher.runProtected("PlayerStateManager.setCDNServerIP", function() {
              null != e._monitorNotifier && e._monitorNotifier.onCDNServerIPChange(a)
            })
          }, this.getError = function() {
            return e._lastError;
          }, d.apply(e, arguments), h.DEFAULT_SIGNAL_STRENGTH = 1e3, h.DEFAULT_RENDERED_FRAME_RATE = -1, h.DEFAULT_BUFFER_LENGTH = -1, h.DEFAULT_PHT = -1
      };
      h.PlayerState = {
        STOPPED: "STOPPED",
        PLAYING: "PLAYING",
        BUFFERING: "BUFFERING",
        PAUSED: "PAUSED",
        UNKNOWN: "UNKNOWN",
        NOT_MONITORED: "NOT_MONITORED"
      }, h.isValidPlayerState = function(a) {
        return a === h.PlayerState.STOPPED || a === h.PlayerState.PLAYING || a === h.PlayerState.BUFFERING || a === h.PlayerState.PAUSED || a === h.PlayerState.UNKNOWN || a === h.PlayerState.NOT_MONITORED ? !0 : !1;
      }, h.SEEK_ACTIONS_TYPE = {
        SEEK_START: "pss",
        SEEK_END: "pse",
        BUTTON_UP: "bu",
        BUTTON_DOWN: "bd"
      };
      var i = (a.ClientMeasureInterface = function() {
          this.getPHT = function() {}, this.getBufferLength = function() {}, this.getSignalStrength = function() {},
            this.getRenderedFrameRate = function() {}
        }, a.HttpInterface = function() {
          this.makeRequest = function(a, b, c, d, e, f) {}, this.release = function() {}
        }),
        j = a.LoggingInterface = function() {
          this.consoleLog = function(a, b) {}, this.release = function() {};
        },
        k = a.MetadataInterface = function() {
          this.getBrowserName = function() {}, this.getBrowserVersion = function() {}, this.getDeviceBrand = function() {}, this.getDeviceManufacturer = function() {}, this.getDeviceModel = function() {},
            this.getDeviceType = function() {}, this.getDeviceVersion = function() {}, this.getFrameworkName = function() {}, this.getFrameworkVersion = function() {}, this.getOperatingSystemName = function() {}, this.getOperatingSystemVersion = function() {},
            this.getDeviceCategory = function() {}, this.release = function() {}
        },
        l = a.StorageInterface = function() {
          this.saveData = function(a, b, c, d) {}, this.loadData = function(a, b, c) {}, this.release = function() {}
        },
        m = a.SystemInterface = function(a, b, c, d, e, f) {
          function g(a, b, c, d, e, f) {
            C.validateInterface(a, new n, "TimeInterface"), C.validateInterface(b, new o, "TimerInterface"), C.validateInterface(c, new i, "HttpInterface"), C.validateInterface(d, new l, "StorageInterface"),
              C.validateInterface(e, new k, "MetadataInterface"), C.validateInterface(f, new j, "LoggingInterface"), this._timeInterface = a, this._timerInterface = b, this._httpInterface = c, this._storageInterface = d, this._metadataInterface = e,
              this._loggingInterface = f
          }
          g.apply(this, arguments), this.release = function() {
            this._timeInterface.release(), this._timeInterface = null, this._timerInterface.release(), this._timerInterface = null, this._httpInterface.release(),
              this._httpInterface = null, this._storageInterface.release(), this._storageInterface = null, this._metadataInterface.release(), this._metadataInterface = null, this._loggingInterface.release(), this._loggingInterface = null;
          }
        },
        n = a.TimeInterface = function() {
          this.getEpochTimeMs = function() {}, this.release = function() {}
        },
        o = a.TimerInterface = function() {
          this.createTimer = function(a, b, c) {}, this.release = function() {}
        },
        p = b.JSON2 = {};
      ! function() {
        function a(a) {
          return 10 > a ? "0" + a : a
        }

        function b(a) {
          return d.lastIndex = 0, d.test(a) ? '"' + a.replace(d, function(a) {
            var b = g[a];
            return "string" == typeof b ? b : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4)
          }) + '"' : '"' + a + '"';
        }

        function c(a, d) {
          var g, i, j, k, l, m = e,
            n = d[a];
          switch (n && "object" == typeof n && "function" == typeof n.toJSON && (n = n.toJSON(a)), "function" == typeof h && (n = h.call(d, a, n)), typeof n) {
            case "string":
              return b(n);
            case "number":
              return isFinite(n) ? String(n) : "null";
            case "boolean":
            case "null":
              return String(n);
            case "object":
              if (!n) return "null";
              if (e += f, l = [], Object.prototype.toString.apply(n) === Object.prototype.toString.apply([])) {
                for (k = n.length, g = 0; k > g; g += 1) l[g] = c(g, n) || "null";
                return j = 0 === l.length ? "[]" : e ? "[\n" + e + l.join(",\n" + e) + "\n" + m + "]" : "[" + l.join(",") + "]", e = m, j
              }
              if (h && "object" == typeof h)
                for (k = h.length, g = 0; k > g; g += 1) "string" == typeof h[g] && (i = h[g], j = c(i, n), j && l.push(b(i) + (e ? ": " : ":") + j));
              else
                for (i in n) Object.prototype.hasOwnProperty.call(n, i) && (j = c(i, n), j && l.push(b(i) + (e ? ": " : ":") + j));
              return j = 0 === l.length ? "{}" : e ? "{\n" + e + l.join(",\n" + e) + "\n" + m + "}" : "{" + l.join(",") + "}",
                e = m, j
          }
        }
        "function" != typeof Date.prototype.toJSON && (Date.prototype.toJSON = function() {
          return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + a(this.getUTCMonth() + 1) + "-" + a(this.getUTCDate()) + "T" + a(this.getUTCHours()) + ":" + a(this.getUTCMinutes()) + ":" + a(this.getUTCSeconds()) + "Z" : null;
        }, String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function() {
          return this.valueOf()
        });
        var d, e, f, g, h;
        "function" != typeof p.stringify && (d = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, g = {
          "\b": "\\b",
          "	": "\\t",
          "\n": "\\n",
          "\f": "\\f",
          "\r": "\\r",
          '"': '\\"',
          "\\": "\\\\"
        }, p.stringify = function(a, b, d) {
          var g;
          if (e = "", f = "", "number" == typeof d)
            for (g = 0; d > g; g += 1) f += " ";
          else "string" == typeof d && (f = d);
          if (h = b, b && "function" != typeof b && ("object" != typeof b || "number" != typeof b.length)) throw new Error("JSON2.stringify");
          return c("", {
            "": a
          })
        })
      }();
      var q = b.JsonParse = function() {
          var a, b, c, d, e = {
              '"': '"',
              "\\": "\\",
              "/": "/",
              b: "\b",
              f: "\f",
              n: "\n",
              r: "\r",
              t: "	"
            },
            f = function(b) {
              throw {
                name: "SyntaxError",
                message: b,
                at: a,
                text: c
              }
            },
            g = function(d) {
              return d && d !== b && f("Expected '" + d + "' instead of '" + b + "'"), b = c.charAt(a), a += 1, b
            },
            h = function() {
              var a, c = "";
              for ("-" === b && (c = "-", g("-")); b >= "0" && "9" >= b;) c += b, g();
              if ("." === b)
                for (c += "."; g() && b >= "0" && "9" >= b;) c += b;
              if ("e" === b || "E" === b)
                for (c += b, g(), ("-" === b || "+" === b) && (c += b, g()); b >= "0" && "9" >= b;) c += b, g();
              return a = +c,
                isNaN(a) ? void f("Bad number") : a
            },
            i = function() {
              var a, c, d, h = "";
              if ('"' === b)
                for (; g();) {
                  if ('"' === b) return g(), h;
                  if ("\\" === b)
                    if (g(), "u" === b) {
                      for (d = 0, c = 0; 4 > c && (a = parseInt(g(), 16), isFinite(a)); c += 1) d = 16 * d + a;
                      h += String.fromCharCode(d);
                    } else {
                      if ("string" != typeof e[b]) break;
                      h += e[b]
                    }
                  else h += b
                }
              f("Bad string")
            },
            j = function() {
              for (; b && " " >= b;) g()
            },
            k = function() {
              switch (b) {
                case "t":
                  return g("t"), g("r"), g("u"), g("e"), !0;
                case "f":
                  return g("f"), g("a"),
                    g("l"), g("s"), g("e"), !1;
                case "n":
                  return g("n"), g("u"), g("l"), g("l"), null
              }
              f("Unexpected '" + b + "'")
            },
            l = function() {
              var a = [];
              if ("[" === b) {
                if (g("["), j(), "]" === b) return g("]"), a;
                for (; b;) {
                  if (a.push(d()), j(), "]" === b) return g("]"),
                    a;
                  g(","), j()
                }
              }
              f("Bad array")
            },
            m = function() {
              var a, c = {};
              if ("{" === b) {
                if (g("{"), j(), "}" === b) return g("}"), c;
                for (; b;) {
                  if (a = i(), j(), g(":"), Object.hasOwnProperty.call(c, a) && f('Duplicate key "' + a + '"'), c[a] = d(), j(), "}" === b) return g("}"), c;
                  g(","), j()
                }
              }
              f("Bad object")
            };
          return d = function() {
              switch (j(), b) {
                case "{":
                  return m();
                case "[":
                  return l();
                case '"':
                  return i();
                case "-":
                  return h();
                default:
                  return b >= "0" && "9" >= b ? h() : k();
              }
            },
            function(e, g) {
              var h;
              return c = e, a = 0, b = " ", h = d(), j(), b && f("Syntax error"), "function" == typeof g ? function i(a, b) {
                var c, d, e = a[b];
                if (e && "object" == typeof e)
                  for (c in e) Object.hasOwnProperty.call(e, c) && (d = i(e, c), void 0 !== d ? e[c] = d : delete e[c]);
                return g.call(a, b, e)
              }({
                "": h
              }, "") : h
            }
        }(),
        r = b.CwsProtocol = function() {
          this.generateEvent = function(a, b, c, d) {
            return d.seq = a, d.st = b, d.t = c, d
          }, this.generateSessionEndEvent = function(a, b) {
            var c = r.EVENT_TYPE_SESSION_END,
              d = {};
            return this.generateEvent(a, b, c, d)
          }
        };
      r.version = "2.4", r.gatewayPath = "/0/wsg", r.DEFAULT_CLIENT_ID = "0", r.DEFAULT_MAX_HEARTBEAT_INFOS = 0, r.DEFAULT_PLAYHEAD_TIME = -1, r.DEFAULT_BUFFER_LENGTH = -1,
        r.DEFAULT_SIGNAL_STRENGTH = 1e3, r.SDK_METADATA_SCHEMA = "sdk.js.1", r.EVENT_TYPE_STATE_CHANGE = "CwsStateChangeEvent", r.EVENT_TYPE_ERROR = "CwsErrorEvent", r.EVENT_TYPE_SESSION_END = "CwsSessionEndEvent", r.EVENT_TYPE_CUSTOM = "CwsCustomEvent",
        r.EVENT_TYPE_SEEK = "CwsSeekEvent", r.EVENT_TYPE_DATA_SAMPLE = "CwsDataSamplesEvent", r.RESPONSE_STATUS_NO_ERRORS = "ok", r.RESPONSE_KEY_STATUS = "err", r.RESPONSE_KEY_CLIENT_ID = "clid", r.RESPONSE_KEY_CONFIG = "cfg",
        r.RESPONSE_KEY_EVENTS = "evs", r.RESPONSE_CONFIG_KEY_MAX_HEARTBEAT_INFOS = "maxhbinfos", r.RESPONSE_CONFIG_KEY_SEND_LOGS = "slg", r.RESPONSE_CONFIG_KEY_HEARTBEAT_INTERVAL = "hbi", r.RESPONSE_CONFIG_KEY_GATEWAY_URL = "gw",
        r.MESSAGE_TYPE_SESSION_HEARTBEAT = "CwsSessionHb", r.REQUEST_KEY_MESSAGE_TYPE = "t", r.REQUEST_KEY_SESSION_TIME = "st", r.REQUEST_KEY_SESSION_START_TIME = "sst", r.REQUEST_KEY_IS_LIVE = "lv", r.REQUEST_KEY_SEQUENCE_NUMBER = "seq",
        r.REQUEST_KEY_CUSTOMER_KEY = "cid", r.REQUEST_KEY_CLIENT_ID = "clid", r.REQUEST_KEY_CLIENT_VERSION = "clv", r.REQUEST_KEY_PROTOCOL_VERSION = "pver", r.REQUEST_KEY_INSTANCE_ID = "iid", r.REQUEST_KEY_SESSION_ID = "sid", r.REQUEST_KEY_VIEWER_ID = "vid",
        r.REQUEST_KEY_ASSET_NAME = "an", r.REQUEST_KEY_PLAYER_NAME = "pn", r.REQUEST_KEY_TAGS = "tags", r.REQUEST_KEY_SESSION_FLAGS = "sf", r.REQUEST_KEY_EVENTS = "evs", r.REQUEST_KEY_LOGS = "lg", r.REQUEST_KEY_HEARTBEAT_INFOS = "hbinfos",
        r.REQUEST_KEY_IS_SDK_CLIENT = "sdk", r.REQUEST_KEY_PAUSE_JOIN = "pj", r.REQUEST_KEY_PLAYER_STATE = "ps", r.REQUEST_KEY_BITRATE = "br", r.REQUEST_KEY_CONTENT_LENGTH = "cl", r.REQUEST_KEY_ENCODED_FRAME_RATE = "efps", r.REQUEST_KEY_AVERAGE_FRAME_RATE = "afps",
        r.REQUEST_KEY_RFPS_TOTAL = "rfpstot", r.REQUEST_KEY_RFPS_COUNT = "rfpscnt", r.REQUEST_KEY_RESOURCE = "rs", r.REQUEST_KEY_PLAYHEAD_TIME = "pht", r.REQUEST_KEY_BUFFER_LENGTH = "bl", r.REQUEST_KEY_STREAM_URL = "url", r.REQUEST_KEY_CAPABILITIES = "caps",
        r.REQUEST_KEY_PLATFORM_METADATA = "pm", r.REQUEST_KEY_VIDEO_WIDTH = "w", r.REQUEST_KEY_VIDEO_HEIGHT = "h", r.REQUEST_KEY_CONNECTION_TYPE = "ct", r.REQUEST_KEY_LINK_ENCRYPTION = "le", r.REQUEST_KEY_SIGNAL_STRENGTH = "ss",
        r.REQUEST_KEY_STREAM_METADATA_CHANGE = "strmetadata", r.REQUEST_PLATFORM_METADATA_KEY_SCHEMA = "sch", r.REQUEST_PLATFORM_METADATA_KEY_BROWSER_NAME = "br", r.REQUEST_PLATFORM_METADATA_KEY_BROWSER_VERSION = "brv", r.REQUEST_PLATFORM_METADATA_KEY_DEVICE_BRAND = "dvb",
        r.REQUEST_PLATFORM_METADATA_KEY_DEVICE_MANUFACTURER = "dvma", r.REQUEST_PLATFORM_METADATA_KEY_DEVICE_MODEL = "dvm", r.REQUEST_PLATFORM_METADATA_KEY_DEVICE_TYPE = "dvt", r.REQUEST_PLATFORM_METADATA_KEY_DEVICE_VERSION = "dvv",
        r.REQUEST_PLATFORM_METADATA_KEY_FRAMEWORK_NAME = "fw", r.REQUEST_PLATFORM_METADATA_KEY_FRAMEWORK_VERSION = "fwv", r.REQUEST_PLATFORM_METADATA_KEY_CLIENT_CONFIGURATION = "cc", r.REQUEST_PLATFORM_METADATA_KEY_MODULE_NAME = "mn",
        r.REQUEST_PLATFORM_METADATA_KEY_MODULE_VERSION = "mv", r.REQUEST_PLATFORM_METADATA_KEY_OPERATING_SYSTEM_NAME = "os", r.REQUEST_PLATFORM_METADATA_KEY_OPERATING_SYSTEM_VERSION = "osv", r.REQUEST_PLATFORM_METADATA_KEY_DEVICE_CATEGORY = "cat",
        r.REQUEST_KEY_PROTOCOL_CAPP = "caps", r.REQUEST_EVENT_KEY_TYPE = "t", r.REQUEST_EVENT_KEY_SEQUENCE_NUMBER = "seq", r.REQUEST_EVENT_KEY_SESSION_TIME = "st", r.REQUEST_EVENT_KEY_SEEK_ACT_TYPE = "act", r.REQUEST_EVENT_KEY_SEEK_TO_POS = "skto",
        r.REQUEST_ERROR_EVENT_KEY_MESSAGE = "err", r.REQUEST_ERROR_EVENT_KEY_FATAL = "ft", r.REQUEST_STATE_CHANGE_EVENT_KEY_NEW = "new", r.REQUEST_STATE_CHANGE_EVENT_KEY_OLD = "old", r.REQUEST_CUSTOM_EVENT_KEY_NAME = "name",
        r.REQUEST_CUSTOM_EVENT_KEY_ATTRIBUTES = "attr", r.REQUEST_HEARTBEAT_INFO_KEY_SEQUENCE_NUMBER = "seq", r.REQUEST_HEARTBEAT_INFO_KEY_STATUS = "err", r.REQUEST_HEARTBEAT_INFO_KEY_ROUNDTRIP_TIME = "rtt", r.REQUEST_KEY_IS_AD_SESSION = "ad",
        r.REQUEST_CDN_SERVER_IP = "csi", r.convertPlayerState = function(a) {
          switch (a) {
            case h.PlayerState.STOPPED:
              return r.eStopped;
            case h.PlayerState.PLAYING:
              return r.ePlaying;
            case h.PlayerState.BUFFERING:
              return r.eBuffering;
            case h.PlayerState.PAUSED:
              return r.ePaused;
            case h.PlayerState.NOT_MONITORED:
              return r.eNotMonitored;
            default:
              return r.eUnknown
          }
        }, r.eStopped = 1, r.ePlaying = 3, r.eBuffering = 6, r.ePaused = 12, r.eNotMonitored = 98, r.eUnknown = 100,
        r.SessionFlags = {
          GLOBAL: 0,
          VIDEO: 1,
          QUALITY_METRICS: 2,
          BITRATE_METRICS: 4
        }, r.Capabilities = {
          INSIGHTS: 0
        };
      var s = (b.JSONInterface = function() {
          this.encode = function(a) {}, this.decode = function(a) {}
        }, b.LibJSONInterface = function() {
          this.encode = function(a) {
            var b = null;
            try {
              b = p.stringify(a)
            } catch (c) {}
            return b
          }, this.decode = function(a) {
            var b = null;
            try {
              b = q(a)
            } catch (c) {}
            return C.isObject(b) || (b = null), b
          }
        }),
        t = b.CwsHeartbeat = function() {
          function a() {}
          this._data = {}, a.apply(this, arguments), this.get = function() {
            return this._data
          }, this.setField = function(a, b) {
            this._data[a] = b
          }, this.setInnerField = function(a, b, c) {
            this._data[a] || (this._data[a] = {}), this._data[a][b] = c;
          }, this.setMessageType = function(a) {
            this.setField(r.REQUEST_KEY_MESSAGE_TYPE, a)
          }, this.setSessionTime = function(a) {
            this.setField(r.REQUEST_KEY_SESSION_TIME, a)
          }, this.setSessionStartTime = function(a) {
            this.setField(r.REQUEST_KEY_SESSION_START_TIME, a);
          }, this.setIsLive = function(a) {
            this.setField(r.REQUEST_KEY_IS_LIVE, a)
          }, this.setSequenceNumber = function(a) {
            this.setField(r.REQUEST_KEY_SEQUENCE_NUMBER, a)
          }, this.setCustomerKey = function(a) {
            this.setField(r.REQUEST_KEY_CUSTOMER_KEY, a);
          }, this.setClientId = function(a) {
            this.setField(r.REQUEST_KEY_CLIENT_ID, a)
          }, this.setClientVersion = function(a) {
            this.setField(r.REQUEST_KEY_CLIENT_VERSION, a)
          }, this.setProtocolVersion = function(a) {
            this.setField(r.REQUEST_KEY_PROTOCOL_VERSION, a);
          }, this.setCapfield = function(a) {
            this.setField(r.REQUEST_KEY_PROTOCOL_CAPP, a)
          }, this.setSessionId = function(a) {
            this.setField(r.REQUEST_KEY_SESSION_ID, a)
          }, this.setInstanceId = function(a) {
            this.setField(r.REQUEST_KEY_INSTANCE_ID, a);
          }, this.setViewerId = function(a) {
            this.setField(r.REQUEST_KEY_VIEWER_ID, a)
          }, this.setAssetName = function(a) {
            this.setField(r.REQUEST_KEY_ASSET_NAME, a)
          }, this.setPlayerName = function(a) {
            this.setField(r.REQUEST_KEY_PLAYER_NAME, a);
          }, this.setTags = function(a) {
            this.setField(r.REQUEST_KEY_TAGS, a)
          }, this.setSessionFlags = function(a) {
            this.setField(r.REQUEST_KEY_SESSION_FLAGS, a)
          }, this.setCapabilities = function(a) {
            this.setField(r.REQUEST_KEY_CAPABILITIES, a);
          }, this.setEvents = function(a) {
            this.setField(r.REQUEST_KEY_EVENTS, a)
          }, this.setIsSdkClient = function(a) {
            this.setField(r.REQUEST_KEY_IS_SDK_CLIENT, a)
          }, this.setLogs = function(a) {
            this.setField(r.REQUEST_KEY_LOGS, a);
          }, this.setHeartbeatInfos = function(a) {
            this.setField(r.REQUEST_KEY_HEARTBEAT_INFOS, a)
          }, this.setPlayerState = function(a) {
            this.setField(r.REQUEST_KEY_PLAYER_STATE, a)
          }, this.setPauseJoin = function(a) {
            this.setField(r.REQUEST_KEY_PAUSE_JOIN, a);
          }, this.setContentLength = function(a) {
            this.setField(r.REQUEST_KEY_CONTENT_LENGTH, a)
          }, this.setBitrate = function(a) {
            this.setField(r.REQUEST_KEY_BITRATE, a)
          }, this.setResource = function(a) {
            this.setField(r.REQUEST_KEY_RESOURCE, a);
          }, this.setEncodedFrameRate = function(a) {
            this.setField(r.REQUEST_KEY_ENCODED_FRAME_RATE, a)
          }, this.setAverageFrameRate = function(a) {
            this.setField(r.REQUEST_KEY_AVERAGE_FRAME_RATE, a)
          }, this.setRfpsObservationCount = function(a) {
            this.setField(r.REQUEST_KEY_RFPS_COUNT, a)
          }, this.setRfpsTotal = function(a) {
            this.setField(r.REQUEST_KEY_RFPS_TOTAL, a)
          }, this.setPlatformMetadataSchema = function(a) {
            this.setInnerField(r.REQUEST_KEY_PLATFORM_METADATA, r.REQUEST_PLATFORM_METADATA_KEY_SCHEMA, a);
          }, this.setBrowserName = function(a) {
            this.setInnerField(r.REQUEST_KEY_PLATFORM_METADATA, r.REQUEST_PLATFORM_METADATA_KEY_BROWSER_NAME, a)
          }, this.setBrowserVersion = function(a) {
            this.setInnerField(r.REQUEST_KEY_PLATFORM_METADATA, r.REQUEST_PLATFORM_METADATA_KEY_BROWSER_VERSION, a);
          }, this.setDeviceBrand = function(a) {
            this.setInnerField(r.REQUEST_KEY_PLATFORM_METADATA, r.REQUEST_PLATFORM_METADATA_KEY_DEVICE_BRAND, a)
          }, this.setDeviceManufacturer = function(a) {
            this.setInnerField(r.REQUEST_KEY_PLATFORM_METADATA, r.REQUEST_PLATFORM_METADATA_KEY_DEVICE_MANUFACTURER, a);
          }, this.setDeviceModel = function(a) {
            this.setInnerField(r.REQUEST_KEY_PLATFORM_METADATA, r.REQUEST_PLATFORM_METADATA_KEY_DEVICE_MODEL, a)
          }, this.setDeviceType = function(a) {
            this.setInnerField(r.REQUEST_KEY_PLATFORM_METADATA, r.REQUEST_PLATFORM_METADATA_KEY_DEVICE_TYPE, a);
          }, this.setDeviceVersion = function(a) {
            this.setInnerField(r.REQUEST_KEY_PLATFORM_METADATA, r.REQUEST_PLATFORM_METADATA_KEY_DEVICE_VERSION, a)
          }, this.setFrameworkName = function(a) {
            this.setInnerField(r.REQUEST_KEY_PLATFORM_METADATA, r.REQUEST_PLATFORM_METADATA_KEY_FRAMEWORK_NAME, a),
              this.setField(r.REQUEST_PLATFORM_METADATA_KEY_FRAMEWORK_NAME, a)
          }, this.setFrameworkVersion = function(a) {
            this.setInnerField(r.REQUEST_KEY_PLATFORM_METADATA, r.REQUEST_PLATFORM_METADATA_KEY_FRAMEWORK_VERSION, a),
              this.setField(r.REQUEST_PLATFORM_METADATA_KEY_FRAMEWORK_VERSION, a)
          }, this.setOperatingSystemName = function(a) {
            this.setInnerField(r.REQUEST_KEY_PLATFORM_METADATA, r.REQUEST_PLATFORM_METADATA_KEY_OPERATING_SYSTEM_NAME, a.toUpperCase());
          }, this.setOperatingSystemVersion = function(a) {
            this.setInnerField(r.REQUEST_KEY_PLATFORM_METADATA, r.REQUEST_PLATFORM_METADATA_KEY_OPERATING_SYSTEM_VERSION, a)
          }, this.setDeviceCategory = function(a) {
            this.setInnerField(r.REQUEST_KEY_PLATFORM_METADATA, r.REQUEST_PLATFORM_METADATA_KEY_DEVICE_CATEGORY, a);
          }, this.setPlayheadTime = function(a) {
            this.setField(r.REQUEST_KEY_PLAYHEAD_TIME, a)
          }, this.setBufferLength = function(a) {
            this.setField(r.REQUEST_KEY_BUFFER_LENGTH, a)
          }, this.setStreamUrl = function(a) {
            this.setField(r.REQUEST_KEY_STREAM_URL, a);
          }, this.setStreamWidth = function(a) {
            this.setField(r.REQUEST_KEY_VIDEO_WIDTH, a)
          }, this.setStreamHeight = function(a) {
            this.setField(r.REQUEST_KEY_VIDEO_HEIGHT, a)
          }, this.setConnectionType = function(a) {
            this.setField(r.REQUEST_KEY_CONNECTION_TYPE, a);
          }, this.setLinkEncryption = function(a) {
            this.setField(r.REQUEST_KEY_LINK_ENCRYPTION, a)
          }, this.setIsAdSession = function() {
            this.setField(r.REQUEST_KEY_IS_AD_SESSION, !0)
          }, this.setSignalStrength = function(a) {
            this.setField(r.REQUEST_KEY_SIGNAL_STRENGTH, a);
          }, this.setModuleName = function(a) {
            this.setInnerField(r.REQUEST_PLATFORM_METADATA_KEY_CLIENT_CONFIGURATION, r.REQUEST_PLATFORM_METADATA_KEY_MODULE_NAME, a)
          }, this.setModuleVersion = function(a) {
            this.setInnerField(r.REQUEST_PLATFORM_METADATA_KEY_CLIENT_CONFIGURATION, r.REQUEST_PLATFORM_METADATA_KEY_MODULE_VERSION, a);
          }, this.setCDNServerIP = function(a) {
            this.setField(r.REQUEST_CDN_SERVER_IP, a)
          }
        },
        u = b.CwsSession = function(a, b, d, e, f, g, i, j, k, l, m) {
          function n(a, b, c, d, e, f, g, h, i, j, k) {
            this._eventQueue = a, this._client = b, this._clientSettings = c,
              this._logger = d, this._logger.setModuleName("CwsSession"), this._exceptionCatcher = e, this._timer = f, this._gatewayControl = g, this._cwsProtocol = h, this._time = i, this._logBuffer = j, this._clientConfig = k
          }
          var o = this;
          o._heartbeatTimerCancel = null,
            o._startTimeMs = 0, o._heartbeatSequenceNumber = 0, o._sessionFlags = r.SessionFlags.GLOBAL, o._capabilities = r.Capabilities.INSIGHTS, o._heartbeatInfos = [], o._lastRequestSentMs = -1, o._bitrateKbps = -2, o._resource = null,
            o._playerState = h.PlayerState.NOT_MONITORED, o._encodedFrameRate = -1, o._contentLengthSec = -1, o._streamUrl = null, o._width = -1, o._height = -1, o._playerStateManager = null, o._assetName = null, o._viewerId = null, o._playerName = null,
            o._isLive = null, o._tags = {}, o._browserName = null, o._browserVersion = null, o._deviceBrand = null, o._deviceManufacturer = null, o._deviceModel = null, o._deviceType = null, o._deviceVersion = null, o._frameworkName = null, o._frameworkVersion = null,
            o._operatingSystemName = null, o._operatingSystemVersion = null, o._deviceCategory = null, o._moduleName = null, o._moduleVersion = null, o._connectionType = null, o._linkEncryption = null, o._cdnServerIP = null, o._pauseJoin = !1,
            o._hasJoined = !1, o._cleanedUp = !1, o._willEndSoon = !1, o._rfpsTimerCancel = null, o._rfpsTimerInterval = 1e3, o._playingFpsObservationCount = 0, o._playingFpsTotal = 0, n.apply(this, arguments), this.cleanup = function() {
              this._clientConfig = null,
                this._logBuffer = null, this._systemSettings = null, this._time = null, this._cwsProtocol = null, this._gatewayControl = null, this._timer = null, this._exceptionCatcher = null, this._logger = null, this._clientSettings = null,
                this._client = null, this._eventQueue.flush(), this._eventQueue = null, this._cleanedUp = !0
            }, this.start = function(a) {
              this._session = a, this._global = this._session._global, this._logger.setSessionId(this._session._id),
                this._startTimeMs = this._time.current(), (this.isVideoSession() || this.isAdSession()) && (this._sessionFlags += u.DEFAULT_VIDEO_SESSION_FLAGS)
            }, this.willEndSoon = function() {
              this._willEndSoon = !0
            }, this.initialize = function() {
              this._logger.debug("initialize()")
            }, this.end = function() {
              (this.isVideoSession() || this.isAdSession()) && (this._logger.debug("end(): schedule the last hb before session cleanup" + o.sessionTypeTag()), this.enqueueSessionEndEvent()),
              this.cancelHeartbeatTimer(), this.sendHeartbeat()
            }, this.startSendingHeartbeats = function() {
              this._willEndSoon || (this.sendHeartbeat(), this.resetHeartbeatTimer())
            }, this.setBrowserName = function(a) {
              o._logger.debug("setBrowserName(): " + a);
              var b = o._browserName;
              b !== a && null != a && (o._logger.debug("Change browserName from " + b + " to " + a), o._browserName = a)
            }, this.setBrowserVersion = function(a) {
              o._logger.debug("setBrowserVersion(): " + a);
              var b = o._browserVersion;
              b !== a && null != a && (o._logger.debug("Change browserVersion from " + b + " to " + a), o._browserVersion = a)
            }, this.setDeviceBrand = function(a) {
              o._logger.debug("setDeviceBrand(): " + a);
              var b = o._deviceBrand;
              b !== a && null != a && (o._logger.debug("Change deviceBrand from " + b + " to " + a), o._deviceBrand = a)
            }, this.setDeviceManufacturer = function(a) {
              o._logger.debug("setDeviceManufacturer(): " + a);
              var b = o._deviceManufacturer;
              b !== a && null != a && (o._logger.debug("Change deviceManufacturer from " + b + " to " + a), o._deviceManufacturer = a)
            }, this.setDeviceModel = function(a) {
              o._logger.debug("setDeviceModel(): " + a);
              var b = o._deviceModel;
              b !== a && null != a && (o._logger.debug("Change deviceModel from " + b + " to " + a), o._deviceModel = a);
            }, this.setDeviceType = function(a) {
              o._logger.debug("setDeviceBrand(): " + a);
              var b = o._deviceType;
              b !== a && null != a && (o._logger.debug("Change deviceType from " + b + " to " + a), o._deviceType = a)
            }, this.setDeviceVersion = function(a) {
              o._logger.debug("setDeviceVersion(): " + a);
              var b = o._deviceVersion;
              b !== a && null != a && (o._logger.debug("Change deviceVersion from " + b + " to " + a), o._deviceVersion = a)
            }, this.setOperatingSystemName = function(a) {
              o._logger.debug("setOperatingSystemName(): " + a);
              var b = o._operatingSystemName;
              b !== a && null != a && (o._logger.debug("Change operatingSystemName from " + b + " to " + a), o._operatingSystemName = a)
            }, this.setOperatingSystemVersion = function(a) {
              o._logger.debug("setOperatingSystemVersion(): " + a);
              var b = o._operatingSystemVersion;
              b !== a && null != a && (o._logger.debug("Change operatingSystemVersion from " + b + " to " + a), o._operatingSystemVersion = a)
            }, this.setDeviceCategory = function(a) {
              o._logger.debug("setDeviceCategory(): " + a);
              var b = o._deviceCategory;
              b !== a && null != a && (o._logger.debug("Change operatingSystemVersion from " + b + " to " + a), o._deviceCategory = a)
            }, this.getFrameworkName = function() {
              return o._frameworkName
            }, this.setFrameworkName = function(a) {
              o._logger.debug("setFrameworkName(): " + a);
              var b = o._frameworkName;
              b !== a && null != a && (o._logger.debug("Change frameworkName from " + b + " to " + a), o._frameworkName = a)
            }, this.getFrameworkVersion = function() {
              return o._frameworkVersion;
            }, this.setFrameworkVersion = function(a) {
              o._logger.debug("setFrameworkVersion(): " + a);
              var b = o._frameworkVersion;
              b !== a && null != a && (o._logger.debug("Change frameworkVersion from " + b + " to " + a), o._frameworkVersion = a);
            }, this.setStreamUrl = function(a) {
              o._logger.debug("setStreamUrl(): " + a);
              var b = o._streamUrl;
              b !== a && null != a && (o._logger.debug("Change stream url from " + b + " to " + a), o._streamUrl = a)
            }, this.setBitrateKbps = function(a) {
              o._logger.debug("setBitrateKbps(): " + a);
              var b = o._bitrateKbps;
              b !== a && a > 0 && (o._logger.info("Change bitrate from " + b + " to " + a), o.enqueueBitrateChangeEvent(b, a), o._bitrateKbps = a)
            }, this.setResource = function(a) {
              o._logger.debug("setResource(): " + a);
              var b = o._resource;
              b !== a && null != a && (o._logger.info("Change resource from " + b + " to " + a), o._resource = a)
            }, this.setAssetName = function(a) {
              o._logger.debug("setAssetName(): " + a),
                o._assetName !== a && null != a && (o._logger.info("Change assetName from " + o._assetName + " to " + a), o._assetName = a)
            }, this.setIsLive = function(a) {
              o._logger.debug("setIsLive(): " + a);
              var b = o._isLive;
              b !== a && null != a && (o._logger.info("Change isLive from " + b + " to " + a), o._isLive = a)
            }, this.setViewerId = function(a) {
              o._logger.debug("setViewerId(): " + a);
              var b = o._viewerId;
              b !== a && null != a && (o._logger.info("Change viewerId from " + b + " to " + a), o._viewerId = a)
            }, this.setPlayerName = function(a) {
              o._logger.debug("setPlayerName(): " + a);
              var b = o._playerName;
              b !== a && null != a && (o._logger.info("Change playerName from " + b + " to " + a), o._playerName = a)
            }, this.setTags = function(a) {
              o._logger.debug("setTags()");
              var b = o._tags;
              C.ObjectShallowEquals(b, a) || null == a || (o._logger.info("Change tags from " + C.ObjectToString(b) + " to " + C.ObjectToString(a)), o._tags = a)
            }, this.setEncodedFrameRate = function(a) {
              o._logger.debug("setEncodedFrameRate(): " + a),
                o._encodedFrameRate = a
            }, this.setContentLength = function(a) {
              o._logger.debug("setContentLength(): " + a), o._contentLengthSec = a
            }, this.setPlayerState = function(a) {
              if (o._logger.debug("setPlayerState(): " + a), o._hasJoined || a != h.PlayerState.PLAYING || (o.togglePauseJoin(!1), o._hasJoined = !0), o._playerState !== a) {
                var b = o._playerState;
                o._logger.info("setPlayerState(): changing player state from " + b + " to " + a), o.enqueuePlayerStateChangeEvent(b, a), o._playerState = a
              }
            }, this.setStreamResolutionWidth = function(a) {
              o._logger.debug("setStreamResolutionWidth(): " + a);
              var b = o._width;
              b !== a && a > 0 && (o._logger.debug("Change stream resolution width from " + b + " to " + a), o.enqueueResolutionWidthChangeEvent(b, a), o._width = a)
            }, this.setStreamResolutionHeight = function(a) {
              o._logger.debug("setStreamResolutionHeight(): " + a);
              var b = o._height;
              b !== a && a > 0 && (o._logger.debug("Change stream resolution height from " + b + " to " + a), o.enqueueResolutionHeightChangeEvent(b, a), o._height = a);
            }, this.setConnectionType = function(a) {
              o._logger.debug("setConnectionType(): " + a);
              var b = o._connectionType;
              b !== a && null != a && (o._logger.debug("Change network connection type from " + b + " to " + a), o.enqueueConnectionTypeChangeEvent(b, a), o._connectionType = a)
            }, this.setLinkEncryption = function(a) {
              o._logger.debug("setLinkEncryption(): " + a);
              var b = o._linkEncryption;
              b !== a && null != a && (o._logger.debug("Change network link encryption from " + b + " to " + a), o.enqueueLinkEncryptionChangeEvent(b, a), o._linkEncryption = a)
            }, this.setCDNServerIP = function(a) {
              o._logger.debug("setCDNServerIP(): " + a);
              var b = o._cdnServerIP;
              b !== a && C.isValidString(a) && (o._logger.debug("Change CDN Server IP from " + b + " to " + a), o.enqueueCDNServerIPChangeEvent(b, a), o._cdnServerIP = a)
            }, this.togglePauseJoin = function(a) {
              if (o._logger.debug("togglePauseJoin()"), o._pauseJoin === a) return void o._logger.debug("togglePauseJoin(): same value, ignoring");
              var b = o._pauseJoin,
                c = !o._pauseJoin;
              o.enqueuePauseJoinChangeEvent(b, c), o._pauseJoin = !o._pauseJoin
            }, this.sendError = function(a, b) {
              o.enqueueErrorEvent(a, b)
            }, this.enqueueEvent = function(a, b) {
              if (b[r.REQUEST_EVENT_KEY_TYPE] = a, b[r.REQUEST_EVENT_KEY_SESSION_TIME] = this.getSessionTime(), b[r.REQUEST_EVENT_KEY_SEQUENCE_NUMBER] = this._eventQueue.getNumber(), this._playerStateManager) {
                var c = G.Integer(this._playerStateManager.getPHT(), 0, null, -1),
                  d = G.Integer(this._playerStateManager.getBufferLength(), 0, null, -1);
                c >= 0 && (b[r.REQUEST_KEY_PLAYHEAD_TIME] = c), d > 0 && (b[r.REQUEST_KEY_BUFFER_LENGTH] = d)
              }
              this._eventQueue.enqueue(b)
            }, this.setPlayerStateManager = function(a) {
              o._playerStateManager = a, null != o._playerStateManager ? o.startRfpsTimer() : o.cancelRfpsTimer();
            }, this.enqueueSessionEndEvent = function() {
              var a = this.getSessionTime(),
                b = this.getNextEventNumber(),
                c = this._cwsProtocol.generateSessionEndEvent(b, a);
              this._eventQueue.enqueue(c)
            }, this.enqueueErrorEvent = function(a, b) {
              var c = {};
              c[r.REQUEST_ERROR_EVENT_KEY_MESSAGE] = a, c[r.REQUEST_ERROR_EVENT_KEY_FATAL] = b, this.enqueueEvent(r.EVENT_TYPE_ERROR, c)
            }, this.enqueueBitrateChangeEvent = function(a, b) {
              var c = {},
                d = {};
              a > 0 && (d[r.REQUEST_KEY_BITRATE] = a),
                c[r.REQUEST_KEY_BITRATE] = b, this.declareStateChange(c, d)
            }, this.enqueueSeekEvent = function(a, b) {
              var c = {};
              c[r.REQUEST_EVENT_KEY_SEEK_ACT_TYPE] = a, b >= 0 && (c[r.REQUEST_EVENT_KEY_SEEK_TO_POS] = b), this.enqueueEvent(r.EVENT_TYPE_SEEK, c);
            }, this.enqueueResolutionWidthChangeEvent = function(a, b) {
              var c = {},
                d = {}; - 1 !== a && (d[r.REQUEST_KEY_VIDEO_WIDTH] = a), c[r.REQUEST_KEY_VIDEO_WIDTH] = b, this.declareStateChange(c, d)
            }, this.enqueueResolutionHeightChangeEvent = function(a, b) {
              var c = {},
                d = {}; - 1 !== a && (d[r.REQUEST_KEY_VIDEO_HEIGHT] = a), c[r.REQUEST_KEY_VIDEO_HEIGHT] = b, this.declareStateChange(c, d)
            }, this.enqueueConnectionTypeChangeEvent = function(a, b) {
              var c = {},
                d = {};
              null !== a && (d[r.REQUEST_KEY_CONNECTION_TYPE] = a),
                c[r.REQUEST_KEY_CONNECTION_TYPE] = b, this.declareStateChange(c, d)
            }, this.enqueueLinkEncryptionChangeEvent = function(a, b) {
              var c = {},
                d = {};
              null !== a && (d[r.REQUEST_KEY_LINK_ENCRYPTION] = a), c[r.REQUEST_KEY_LINK_ENCRYPTION] = b,
                this.declareStateChange(c, d)
            }, this.enqueueCDNServerIPChangeEvent = function(a, b) {
              var c = {},
                d = {};
              C.isValidString(a) && (d[r.REQUEST_CDN_SERVER_IP] = a), c[r.REQUEST_CDN_SERVER_IP] = b, this.declareStateChange(c, d);
            }, this.enqueuePauseJoinChangeEvent = function(a, b) {
              var c = {},
                d = {};
              d[r.REQUEST_KEY_PAUSE_JOIN] = a, c[r.REQUEST_KEY_PAUSE_JOIN] = b, this.declareStateChange(c, d)
            }, this.enqueuePlayerStateChangeEvent = function(a, b) {
              var c = {},
                d = {};
              c[r.REQUEST_KEY_PLAYER_STATE] = r.convertPlayerState(b), d[r.REQUEST_KEY_PLAYER_STATE] = r.convertPlayerState(a), this.declareStateChange(c, d)
            }, this.declareStateChange = function(a, b) {
              var c = {};
              c[r.REQUEST_STATE_CHANGE_EVENT_KEY_NEW] = a,
                null != b && C.dictCount(b) > 0 && (c[r.REQUEST_STATE_CHANGE_EVENT_KEY_OLD] = b), this.enqueueEvent(r.EVENT_TYPE_STATE_CHANGE, c)
            }, this.enqueueCustomEvent = function(a, b) {
              var c = {};
              c[r.REQUEST_CUSTOM_EVENT_KEY_NAME] = a,
                c[r.REQUEST_CUSTOM_EVENT_KEY_ATTRIBUTES] = b, this.enqueueEvent(r.EVENT_TYPE_CUSTOM, c)
            }, this.cancelHeartbeatTimer = function() {
              null != o._heartbeatTimerCancel && (o._heartbeatTimerCancel(), o._heartbeatTimerCancel = null);
            }, this.resetHeartbeatTimer = function() {
              o.cancelHeartbeatTimer();
              var a = 1e3 * o._clientSettings.heartbeatInterval;
              o._heartbeatTimerCancel = o._timer.create(o.sendHeartbeat, a, "Session.sendHeartbeat")
            }, this.cancelRfpsTimer = function() {
              null != o._rfpsTimerCancel && (o._rfpsTimerCancel(), o._rfpsTimerCancel = null)
            }, this.startRfpsTimer = function() {
              o.cancelRfpsTimer(), o._rfpsTimerCancel = o._timer.create(o.countRfps, o._rfpsTimerInterval, "Session.startRfpsTimer");
            }, this.createHeartbeatInfo = function() {
              var a = {};
              a.err = "pending", a.seq = o._heartbeatSequenceNumber - 1, a.sentAt = o.getSessionTime(), a.rtt = -1, o._heartbeatInfos.push(a)
            }, this.updateHeartbeatInfoOnFailure = function(a, b) {
              for (var c = 0; c < o._heartbeatInfos.length; c++) {
                var d = o._heartbeatInfos[c],
                  e = d.seq;
                e === a && (d.rtt = o.getSessionTime() - d.sentAt, d.err = b)
              }
            }, this.updateHeartbeatInfoOnSuccess = function(a) {
              for (var b = 0; b < o._heartbeatInfos.length; b++) {
                var c = o._heartbeatInfos[b],
                  d = c.seq;
                d === a && (c.rtt = o.getSessionTime() - c.sentAt, c.err = "ok")
              }
            }, this.removeOutdatedHeartbeatInfos = function() {
              for (var a, b, c = o._clientConfig.get(y.CONFIG_KEY_MAX_HEARTBEAT_INFOS), d = [], e = 0; e < o._heartbeatInfos.length; e++) b = o._heartbeatInfos[e],
                a = b.seq, a < o._heartbeatSequenceNumber - c && d.push(e);
              for (var f = [], g = 0; g < o._heartbeatInfos.length; g++) b = o._heartbeatInfos[g], a = b.seq, d.indexOf(g) < 0 && f.push(o._heartbeatInfos[g]);
              o._heartbeatInfos = f
            }, this.compileHeartbeatInfos = function() {
              o.removeOutdatedHeartbeatInfos();
              for (var a = [], b = 0; b < o._heartbeatInfos.length; b++) {
                var c = o._heartbeatInfos[b],
                  d = {};
                d[r.REQUEST_HEARTBEAT_INFO_KEY_SEQUENCE_NUMBER] = c.seq, d[r.REQUEST_HEARTBEAT_INFO_KEY_ROUNDTRIP_TIME] = c.rtt,
                  d[r.REQUEST_HEARTBEAT_INFO_KEY_STATUS] = c.err, a.push(d)
              }
              return a
            }, this.makeHeartbeat = function() {
              var a = o._eventQueue.flush();
              if (o.isGlobalSession() && 0 === a.length) return null;
              var b = new t;
              if (b.setMessageType(r.MESSAGE_TYPE_SESSION_HEARTBEAT), b.setCustomerKey(o._clientSettings.customerKey), b.setClientId(o._clientConfig.get(y.CONFIG_KEY_CLIENT_ID)), b.setSessionId(o._session._id), b.setSequenceNumber(o._heartbeatSequenceNumber), b.setProtocolVersion(r.version), b.setClientVersion(c.version), b.setInstanceId(o._client.getId()), b.setCapfield(0), null != o._connectionType && b.setConnectionType(o._connectionType), null != o._linkEncryption && b.setLinkEncryption(o._linkEncryption), C.isValidString(o._cdnServerIP) && b.setCDNServerIP(o._cdnServerIP), b.setPlatformMetadataSchema(r.SDK_METADATA_SCHEMA), null != o._browserName && b.setBrowserName(o._browserName), null != o._browserVersion && b.setBrowserVersion(o._browserVersion), null != o._deviceBrand && b.setDeviceBrand(o._deviceBrand), null != o._deviceManufacturer && b.setDeviceManufacturer(o._deviceManufacturer), null != o._deviceModel && b.setDeviceModel(o._deviceModel), null != o._deviceType && b.setDeviceType(o._deviceType), null != o._deviceVersion && b.setDeviceVersion(o._deviceVersion), null != o._frameworkName && b.setFrameworkName(o._frameworkName), null != o._frameworkVersion && b.setFrameworkVersion(o._frameworkVersion), null != o._operatingSystemName && b.setOperatingSystemName(o._operatingSystemName), null != o._operatingSystemVersion && b.setOperatingSystemVersion(o._operatingSystemVersion), null != o._deviceCategory && b.setDeviceCategory(o._deviceCategory), null != o._playerStateManager && (o._moduleName = o._playerStateManager.getModuleName(), null != o._moduleName && b.setModuleName(o._moduleName)), null != o._playerStateManager && (o._moduleVersion = o._playerStateManager.getModuleVersion(), null != o._moduleVersion && b.setModuleVersion(o._moduleVersion)), null != o._viewerId && b.setViewerId(o._viewerId), C.dictCount(o._tags) > 0 && b.setTags(o._tags), o.isVideoSession() || o.isAdSession()) {
                o.isAdSession() && b.setIsAdSession(), null != o._assetName && b.setAssetName(o._assetName),
                  b.setSessionFlags(o._sessionFlags);
                var d = r.convertPlayerState(o._playerState);
                b.setPlayerState(d), b.setPauseJoin(o._pauseJoin), null != o._playerName && b.setPlayerName(o._playerName), null != o._isLive && b.setIsLive(o._isLive),
                  o._contentLengthSec > 0 && b.setContentLength(o._contentLengthSec), o._bitrateKbps > 0 && b.setBitrate(o._bitrateKbps), null !== o._resource && b.setResource(o._resource), o._encodedFrameRate > 0 && b.setEncodedFrameRate(o._encodedFrameRate);
                var e, f, g;
                null != o._playerStateManager && (e = G.Integer(o._playerStateManager.getPHT(), 0, null, -1), f = G.Integer(o._playerStateManager.getBufferLength(), 0, null, -1), g = o._playerStateManager.getSignalStrength()),
                  e >= 0 && b.setPlayheadTime(e), f > 0 && b.setBufferLength(f);
                var h = o.updateAverageFrameRate();
                h > 0 && b.setAverageFrameRate(h), o._playingFpsTotal > 0 && b.setRfpsTotal(G.Integer(o._playingFpsTotal, 0, null, -1)), o._playingFpsObservationCount > 0 && b.setRfpsObservationCount(G.Integer(o._playingFpsObservationCount, 0, null, -1)),
                  0 >= g && b.setSignalStrength(g), null != o._streamUrl && b.setStreamUrl(o._streamUrl), o._width > 0 && b.setStreamWidth(o._width), o._height > 0 && b.setStreamHeight(o._height)
              } else b.setSessionFlags(r.SessionFlags.GLOBAL);
              if (a.length > 0 && b.setEvents(a), b.setCapabilities(o._capabilities), b.setIsSdkClient(!0), o._clientConfig.get(y.CONFIG_KEY_SEND_LOGS) && b.setLogs(o._logBuffer.flush()), o._clientConfig.get(y.CONFIG_KEY_MAX_HEARTBEAT_INFOS) > 0) {
                var i = o.compileHeartbeatInfos();
                i.length > 0 && b.setHeartbeatInfos(i)
              }
              return b.setSessionStartTime(o._startTimeMs), b.setSessionTime(o.getSessionTime()), o._heartbeatSequenceNumber++, b.get()
            }, this.sendHeartbeat = function() {
              if (!o._cleanedUp) {
                var a = o.makeHeartbeat();
                null != a && o.postHeartbeat(a)
              }
            }, this.countRfps = function() {
              if (o._playerState === h.PlayerState.PLAYING) {
                var a = o._playerStateManager.getRenderedFrameRate();
                a >= 0 && (o._playingFpsTotal += a, o._playingFpsObservationCount++)
              }
            }, this.updateAverageFrameRate = function() {
              if (o._playerState === h.PlayerState.PLAYING) {
                var a = o._playerStateManager.getRenderedFrameRate();
                if (a >= 0) {
                  o._playingFpsTotal += a, o._playingFpsObservationCount++;
                  var b = C.Int32.Cast(1 * o._playingFpsTotal / o._playingFpsObservationCount);
                  return b
                }
                return -1
              }
              return -1
            }, this.postHeartbeat = function(a) {
              o.createHeartbeatInfo();
              var b = o._heartbeatSequenceNumber - 1;
              o._logger.info("postHeartbeat(): Send HB[" + b + "]" + o.sessionTypeTag());
              var c = function(a, c) {
                o.onHeartbeatResponse(a, c, b)
              };
              o._gatewayControl.send(a, c)
            }, this.onHeartbeatResponse = function(a, b, c) {
              o._cleanedUp || o._exceptionCatcher.runProtected("onHeartbeatResponse", function() {
                if (a) {
                  var d = b;
                  if (null != d) {
                    o._logger.debug("onHeartbeatResponse(): received valid response for HB[" + c + "]"), o.updateHeartbeatInfoOnSuccess(c);
                    var e = d[r.RESPONSE_KEY_CLIENT_ID];
                    null != e && e != o._clientConfig.get(y.CONFIG_KEY_CLIENT_ID) && (o._logger.debug("onHeartbeatResponse(): setting the client id to " + e + " (from gateway)"), o._clientConfig.set(y.CONFIG_KEY_CLIENT_ID, e), o._clientConfig.save());
                    var f = d[r.RESPONSE_KEY_STATUS];
                    null != f && f != r.RESPONSE_STATUS_NO_ERRORS && o._logger.error("onHeartbeatResponse(): error from gateway: " + f);
                    var g = d[r.RESPONSE_KEY_CONFIG];
                    if ("object" == typeof g) {
                      var h = g[r.RESPONSE_CONFIG_KEY_MAX_HEARTBEAT_INFOS];
                      null != h && o._clientConfig.get(y.CONFIG_KEY_MAX_HEARTBEAT_INFOS) !== h && (o._logger.debug("onHeartbeatResponse(): setting Maximum Heartbeat Infos to " + h + " (from gateway)"), o._clientConfig.set(y.CONFIG_KEY_MAX_HEARTBEAT_INFOS, h));
                      var i = g[r.RESPONSE_CONFIG_KEY_SEND_LOGS],
                        j = null != i ? C.AsBoolean(i) : !1;
                      j !== o._clientConfig.get(y.CONFIG_KEY_SEND_LOGS) && (o._logger.debug("onHeartbeatResponse(): turning " + (j ? "on" : "off") + " sending of logs"), o._clientConfig.set(y.CONFIG_KEY_SEND_LOGS, j));
                      var k = g[r.RESPONSE_CONFIG_KEY_HEARTBEAT_INTERVAL];
                      if (null != k) {
                        var l = C.Int32.Cast(k),
                          m = l;
                        m != o._clientSettings.heartbeatInterval && (o._logger.debug("onHeartbeatResponse(): received hbIntervalMs from gateway: " + m), o._clientSettings.heartbeatInterval = m, null != o._heartbeatTimerCancel && o.resetHeartbeatTimer())
                      }
                      var n = g[r.RESPONSE_CONFIG_KEY_GATEWAY_URL];
                      null != n && n != o._clientSettings.gatewayUrl && (o._logger.debug("onHeartbeatResponse(): received gatewayUrl from gateway: " + n), o._clientSettings.gatewayUrl = n)
                    }
                  } else o._logger.warning("onHeartbeatResponse(): decoded heartbeat response is null.")
                } else {
                  var p = b;
                  C.isValidString(p) ? C.stringStartsWith(p, "HTTP timeout") ? o._logger.warning("onHeartbeatResponse(): " + p) : o._logger.error("onHeartbeatResponse(): failed to send heartbeat: " + p) : (p = v.DEFAULT_HEARTBEAT_ERROR_MESSAGE, o._logger.error("onHeartbeatResponse(): " + p)), o.updateHeartbeatInfoOnFailure(c, p)
                }
              })
            }, this.getSessionTime = function() {
              var a = C.Int32.Cast(o._time.current() - o._startTimeMs);
              return a
            }, this.getNextEventNumber = function() {
              return this._eventQueue.getNumber()
            }, this.sessionTypeTag = function() {
              return this.isGlobalSession() ? " (global session)" : ""
            }, this.isGlobalSession = function() {
              return this._global == u.SESSION_TYPE.GLOBAL
            }, this.isVideoSession = function() {
              return this._global == u.SESSION_TYPE.VIDEO
            }, this.isAdSession = function() {
              return this._global == u.SESSION_TYPE.AD
            }
        };
      u.DEFAULT_VIDEO_SESSION_FLAGS = r.SessionFlags.VIDEO + r.SessionFlags.QUALITY_METRICS + r.SessionFlags.BITRATE_METRICS,
        u.SESSION_TYPE = {
          VIDEO: "Video",
          GLOBAL: "Global",
          AD: "Ad"
        };
      var v = (b.IMonitor = function() {
        this.onPlayerStateChange = function(a) {}, this.onBitrateChange = function(a) {}, this.onSeekEvent = function(a, b) {}, this.onEncodedFrameRateChange = function(a) {},
          this.onRenderedFrameRateChange = function(a) {}, this.onContentLengthChange = function(a) {}, this.onPlayheadTimeChange = function(a) {}, this.onStreamUrlChange = function(a) {}, this.onBufferLengthChange = function(a) {},
          this.onPlayerTypeChange = function(a) {}, this.onPlayerVersionChange = function(a) {}, this.onStreamResolutionWidthChange = function(a) {}, this.onStreamResolutionHeightChange = function(a) {}, this.onConnectionTypeChange = function(a) {},
          this.onLinkEncryptionChange = function(a) {}, this.onSignalStrengthChange = function(a) {}, this.onError = function(a, b) {}, this.onRelease = function() {}, this.onCDNServerIPChange = function(a) {}
      }, b.Session = function() {
        function b(a, b, c, d, e, f, g, h) {
          this._id = a, this._global = b, this._contentMetadata = c, this._clientConfig = d, this._systemMetadata = e, this._cwsSession = f, this._exceptionCatcher = g, this._logger = h, this._logger.setModuleName("Session"),
            this._logger.setSessionId(C.ToString(this._id))
        }
        var c = this;
        c._contentMetadata = null, c._playerStateManager = null, c._id = 0, c._global = u.SESSION_TYPE.VIDEO, c._cleaningUp = !1, c._cleanedUp = !1, c._adPlaying = !1, c._adStream = null,
          c._adPlayer = null, c._adPosition = null, c._ignorePlayerState = !1, c._pooledPlayerState = h.PlayerState.NOT_MONITORED, c._ignoreBitrateAndResource = !1, c._ignorePlayheadTimeandBufferLength = !1, c._ignoreEncodedFrameRateAndDuration = !1,
          c._ignoreError = !1, b.apply(c, arguments), this.start = function() {
            if (c.isVideoSession() || c.isAdSession() ? c._logger.info("start(): assetName=" + c._contentMetadata.assetName) : c._logger.info("start()" + c.sessionTypeTag()), c._cwsSession.start(this), c._clientConfig.isReady()) c.initiateSession();
            else {
              var a = function() {
                c.initiateSession()
              };
              c._clientConfig.register(a)
            }
          }, this.cleanup = function() {
            if (c._logger.info("cleanup()" + c.sessionTypeTag()), c._cleaningUp = !0, c._cwsSession.willEndSoon(), c._clientConfig.isReady()) c.endCwsSessionAndCleanupAll();
            else {
              var a = function() {
                c.endCwsSessionAndCleanupAll()
              };
              c._clientConfig.register(a)
            }
          }, this.cleanupAll = function() {
            c._logger.debug("cleanupAll()" + c.sessionTypeTag()), (c.isVideoSession() || c.isAdSession()) && null != c._playerStateManager && c.detachPlayer(), c._contentMetadata = null, c._logger.setSessionId(null), c._logger = null,
              c._exceptionCatcher = null, c._client = null, c._clientConfig = null, c._systemMetadata = null, c._cwsSession.cleanup(), c._cwsSession = null, c._cleanedUp = !0
          }, this.endCwsSessionAndCleanupAll = function() {
            c._cwsSession.end(),
              c.cleanupAll()
          }, this.initiateSession = function() {
            c._cwsSession.initialize(), c.setStatesFromSystemMetadata(), (c.isVideoSession() || c.isAdSession()) && (c.setStatesFromContentMetadata(), c.enqueueEventForContentMetadata()),
              c._cwsSession.startSendingHeartbeats()
          }, this.enqueueEventForContentMetadata = function() {
            var b = {};
            if (null != c._contentMetadata.assetName ? b[r.REQUEST_KEY_ASSET_NAME] = c._contentMetadata.assetName : c._logger.warning("enqueueEventForContentMetadata(): assetName was not set."), null != c._contentMetadata.applicationName ? ("undefined" == typeof b[r.REQUEST_KEY_STREAM_METADATA_CHANGE] && (b[r.REQUEST_KEY_STREAM_METADATA_CHANGE] = {}), b[r.REQUEST_KEY_STREAM_METADATA_CHANGE][r.REQUEST_KEY_PLAYER_NAME] = c._contentMetadata.applicationName) : c._logger.warning("enqueueEventForContentMetadata(): applicationName was not set."), null != c._contentMetadata.streamUrl ? b[r.REQUEST_KEY_STREAM_URL] = c._contentMetadata.streamUrl : c._logger.warning("enqueueEventForContentMetadata(): streamUrl was not set."), null != c._contentMetadata.viewerId ? ("undefined" == typeof b[r.REQUEST_KEY_STREAM_METADATA_CHANGE] && (b[r.REQUEST_KEY_STREAM_METADATA_CHANGE] = {}), b[r.REQUEST_KEY_STREAM_METADATA_CHANGE][r.REQUEST_KEY_VIEWER_ID] = c._contentMetadata.viewerId) : c._logger.warning("enqueueEventForContentMetadata(): viewerId was not set."), null != c._contentMetadata.defaultResource ? b[r.REQUEST_KEY_RESOURCE] = c._contentMetadata.defaultResource : c._logger.warning("enqueueEventForContentMetadata(): defaultResource was not set."), c._contentMetadata.duration > -1 ? b[r.REQUEST_KEY_CONTENT_LENGTH] = c._contentMetadata.duration : c._logger.warning("enqueueEventForContentMetadata(): duration was not set."), c._contentMetadata.encodedFrameRate > -1 ? b[r.REQUEST_KEY_ENCODED_FRAME_RATE] = c._contentMetadata.encodedFrameRate : c._logger.warning("enqueueEventForContentMetadata(): encodedFrameRate was not set."), c._contentMetadata.streamType != e.StreamType.UNKNOWN ? c._contentMetadata.streamType == a.ContentMetadata.StreamType.LIVE ? b[r.REQUEST_KEY_IS_LIVE] = !0 : b[r.REQUEST_KEY_IS_LIVE] = !1 : c._logger.warning("enqueueEventForContentMetadata(): streamType was not set."), C.dictCount(c._contentMetadata.custom) > 0) {
              b[r.REQUEST_KEY_TAGS] = {};
              for (var d in c._contentMetadata.custom) b[r.REQUEST_KEY_TAGS][d] = c._contentMetadata.custom[d]
            } else c._logger.warning("enqueueEventForContentMetadata(): custom tags were not set.");
            C.dictCount(b) > 0 && c._cwsSession.declareStateChange(b, null)
          }, this.setStatesFromSystemMetadata = function() {
            c._logger.debug("setStatesFromSystemMetadata()");
            var a = c._systemMetadata.get(),
              b = a[K.BROWSER_NAME];
            null != b && c._cwsSession.setBrowserName(b);
            var d = a[K.BROWSER_VERSION];
            null != d && c._cwsSession.setBrowserVersion(d);
            var e = a[K.DEVICE_BRAND];
            null != e && c._cwsSession.setDeviceBrand(e);
            var f = a[K.DEVICE_MANUFACTURER];
            null != f && c._cwsSession.setDeviceManufacturer(f);
            var g = a[K.DEVICE_MODEL];
            null != g && c._cwsSession.setDeviceModel(g);
            var h = a[K.DEVICE_TYPE];
            null != h && c._cwsSession.setDeviceType(h);
            var i = a[K.DEVICE_VERSION];
            null != i && c._cwsSession.setDeviceVersion(i);
            var j = a[K.FRAMEWORK_NAME];
            null != j && c._cwsSession.setFrameworkName(j);
            var k = a[K.FRAMEWORK_VERSION];
            null != k && c._cwsSession.setFrameworkVersion(k);
            var l = a[K.OPERATING_SYSTEM_NAME];
            null != l && c._cwsSession.setOperatingSystemName(l);
            var m = a[K.OPERATING_SYSTEM_VERSION];
            null != m && c._cwsSession.setOperatingSystemVersion(m);
            var n = a[K.DEVICE_CATEGORY];
            null != n && c._cwsSession.setDeviceCategory(n);
          }, this.setStatesFromContentMetadata = function() {
            if (c._logger.debug("setStatesFromContentMetadata()"), null != c._contentMetadata.defaultResource && c._cwsSession.setResource(c._contentMetadata.defaultResource), null != c._contentMetadata.streamUrl && c._cwsSession.setStreamUrl(c._contentMetadata.streamUrl), c._contentMetadata.duration > 0 && c._cwsSession.setContentLength(c._contentMetadata.duration), c._contentMetadata.encodedFrameRate > 0 && c._cwsSession.setEncodedFrameRate(c._contentMetadata.encodedFrameRate), c._contentMetadata.streamType !== e.StreamType.UNKNOWN) {
              var a = c._contentMetadata.streamType === e.StreamType.LIVE;
              c._cwsSession.setIsLive(a)
            }
            null != c._contentMetadata.playerName && c._cwsSession.setPlayerName(c._contentMetadata.playerName),
            null != c._contentMetadata.assetName && c._cwsSession.setAssetName(c._contentMetadata.assetName),
              null != c._contentMetadata.viewerId && c._cwsSession.setViewerId(c._contentMetadata.viewerId), null != c._contentMetadata.applicationName && c._cwsSession.setPlayerName(c._contentMetadata.applicationName), C.dictCount(c._contentMetadata.custom) > 0 && c._cwsSession.setTags(c._contentMetadata.custom);
          }, this.onPlayerStateChange = function(a) {
            return c._logger.debug("onPlayerStateChange(): " + a), c._cwsSession._playerState != a ? (c._cwsSession._playerState == h.PlayerState.NOT_MONITORED && a != h.PlayerState.NOT_MONITORED && (c._pooledPlayerState = a), c._ignorePlayerState ? void c._logger.debug("onPlayerStateChange(): " + a + " (pooled, " + (c._adPlaying ? "ad playing" : "preloading") + ")") : void c._cwsSession.setPlayerState(a)) : void 0
          }, this.onBitrateChange = function(a) {
            return c._logger.debug("onBitrateChange(): " + a), c._ignoreBitrateAndResource ? void c._logger.info("onBitrateChange(): ignored") : void c._cwsSession.setBitrateKbps(a)
          }, this.onSeekEvent = function(a, b) {
            null == b || C.isInteger(b) || (c._logger.error("onSeekEvent(): Ignored non-integer seekToPosition data: " + b), b = -1), c._cwsSession.enqueueSeekEvent(a, b)
          }, this.onEncodedFrameRateChange = function(a) {
            c._logger.debug("onEncodedFrameRateChange(): " + a), c._contentMetadata.encodedFrameRate > 0 || (a > 0 ? c._ignoreEncodedFrameRateAndDuration ? c._logger.info("onEncodedFrameRateChange(): Ignored encoded frame rate data: " + a + " (ads)") : (c._cwsSession.setEncodedFrameRate(a), c._logger.info("onEncodedFrameRateChange(): Received encoded frame rate data: " + a)) : c._logger.warning("onEncodedFrameRateChange(): Ignored invalid encoded frame rate data: " + a))
          }, this.onContentLengthChange = function(a) {
            c._logger.debug("onContentLengthChange(): " + a), c._contentMetadata.duration > 0 || (a > 0 ? c._ignoreEncodedFrameRateAndDuration ? c._logger.info("setContentLength(): Ignored content length data: " + a + " (ads)") : (c._cwsSession.setContentLength(a), c._logger.info("setContentLength(): Received content length data: " + a)) : c._logger.warning("setContentLength(): Ignored invalid content length data: " + a))
          }, this.onStreamUrlChange = function(a) {
            c._logger.debug("onStreamUrlChange(): " + a),
              null == c._contentMetadata.streamUrl && c._cwsSession.setStreamUrl(a)
          }, this.onStreamResolutionWidthChange = function(a) {
            c._logger.debug("onStreamResolutionWidthChange(): " + a), c._cwsSession.setStreamResolutionWidth(a);
          }, this.onStreamResolutionHeightChange = function(a) {
            c._logger.debug("onStreamResolutionHeightChange(): " + a), c._cwsSession.setStreamResolutionHeight(a)
          }, this.onConnectionTypeChange = function(a) {
            c._logger.debug("onConnectionTypeChange(): " + a),
              c._cwsSession.setConnectionType(a)
          }, this.onLinkEncryptionChange = function(a) {
            c._logger.debug("onLinkEncryptionChange(): " + a), c._cwsSession.setLinkEncryption(a)
          }, this.onPlayerTypeChange = function(a) {
            c._logger.debug("onPlayerTypeChange(): " + a),
              null == c._cwsSession.getFrameworkName() && c._cwsSession.setFrameworkName(a)
          }, this.onPlayerVersionChange = function(a) {
            c._logger.debug("onPlayerVersionChange(): " + a), null == c._cwsSession.getFrameworkVersion() && c._cwsSession.setFrameworkVersion(a);
          }, this.onCDNServerIPChange = function(a) {
            c._logger.debug("onCDNServerIPChange(): " + a), c._cwsSession.setCDNServerIP(a)
          }, this.onError = function(a, b) {
            c._logger.debug("onError(): " + a + " (" + b + ")"), c.reportError(a, b);
          }, this.onRelease = function() {
            c._logger.debug("onRelease()"), c.detachPlayer()
          }, this.adStart = function(b, d, e) {
            return c._logger.debug("adStart(): adStream=" + b + " adPlayer=" + d + " adPosition=" + e), c._adPlaying ? void c._logger.warning("adStart(): multiple adStart calls, ignoring") : (c._adPlaying = !0, c._adStream = b, c._adPlayer = d, c._adPosition = e, c._cwsSession._hasJoined || c._cwsSession.togglePauseJoin(!0), void(c._adStream == a.Client.AdStream.CONTENT || c._adPlayer == a.Client.AdPlayer.SEPARATE ? (c._cwsSession._playerState !== h.PlayerState.NOT_MONITORED && (c._pooledPlayerState = c._cwsSession._playerState), c._cwsSession.setPlayerState(h.PlayerState.NOT_MONITORED), c._ignorePlayerState = !0) : c._adStream == a.Client.AdStream.SEPARATE && c._adPlayer == a.Client.AdPlayer.CONTENT && (c._cwsSession._playerState !== h.PlayerState.NOT_MONITORED && (c._pooledPlayerState = c._cwsSession._playerState), c._cwsSession.setPlayerState(h.PlayerState.NOT_MONITORED), c._ignorePlayerState = !0, c._ignoreBitrateAndResource = !0, c._ignoreEncodedFrameRateAndDuration = !0, c._ignorePlayheadTimeandBufferLength = !0, c._ignoreError = !0)));
          }, this.adEnd = function() {
            return c._logger.debug("adEnd()"), c._adPlaying ? (c._cwsSession._hasJoined || c._cwsSession.togglePauseJoin(!1), c._adStream == a.Client.AdStream.CONTENT || c._adPlayer == a.Client.AdPlayer.SEPARATE ? c._preloading || (c._ignorePlayerState = !1, c._cwsSession.setPlayerState(c._pooledPlayerState)) : c._adStream == a.Client.AdStream.SEPARATE && c._adPlayer == a.Client.AdPlayer.CONTENT && (c._ignoreBitrateAndResource = !1, c._ignoreEncodedFrameRateAndDuration = !1, c._ignorePlayheadTimeandBufferLength = !1, c._ignoreError = !1, c._preloading || (c._ignorePlayerState = !1, c._cwsSession.setPlayerState(c._pooledPlayerState))), c._adPlaying = !1, void(c._adStream = c._adPlayer = c._adPosition = null)) : void c._logger.debug("adEnd(): called before adStart, ignoring");
          }, this.detachPlayer = function() {
            c._logger.debug("detachPlayer()"), null !== c._playerStateManager && (c._exceptionCatcher.runProtected("Session.detachPlayer", function() {
              c._playerStateManager.removeMonitoringNotifier();
            }), c._playerStateManager = null, c._cwsSession.setPlayerStateManager(null), c._cwsSession.setPlayerState(h.PlayerState.NOT_MONITORED))
          }, this.attachPlayer = function(a) {
            return c._logger.debug("attachPlayer()"),
              null != c._playerStateManager ? void c._logger.error("attachPlayer(): detach current PlayerStateManager first") : void c._exceptionCatcher.runProtected("Session.attachPlayer()", function() {
                a.setMonitoringNotifier(c, c._id) ? (a.pushCurrentState(), c._playerStateManager = a, c._cwsSession.setPlayerStateManager(c._playerStateManager)) : c._logger.error("attachPlayer(): instance of PlayerStateManager is already attached to a session")
              })
          }, this.getPlayerStateManager = function() {
            return c._logger.debug("getPlayerStateManager()"), c._playerStateManager
          }, this.contentPreload = function() {
            return c._logger.debug("contentPreload()"), c._preloading ? void c._logger.debug("contentPreload(): called twice, ignoring") : (c._preloading = !0, void(c._ignorePlayerState = !0))
          }, this.contentStart = function() {
            return c._logger.debug("contentStart()"), c._preloading ? (c._preloading = !1, void(c._adPlaying || (c._ignorePlayerState = !1, c._cwsSession.setPlayerState(c._pooledPlayerState)))) : void c._logger.warning("contentStart(): called without contentPreload, ignoring");
          }, this.reportError = function(b, d) {
            if (c._logger.info("reportError(): " + b), !C.isValidString(b)) return void c._logger.error("reportError(): invalid error message string: " + b);
            if (d !== a.Client.ErrorSeverity.FATAL && d !== a.Client.ErrorSeverity.WARNING) return void c._logger.error("reportError(): invalid error severity: " + d);
            if (c._ignoreError) return void c._logger.debug("reportError(): ignored");
            var e = d === a.Client.ErrorSeverity.FATAL;
            c._cwsSession.sendError(b, e)
          }, this.updateContentMetadata = function(a) {
            c._logger.debug("updateContentMetadata(): enter"),
              c._exceptionCatcher.runProtected("Session.updateContentMetadata", function() {
                c.mergeContentMetadata(a), c.setStatesFromContentMetadata()
              })
          }, this.sendCustomEvent = function(a, b) {
            c._logger.info("sendEvent(): eventName=" + a + c.sessionTypeTag()),
              c._cwsSession.enqueueCustomEvent(a, b)
          }, this.mergeContentMetadata = function(b) {
            var d = {},
              f = {};
            if (C.isValidString(b.assetName) && (c._contentMetadata.assetName != b.assetName ? (null != c._contentMetadata.assetName && (d[r.REQUEST_KEY_ASSET_NAME] = c._contentMetadata.assetName), f[r.REQUEST_KEY_ASSET_NAME] = b.assetName, c._contentMetadata.assetName = b.assetName) : c._logger.warning("mergeContentMetadata(): assetName was not changed.")), C.isValidString(b.applicationName) && (c._contentMetadata.applicationName != b.applicationName ? (null != c._contentMetadata.applicationName && ("undefined" == typeof d[r.REQUEST_KEY_STREAM_METADATA_CHANGE] && (d[r.REQUEST_KEY_STREAM_METADATA_CHANGE] = {}), d[r.REQUEST_KEY_STREAM_METADATA_CHANGE][r.REQUEST_KEY_PLAYER_NAME] = c._contentMetadata.applicationName), "undefined" == typeof f[r.REQUEST_KEY_STREAM_METADATA_CHANGE] && (f[r.REQUEST_KEY_STREAM_METADATA_CHANGE] = {}), f[r.REQUEST_KEY_STREAM_METADATA_CHANGE][r.REQUEST_KEY_PLAYER_NAME] = b.applicationName, c._contentMetadata.applicationName = b.applicationName) : c._logger.warning("mergeContentMetadata(): applicationName was not changed.")), C.isValidString(b.streamUrl) && (c._contentMetadata.streamUrl != b.streamUrl ? (null != c._contentMetadata.streamUrl && (d[r.REQUEST_KEY_STREAM_URL] = c._contentMetadata.streamUrl), f[r.REQUEST_KEY_STREAM_URL] = b.streamUrl, c._contentMetadata.streamUrl = b.streamUrl) : c._logger.warning("mergeContentMetadata(): streamUrl was not changed.")), C.isValidString(b.viewerId) && (c._contentMetadata.viewerId != b.viewerId ? (null != c._contentMetadata.viewerId && ("undefined" == typeof d[r.REQUEST_KEY_STREAM_METADATA_CHANGE] && (d[r.REQUEST_KEY_STREAM_METADATA_CHANGE] = {}), d[r.REQUEST_KEY_STREAM_METADATA_CHANGE][r.REQUEST_KEY_VIEWER_ID] = c._contentMetadata.viewerId), "undefined" == typeof f[r.REQUEST_KEY_STREAM_METADATA_CHANGE] && (f[r.REQUEST_KEY_STREAM_METADATA_CHANGE] = {}), f[r.REQUEST_KEY_STREAM_METADATA_CHANGE][r.REQUEST_KEY_VIEWER_ID] = b.viewerId, c._contentMetadata.viewerId = b.viewerId) : c._logger.warning("mergeContentMetadata(): viewerId was not changed.")), C.isValidString(b.defaultResource) && (c._contentMetadata.defaultResource != b.defaultResource ? (null != c._contentMetadata.defaultResource && (d[r.REQUEST_KEY_RESOURCE] = c._contentMetadata.defaultResource), f[r.REQUEST_KEY_RESOURCE] = b.defaultResource, c._contentMetadata.defaultResource = b.defaultResource) : c._logger.warning("mergeContentMetadata(): defaultResource was not changed.")), C.isInteger(b.duration) && b.duration > 0 && (c._contentMetadata.duration != b.duration ? (c._cwsSession._contentLengthSec > 0 && (d[r.REQUEST_KEY_CONTENT_LENGTH] = c._cwsSession._contentLengthSec), f[r.REQUEST_KEY_CONTENT_LENGTH] = b.duration, c._contentMetadata.duration = b.duration) : c._logger.warning("mergeContentMetadata(): duration was not changed.")), C.isInteger(b.encodedFrameRate) && b.encodedFrameRate > 0 && (c._contentMetadata.encodedFrameRate != b.encodedFrameRate ? (c._contentMetadata.encodedFrameRate > -1 && (d[r.REQUEST_KEY_ENCODED_FRAME_RATE] = c._contentMetadata.encodedFrameRate), f[r.REQUEST_KEY_ENCODED_FRAME_RATE] = b.encodedFrameRate, c._contentMetadata.encodedFrameRate = b.encodedFrameRate) : c._logger.warning("mergeContentMetadata(): encodedFrameRate was not changed.")), b.streamType != e.StreamType.UNKNOWN && (c._contentMetadata.streamType != b.streamType ? (c._contentMetadata.streamType != e.StreamType.UNKNOWN && (c._contentMetadata.streamType == a.ContentMetadata.StreamType.LIVE ? d[r.REQUEST_KEY_IS_LIVE] = !0 : d[r.REQUEST_KEY_IS_LIVE] = !1), b.streamType == a.ContentMetadata.StreamType.LIVE ? f[r.REQUEST_KEY_IS_LIVE] = !0 : f[r.REQUEST_KEY_IS_LIVE] = !1, c._contentMetadata.streamType = b.streamType) : c._logger.warning("mergeContentMetadata(): streamType was not changed.")), C.dictCount(b.custom) > 0) {
              var g = {},
                h = {};
              for (var i in b.custom) {
                var j = c._contentMetadata.custom[i];
                j != b.custom[i] ? (g[i] = b.custom[i], c._contentMetadata.custom[i] && (h[i] = c._contentMetadata.custom[i]), c._contentMetadata.custom[i] = b.custom[i]) : c._logger.info("mergeContentMetadata(): custom." + i + " was not changed.");
              }
              C.dictCount(g) > 0 ? (C.dictCount(h) > 0 && (d[r.REQUEST_KEY_TAGS] = h), f[r.REQUEST_KEY_TAGS] = g) : c._logger.warning("mergeContentMetadata(): custom was not changed.")
            }
            C.dictCount(f) > 0 && c._cwsSession.declareStateChange(f, d);
          }, this.isGlobalSession = function() {
            return c._global == u.SESSION_TYPE.GLOBAL
          }, this.isVideoSession = function() {
            return c._global == u.SESSION_TYPE.VIDEO
          }, this.isAdSession = function() {
            return c._global == u.SESSION_TYPE.AD;
          }, this.sessionTypeTag = function() {
            return c.isGlobalSession() ? " (global session)" : ""
          }
      });
      v.DEFAULT_HEARTBEAT_ERROR_MESSAGE = "received no response (or a bad response) to heartbeat POST request";
      var w = b.SessionFactory = function() {
          function a(a, c, d, e) {
            b._client = a, b._clientSettings = c, b._clientConfig = d, b._systemFactory = e, b._logger = b._systemFactory.buildLogger(), b._logger.setModuleName("SessionFactory"), b._nextSessionKey = 0, b._sessionsByKey = {};
          }
          var b = this;
          b._logger = null, b._logBuffer = null, b._nextSessionKey = 0, b._sessionsByKey = null, a.apply(b, arguments), this.cleanup = function() {
            b._logger = null, b._logBuffer = null;
            for (var a in b._sessionsByKey) {
              var c = b._sessionsByKey[a];
              c.cleanup()
            }
            b._sessionsByKey = null, b._nextSessionKey = 0
          }, this.newSessionKey = function() {
            var a = b._nextSessionKey;
            return b._nextSessionKey++, a
          }, this.makeVideoSession = function(a, c) {
            return null == a && (a = new e),
              b.makeSession(a, c)
          }, this.makeGlobalSession = function(a) {
            return b.makeSession(a, u.SESSION_TYPE.GLOBAL)
          }, this.generateSessionId = function() {
            return F.integer32()
          }, this.makeSession = function(a, c) {
            var z = JSON.parse(JSON.stringify(a));
            var d = JSON.parse(JSON.stringify(a)),
              e = b.generateSessionId(),
              f = b._systemFactory.buildSession(b._client, b._clientSettings, b._clientConfig, e, c, d),
              g = b.newSessionKey();
            return b.addSession(g, f), f.start(), g
          }, this.getSession = function(a) {
            var c = b._sessionsByKey[a];
            return null == c && b._logger.error("Client: invalid sessionKey. Did you cleanup that session previously?"), c
          }, this.getVideoSession = function(a) {
            var c = this.getSession(a);
            return null != c && (c.isVideoSession() || c.isAdSession() || (b._logger.error("Client: invalid sessionKey. Did you cleanup that session previously?"), c = null)), c
          }, this.addSession = function(a, c) {
            b._sessionsByKey[a] = c
          }, this.removeSession = function(a) {
            delete b._sessionsByKey[a]
          }, this.cleanupSession = function(a) {
            var c = b.getSession(a);
            b.removeSession(a), c.cleanup()
          }
        },
        x = b.CallbackWithTimeout = function(a) {
          this._timer = a, this.getWrapperCallback = function(a, b, c) {
            var d = !1,
              e = function() {
                d || (d = !0, a(!1, c + " (" + b + " ms)"))
              };
            this._timer.createOnce(e, b, "CallbackWithTimeout.wrap");
            var f = function(b, c) {
              d || (d = !0, a(b, c))
            };
            return f
          }
        },
        y = b.Config = function(a, b, c) {
          var d = this;
          this._logger = a, this._logger.setModuleName("Config"), this._storage = b, this._jsonInterface = c, this._defaultConfig = {
            clientId: r.DEFAULT_CLIENT_ID,
            sendLogs: !1,
            maxHbInfos: r.DEFAULT_MAX_HEARTBEAT_INFOS
          }, this._config = C.ObjectShallowCopy(this._defaultConfig), this._loaded = !1, this._loadedEmpty = !1, this._waitingConsumers = [], this.isReady = function() {
            return this._loaded;
          }, this.load = function() {
            var a = function(a, b) {
              a ? (d._parse(b), d._logger.debug("load(): configuration successfully loaded from local storage" + (d._loadedEmpty ? " (was empty)" : "") + ".")) : d._logger.error("load(): error loading configuration from local storage: " + b),
                d._loaded = !0, d._notify()
            };
            this._storage.load(y.STORAGE_KEY, a)
          }, this._parse = function(a) {
            var b = this._jsonInterface.decode(a);
            if (null == b) return void(this._loadedEmpty = !0);
            var c = b[y.CONFIG_STORAGE_KEY_CLIENT_ID];
            null != c && c != r.DEFAULT_CLIENT_ID && "" != c && "null" != c && (this._config[y.CONFIG_KEY_CLIENT_ID] = c, this._logger.debug("parse(): loaded clientId=" + c + " (from local storage)"))
          }, this._marshall = function() {
            var a = {};
            return a[y.CONFIG_STORAGE_KEY_CLIENT_ID] = this._config.clientId, this._logger.debug("_marshall(): saving clientId=" + this._config.clientId + " (to local storage)"), this._jsonInterface.encode(a)
          }, this.save = function() {
            var a = function(a, b) {
              a ? d._logger.debug("save(): configuration successfully saved to local storage.") : d._logger.error("save(): error saving configuration to local storage: " + b)
            };
            this._storage.save(y.STORAGE_KEY, this._marshall(), a);
          }, this.register = function(a) {
            return this.isReady() ? void a() : void this._waitingConsumers.push(a)
          }, this.get = function(a) {
            return this._loaded ? this._config[a] : null
          }, this.set = function(a, b) {
            this._loaded && (this._config[a] = b);
          }, this._notify = function() {
            for (var a; null != (a = this._waitingConsumers.shift());) a()
          }
        };
      y.STORAGE_KEY = "sdkConfig", y.CONFIG_STORAGE_KEY_CLIENT_ID = "clId", y.CONFIG_KEY_CLIENT_ID = "clientId", y.CONFIG_KEY_SEND_LOGS = "sendLogs",
        y.CONFIG_KEY_MAX_HEARTBEAT_INFOS = "maxHbInfos";
      var z = b.EventQueue = function() {
          this._events = [], this._nextEventNumber = 0, this.enqueue = function(a) {
            this._events.push(a)
          }, this.getNumber = function() {
            var a = this._nextEventNumber;
            return this._nextEventNumber++, a
          }, this.flush = function() {
            var a = this._events;
            return this._events = [], a
          }
        },
        A = b.ExceptionCatcher = function(a, b, c) {
          this._logger = a, this._logger.setModuleName("ExceptionCatcher"),
            this._ping = b, this._systemSettings = c, this.runProtected = function(a, b, c) {
              try {
                b()
              } catch (d) {
                if (null != c) c(d);
                else {
                  if (this._systemSettings.allowUncaughtExceptions) throw d;
                  this.onUncaughtException(a, d)
                }
              }
            }, this.onUncaughtException = function(a, b) {
              var c = "Uncaught exception: " + a + ": " + b.toString();
              if (null != this._ping) try {
                this._ping.send(c)
              } catch (d) {
                this._logger.error("Caught exception while sending ping: " + d.toString())
              }
              this._logger.error(c)
            }
        },
        B = b.GatewayControl = function(a, b, c, d) {
          var e = this;
          this._clientSettings = a, this._logger = b, this._logger.setModuleName("GatewayControl"), this._httpClient = c, this._jsonInterface = d, this.send = function(a, b) {
            var c = this._jsonInterface.encode(a),
              d = this._clientSettings.gatewayUrl + r.gatewayPath,
              f = function(a, c) {
                if (a) {
                  var d = e._jsonInterface.decode(c);
                  b(a, d)
                } else {
                  var f = c;
                  b(a, f)
                }
              };
            this._httpClient.request("POST", d, c, "application/json", f)
          }
        },
        C = b.Lang = {};
      C.isMeaningfulString = function(a) {
          return C.isValidString(a) && null != a && "undefined" != a && "null" != a;
        }, C.sanitizeStringToStringObject = function(a) {
          var b = {};
          for (var c in a)
            if (C.isMeaningfulString(c)) {
              var d = a[c];
              C.isMeaningfulString(d) && (b[c] = d)
            } return b
        }, C.validateInterface = function(a, b, c) {
          if (null == a) throw new Error("Expected " + c + " implementation is null.");
          for (var d in b)
            if ("function" != typeof a[d]) throw new Error("Expected method " + d + " in " + c + " implementation.")
        }, C.dictCount = function(a) {
          var b, c = 0;
          for (b in a) a.hasOwnProperty(b) && c++;
          return c
        }, C.ToString = function(a) {
          return "" + a
        }, C.NumberToInt = function(a) {
          return Math.floor(a)
        }, C.NumberToUnsignedInt = function(a) {
          return Math.abs(C.NumberToInt(a))
        }, C.AsBoolean = function(a) {
          return Boolean(a)
        }, C.isValidString = function(a) {
          return "string" == typeof a && "" !== a;
        }, C.stringStartsWith = function(a, b) {
          return "string" != typeof a || "string" != typeof b ? !1 : "function" == typeof a.indexOf ? 0 === a.indexOf(b) : !1
        }, C.isBoolean = function(a) {
          return "boolean" == typeof a
        }, C.UrlEncodeString = function(a) {
          return escape(a)
        }, C.isObject = function(a) {
          return "object" == typeof a
        }, C.ObjectToString = function(a) {
          var b = "";
          for (var c in a) {
            var d = a[c],
              e = d;
            b += c + "=" + e
          }
          return "Object{" + b + "}"
        }, C.ObjectShallowCopyOmitNull = function(a) {
          var b = C.ObjectShallowCopy(a);
          for (var c in b) null == b[c] && delete b[c];
          return b
        }, C.ObjectShallowCopy = function(a) {
          var b = {};
          for (var c in a) b[c] = a[c];
          return b
        }, C.ObjectShallowEquals = function(a, b) {
          if (typeof a != typeof b) return !1;
          if (a instanceof Object && b instanceof Object) {
            if (C.dictCount(a) !== C.dictCount(b)) return !1;
            var c = !0;
            for (var d in a)
              if (c = a[d] === b[d], !c) return !1;
            return !0
          }
          return a === b
        }, C.isInteger = function(a) {
          if ("number" != typeof a) return !1;
          var b = Math.round(a);
          return b === a
        }, C.isArray = function(a) {
          return "[object Array]" === Object.prototype.toString.call(a)
        }, C.ArrayEquals = function(a, b) {
          if (a === b) return !0;
          if (null == a || null == b) return !1;
          if (a.length != b.length) return !1;
          for (var c = 0; c < a.length; ++c)
            if (C.isArray(a[c]) && C.isArray(b[c])) {
              if (!C.ArrayEquals(a[c], b[c])) return !1
            } else if (a[c] !== b[c]) return !1;
          return !0
        }, C.isObjectDefinePropertyPresent = function() {
          return "undefined" != typeof Object.defineProperty && function() {
            try {
              return Object.defineProperty({}, "x", {}), !0
            } catch (a) {
              return !1
            }
          }()
        }, C.defGet = function(a, b, c) {
          if (C.isObjectDefinePropertyPresent()) Object.defineProperty(a, b, {
            configurable: !0,
            enumerable: !0,
            get: c
          });
          else {
            if ("undefined" == typeof a.__defineGetter__) throw new Error("JavaScript runtime must support either Object.defineProperty or __defineGetter__");
            a.__defineGetter__(b, c)
          }
        }, C.defSet = function(a, b, c) {
          if (C.isObjectDefinePropertyPresent()) Object.defineProperty(a, b, {
            configurable: !0,
            set: c
          });
          else {
            if ("undefined" == typeof a.__defineSetter__) throw new Error("JavaScript runtime must support either Object.defineProperty or __defineSetter__");
            a.__defineSetter__(b, c)
          }
        },
        function() {
          var a = {};
          a.two32 = 4294967296, a.MaxValue = a.two32 - 1, a.MinValue = 0, C.UInt32 = a, C.UInt32.Cast = function(b) {
            var c = parseInt(b, 10);
            return c > a.MaxValue ? c %= a.two32 : c < a.MinValue && (c = -c % a.two32, c = a.two32 - c), c
          }, C.UInt32.InRange = function(b) {
            var c = parseInt(b, 10);
            return c <= a.MaxValue && c >= a.MinValue
          };
          var b = {};
          b.MaxValue = 2147483647, b.MinValue = -2147483648, C.Int32 = b, C.Int32.Cast = function(a) {
            var c = parseInt(a, 10);
            return c > b.MaxValue ? c %= b.MaxValue : c < b.MinValue && (c = -c % b.MaxValue, c = b.MaxValue - c), c
          }, C.Int32.InRange = function(a) {
            var c = parseInt(a, 10);
            return c <= b.MaxValue && c >= b.MinValue
          }
        }();
      var D = b.LogBuffer = function() {
          var a = 32;
          this._buffer = [], this.add = function(b) {
            this._buffer.length >= a && this._buffer.shift(),
              this._buffer.push(b)
          }, this.flush = function() {
            var a = this._buffer;
            return this._buffer = [], a
          }
        },
        E = b.Ping = function(a, b, d) {
          this._isSendingPing = !1, this._cachedBasePingUrl = null, this._logger = a, this._logger.setModuleName("Ping"),
            this._httpClient = b, this._clientSettings = d, this.send = function(a) {
              if (!this._isSendingPing) {
                this._isSendingPing = !0;
                var b = this.getBasePingUrl() + "&d=" + C.UrlEncodeString(a.toString());
                this._logger.error("send(): " + b),
                  this._httpClient.request("GET", b, null, null, null), this._isSendingPing = !1
              }
            }, this.getBasePingUrl = function() {
              if (!this._cachedBasePingUrl) {
                var a = E.SERVICE_URL + "?comp=" + E.COMPONENT_NAME + "&clv=" + c.version;
                if (this._clientSettings && (a += "&cid=" + this._clientSettings.customerKey), a += "&sch=" + r.SDK_METADATA_SCHEMA, !this._clientSettings) return a;
                this._cachedBasePingUrl = a
              }
              return this._cachedBasePingUrl
            }
        };
      E.COMPONENT_NAME = "sdkjs", E.SERVICE_URL = "https://pings.conviva.com/ping.ping";
      var F = b.Random = {};
      F.maxUInt32 = 4294967295, F.maxInt32 = 2147483647, F.minInt32 = -2147483648, F.integer32 = function() {
        return Math.floor(Math.random() * F.maxUInt32) + F.minInt32
      }, F.uinteger32 = function() {
        return Math.floor(Math.random() * F.maxUInt32);
      };
      var G = b.Sanitize = {};
      G.Integer = function(a, b, c, d) {
        if (isNaN(a)) return d;
        if ("number" != typeof a) return d;
        if (a == d) return d;
        var e = C.NumberToInt(a);
        return G.EnforceBoundaries(e, b, c)
      }, G.EnforceBoundaries = function(a, b, c) {
        return null != c && a > c ? a = c : null != b && b > a && (a = b), a
      }, G.sanitizeSpecialIntegerValue = function(a) {
        return -1 == a || -2 == a ? a : a = G.Integer(a, 0, null, -1)
      };
      var H = (b.StreamerError = function() {
          function a(a, c) {
            b.errorCode = a, b.severity = c;
          }
          var b = this;
          b.errorCode = null, b.severity = c.ErrorSeverity.FATAL, a.apply(b, arguments)
        }, b.HttpClient = function(a, b, c, d) {
          this._logger = a, this._logger.setModuleName("HttpClient"), this._httpInterface = b, this._callbackWithTimeout = c,
            this._systemSettings = d, this.request = function(a, b, c, d, e) {
              var f = 1e3 * this._systemSettings.httpTimeout,
                g = this._callbackWithTimeout.getWrapperCallback(e, f, "HTTP timeout");
                this._logger.debug("request(): calling HttpInterface.makeRequest"),
                this._httpInterface.makeRequest(a, b, c, d, f, g)
            }
        }),
        I = b.Logger = function(a, b, c, d, e) {
          this._loggingInterface = a, this._timeInterface = b, this._settings = c, this._logBuffer = d, this._packageName = e, this.debug = function(a) {
              this.log(a, g.LogLevel.DEBUG)
            }, this.info = function(a) {
              this.log(a, g.LogLevel.INFO)
            }, this.warning = function(a) {
              this.log(a, g.LogLevel.WARNING)
            }, this.error = function(a) {
              this.log(a, g.LogLevel.ERROR)
            }, this.log = function(a, b) {
              var c = this.formatMessage(a, b);
              this._logBuffer.add(c), this._settings.logLevel <= b && this._loggingInterface.consoleLog(c, b)
            }, this.prependModuleName = function(a) {
              var b = a;
              return b = "[" + this._moduleName + "] " + b
            },
            this.prependPackageName = function(a) {
              var b = a;
              return b = "[" + this._packageName + "] " + b
            }, this.prependConvivaNamespace = function(a) {
              var b = a;
              return b = "[Conviva] " + b
            }, this.prependTime = function(a) {
              var b = this._timeInterface.getEpochTimeMs(),
                c = (b / 1e3).toFixed(3).toString();
              return "[" + c + "] " + a
            }, this.prependLogLevel = function(a, b) {
              var c = I.getLogLevelString(b),
                d = a;
              return d = "[" + c + "] " + d
            }, this.prependSessionId = function(a) {
              var b = a;
              return null != this._sessionId && (b = "sid=" + this._sessionId + " " + b),
                b
            }, this.setSessionId = function(a) {
              this._sessionId = a
            }, this.setModuleName = function(a) {
              this._moduleName = a
            }, this.formatMessage = function(a, b) {
              return this.prependConvivaNamespace(this.prependTime(this.prependLogLevel(this.prependPackageName(this.prependModuleName(this.prependSessionId(a))), b)));
            }
        };
      I.getLogLevelString = function(a) {
        var b;
        switch (a) {
          case g.LogLevel.ERROR:
            b = "ERROR";
            break;
          case g.LogLevel.WARNING:
            b = "WARNING";
            break;
          case g.LogLevel.INFO:
            b = "INFO";
            break;
          case g.LogLevel.DEBUG:
            b = "DEBUG"
        }
        return b;
      };
      var J = b.Storage = function(a, b, c, d) {
        this._logger = a, this._logger.setModuleName("Storage"), this._storageInterface = b, this._callbackWithTimeout = c, this._systemSettings = d, this.load = function(a, b) {
          var c = this._callbackWithTimeout.getWrapperCallback(b, 1e3 * this._systemSettings.storageTimeout, "storage load timeout");
          this._logger.debug("load(): calling StorageInterface.loadData"), this._storageInterface.loadData(J.STORAGE_SPACE, a, c)
        }, this.save = function(a, b, c) {
          var d = this._callbackWithTimeout.getWrapperCallback(c, 1e3 * this._systemSettings.storageTimeout, "storage save timeout");
          this._logger.debug("save(): calling StorageInterface.saveData"), this._storageInterface.saveData(J.STORAGE_SPACE, a, b, d)
        }
      };
      J.STORAGE_SPACE = "Conviva";
      var K = b.SystemMetadata = function(b, c, d) {
        this._logger = b,
          this._logger.setModuleName("SystemMetadata"), this._metadataInterface = c, this._exceptionCatcher = d, this._cachedMetadata = null, this.get = function() {
            return this._cachedMetadata || this.retrieve(), this._cachedMetadata;
          }, this.retrieve = function() {
            function b(a, b) {
              d._exceptionCatcher.runProtected("Session.getSystemMetadataSchema(): " + a, function() {
                var c = b[a];
                b[a] = c.call(d._metadataInterface)
              })
            }
            var c = {};
            c[K.BROWSER_NAME] = this._metadataInterface.getBrowserName,
              c[K.BROWSER_VERSION] = this._metadataInterface.getBrowserVersion, c[K.DEVICE_BRAND] = this._metadataInterface.getDeviceBrand, c[K.DEVICE_MANUFACTURER] = this._metadataInterface.getDeviceManufacturer, c[K.DEVICE_MODEL] = this._metadataInterface.getDeviceModel,
              c[K.DEVICE_TYPE] = this._metadataInterface.getDeviceType, c[K.DEVICE_VERSION] = this._metadataInterface.getDeviceVersion, c[K.FRAMEWORK_NAME] = this._metadataInterface.getFrameworkName, c[K.FRAMEWORK_VERSION] = this._metadataInterface.getFrameworkVersion,
              c[K.OPERATING_SYSTEM_NAME] = this._metadataInterface.getOperatingSystemName, c[K.OPERATING_SYSTEM_VERSION] = this._metadataInterface.getOperatingSystemVersion, c[K.DEVICE_CATEGORY] = this._metadataInterface.getDeviceCategory;
            var d = this;
            this._logger.debug("retrieve(): calling MetadataInterface methods");
            for (var e in c) b(e, c), C.isValidString(c[e]) || delete c[e];
            var f = !1;
            if ("undefined" != typeof c[K.DEVICE_TYPE]) {
              for (var g in a.Client.DeviceType)
                if (c[K.DEVICE_TYPE] === a.Client.DeviceType[g]) {
                  f = !0;
                  break
                } f || delete c[K.DEVICE_TYPE]
            }
            if (f = !1, "undefined" != typeof c[K.DEVICE_CATEGORY]) {
              for (var h in a.Client.DeviceCategory)
                if (c[K.DEVICE_CATEGORY] === a.Client.DeviceCategory[h]) {
                  f = !0;
                  break
                } f || delete c[K.DEVICE_CATEGORY];
            }
            this._cachedMetadata = C.ObjectShallowCopyOmitNull(c)
          }
      };
      K.BROWSER_NAME = "browserName", K.BROWSER_VERSION = "browserVersion", K.DEVICE_BRAND = "deviceBrand", K.DEVICE_MANUFACTURER = "deviceManufacturer", K.DEVICE_MODEL = "deviceModel",
        K.DEVICE_TYPE = "deviceType", K.DEVICE_VERSION = "deviceVersion", K.FRAMEWORK_NAME = "frameworkName", K.FRAMEWORK_VERSION = "frameworkVersion", K.OPERATING_SYSTEM_NAME = "operatingSystemName", K.OPERATING_SYSTEM_VERSION = "operatingSystemVersion",
        K.DEVICE_CATEGORY = "deviceCategory";
      var L = b.Time = function(a, b) {
          this._timeInterface = a, this._logger = b, this._logger.setModuleName("Time"), this.current = function() {
            var a = this._timeInterface.getEpochTimeMs();
            return C.isInteger(a) || this._logger.error("current(): TimeInterface.getEpochTimeMs() did not return an integer (" + a + ")"),
              a
          }
        },
        M = b.Timer = function(a, b, c) {
          var d = this;
          this._logger = a, this._logger.setModuleName("Timer"), this._timerInterface = b, this._exceptionCatcher = c, this.create = function(a, b, c) {
            var e = function() {
                d._exceptionCatcher.runProtected(c, function() {
                  a()
                })
              },
              f = this.createTimer(e, b, c);
            return f
          }, this.createOnce = function(a, b, c) {
            var e = {
                cancel: null
              },
              f = function() {
                d._exceptionCatcher.runProtected(c, function() {
                  e && "function" == typeof e.cancel && (e.cancel(), e.cancel = null, e = null), a()
                })
              },
              g = this.createTimer(f, b, c);
            return e.cancel = g, g
          }, this.createTimer = function(a, b, c) {
            return this._logger.debug("createTimer(): calling TimerInterface.create"), this._timerInterface.createTimer(a, b, c);
          }
        }
    }()
  }(), a
});

/*! (C) 2016 Conviva, Inc. All rights reserved. Confidential and proprietary. */
Conviva.Impl=Conviva.Impl||{},Conviva.Impl.Html5PlayerInterface=function(a,b,c){function d(a,b){if(this._log("Html5PlayerInterface._constr()"),!a)throw new Error("Html5PlayerInterface: playerStateManager argument cannot be null.");
if(!b)throw new Error("Html5PlayerInterface: videoElement argument cannot be null.");this._playerStateManager=a,this._videoElement=b,this._eventListeners=[],this._registerVideoEventListeners(),this._resetPlayHeadTimes(),
this._resetTimeupdate(),this._startPolling(),this._findCurrentState(),this._playerStateManager.setClientMeasureInterface(this),this._playerStateManager.setModuleNameAndVersion("HTML5",Conviva.Client.version);
}var e=this,f=500,g=4e3/f,h=2e3/f,i=1,j=0,k=.25;e._lastPlayHeadTimeSpeeds=[],e._timeupdate=0,e._lastTimeupdate=0,e._currentTimeIsInvalid=!1,this._timerInterface=new Conviva.Impl.Html5Timer,this._loggingInterface=c.buildLogger(),
this._loggingInterface.setModuleName("Html5PlayerInterface"),this._width=-1,this._height=-1,this._addEventListener=function(a,b,c){"undefined"==typeof c&&(c=e._videoElement),e._eventListeners.push([a,b,c]),
window.addEventListener?c.addEventListener(a,b,!1):c.attachEvent("on"+a,b)},this._removeEventListener=function(a,b,c){"undefined"==typeof c&&(c=e._videoElement),window.removeEventListener?c.removeEventListener(a,b,!1):c.detachEvent("on"+a,b);
},this._registerVideoEventListeners=function(){e._addEventListener("ended",function(){e._receivedHtml5Event("ended")}),e._addEventListener("pause",function(){e._receivedHtml5Event("pause")}),e._addEventListener("playing",function(){
return 0==e._videoElement.currentTime?void(e._currentTimeIsInvalid=!0):void(e._videoElement.seeking||e._receivedHtml5Event("playing"))}),e._addEventListener("waiting",function(){e._receivedHtml5Event("waiting");
}),e._addEventListener("timeupdate",function(){e._currentTimeIsInvalid&&(e._timeupdate++,e._playerStateManager.getPlayerState()===Conviva.PlayerStateManager.PlayerState.PLAYING||e._videoElement.seeking||e._receivedHtml5Event("playing"));
}),e._addEventListener("error",function(){if(e._videoElement.error){var a=e._videoElement.error.code;e._reportHtml5Error(a)}}),e._addEventListener("loadedmetadata",e._loadedMetadata),e._addEventListener("seeking",function(){
e.isSeekStarted||(e.isSeekStarted=!0,e._playerStateManager.setPlayerSeekStart(-1)),e._currentTimeIsInvalid&&e._playerStateManager.getPlayerState()!==Conviva.PlayerStateManager.PlayerState.BUFFERING&&(e._log("Adjusting Conviva player state to: BUFFERING"),
e._receivedHtml5Event("waiting"))}),e._addEventListener("seeked",function(){e.isSeekStarted=!1,e._playerStateManager.setPlayerSeekEnd()}),e._monitorErrorsFromSourceElements()},this.getPHT=function(){return 1e3*e._videoElement.currentTime;
},this.getBufferLength=function(){var a=e._videoElement.buffered;if(void 0!==a){for(var b=0,c=0;c<a.length;c++){var d=a.start(c),f=a.end(c);d<=e._videoElement.currentTime&&e._videoElement.currentTime<f&&(b+=f-e._videoElement.currentTime);
}return e._currentBufferLength=b,1e3*e._currentBufferLength}},this.getSignalStrength=function(){return Conviva.PlayerStateManager.DEFAULT_SIGNAL_STRENGTH},this.getRenderedFrameRate=function(){return Conviva.PlayerStateManager.DEFAULT_RENDERED_FRAME_RATE;
},this._monitorErrorsFromSourceElements=function(){if("undefined"!=typeof e._videoElement.children){var a=function(){e._log("Caught non-specific error from <source> element, reporting as ERR_UNKNOWN"),
e._reportHtml5Error(0)};e._videoElement._sources=e._videoElement.children;for(var b=0;b<e._videoElement._sources.length;b++){var c=e._videoElement._sources[b];"SOURCE"==c.tagName&&e._addEventListener("error",a,c);
}}},this._removeVideoEventHandlers=function(){for(var a=0;a<e._eventListeners.length;a++){var b=e._eventListeners[a];e._removeEventListener(b[0],b[1],b[2])}e._eventListeners=[]},this._findCurrentState=function(){
e._prevReadyState=e._videoElement.readyState,0===e._videoElement.readyState?e._updateConvivaPlayerState(Conviva.PlayerStateManager.PlayerState.STOPPED):e._videoElement.ended?e._updateConvivaPlayerState(Conviva.PlayerStateManager.PlayerState.STOPPED):(e._videoElement.paused||e._videoElement.seeking)&&e._updateConvivaPlayerState(Conviva.PlayerStateManager.PlayerState.PAUSED),
e._videoElement.readyState>=e._videoElement.HAVE_METADATA&&e._loadedMetadata()},this._receivedHtml5Event=function(a){var b=e._convertHtml5EventToConvivaPlayerState(a);e._log("Received HTML5 event: "+a+". Mapped to Conviva player state: "+b),
e._updateConvivaPlayerState(b)},this._updateConvivaPlayerState=function(a){e._playerStateManager.getPlayerState()!==a&&(e._log("Changing Conviva player state to: "+a),e._playerStateManager.setPlayerState(a),
e._resetPlayHeadTimes(),e._playerStateRecentlyChanged=!0)},this._convertHtml5EventToConvivaPlayerState=function(a){switch(a){case"playing":return Conviva.PlayerStateManager.PlayerState.PLAYING;case"waiting":
return Conviva.PlayerStateManager.PlayerState.BUFFERING;case"ended":case"stopped":return Conviva.PlayerStateManager.PlayerState.STOPPED;case"pause":return Conviva.PlayerStateManager.PlayerState.PAUSED;default:
return Conviva.PlayerStateManager.PlayerState.UNKNOWN}},this._reportHtml5Error=function(a){var b;switch(a){case 1:b="MEDIA_ERR_ABORTED";break;case 2:b="MEDIA_ERR_NETWORK";break;case 3:b="MEDIA_ERR_DECODE";
break;case 4:b="MEDIA_ERR_SRC_NOT_SUPPORTED";break;default:b="MEDIA_ERR_UNKNOWN"}e._log("Reporting error: code="+a+" message="+b);var c=Conviva.Client.ErrorSeverity.FATAL;e._playerStateManager.sendError(b,c);
},this._loadedMetadata=function(){var a=e._videoElement.duration;isNaN(a)||a==1/0||e._playerStateManager.setDuration(a);var b=e._videoElement.videoWidth;!isNaN(b)&&b>=0&&e._playerStateManager.setVideoResolutionWidth(b);
var c=e._videoElement.videoHeight;!isNaN(c)&&c>=0&&e._playerStateManager.setVideoResolutionHeight(c)},this._startPolling=function(){this._previousPosition=0,this._currentPosition=0,this._currentBufferLength=0,
this._pollingTimerCancel=this._timerInterface.createTimer(this._poll,500,"Html5PlayerInterface._poll()")},this._poll=function(){e._pollStreamerResolution(),e._pollPosition(),e._inferPlayerStateFromPosition();
},this._pollStreamerResolution=function(){var a=e._videoElement.videoWidth;!isNaN(a)&&a>=0&&a!=e._width&&(e._playerStateManager.setVideoResolutionWidth(a),e._width=a);var b=e._videoElement.videoHeight;!isNaN(b)&&b>=0&&b!=e._height&&(e._playerStateManager.setVideoResolutionHeight(b),
e._height=b)},this._pollPosition=function(){if(e._previousPosition=e._currentPosition,e._currentPosition=e._videoElement.currentTime,now=Date.now(),e._lastPollTime>0&&now>e._lastPollTime){var a=e._currentPosition-e._previousPosition;
0>a&&(a=0),currentPhtSpeed=a/(now-e._lastPollTime)*1e3,e._lastPlayHeadTimeSpeeds.push(currentPhtSpeed)}e._lastPollTime=now,e._lastPlayHeadTimeSpeeds.length>Math.max(g,h)&&e._lastPlayHeadTimeSpeeds.shift();
},this._inferPlayerStateFromPosition=function(){var a=e._lastPlayHeadTimeSpeeds.length;if(a>=Math.min(h,g)){for(var b=0,c=e._lastPlayHeadTimeSpeeds.slice(),d=0;d<c.length;d++){var f=c[d];b+=f}b/=a;var l=i,m=k,n=e._videoElement.playbackRate;
!isNaN(n)&&n!=1/0&&n>0&&(isSafari=Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor")>0,isSafari&&.5>n&&(n=.5),l*=n,m*=n);var o=e._playerStateManager.getPlayerState();if(o!=Conviva.PlayerStateManager.PlayerState.PLAYING&&a>=h&&Math.abs(b-l)<m)return e._log("Adjusting Conviva player state to: PLAYING"),
void e._updateConvivaPlayerState(Conviva.PlayerStateManager.PlayerState.PLAYING);if(o==Conviva.PlayerStateManager.PlayerState.PLAYING&&a>=g&&b==j)return void(e._videoElement.paused?o!=Conviva.PlayerStateManager.PlayerState.PAUSED&&(e._log("Adjusting Conviva player state to: PAUSED"),
e._updateConvivaPlayerState(Conviva.PlayerStateManager.PlayerState.PAUSED)):e._videoElement.seeking||(e._log("Adjusting Conviva player state to: BUFFERING"),e._updateConvivaPlayerState(Conviva.PlayerStateManager.PlayerState.BUFFERING)));
if(e._currentTimeIsInvalid)return void(e._videoElement.paused?(o!=Conviva.PlayerStateManager.PlayerState.PAUSED&&(e._log("Adjusting Conviva player state to: PAUSED"),e._updateConvivaPlayerState(Conviva.PlayerStateManager.PlayerState.PAUSED)),
e._timeupdate=e._lastTimeupdate):e._videoElement.seeking||(e._timeupdate>1&&e._timeupdate==e._lastTimeupdate&&(e._log("Adjusting Conviva player state to: BUFFERING"),e._updateConvivaPlayerState(Conviva.PlayerStateManager.PlayerState.BUFFERING)),
e._lastTimeupdate=e._timeupdate))}},this._stopPolling=function(){this._pollingTimerCancel()},this._resetPlayHeadTimes=function(){e._lastPlayHeadTimeSpeeds=[],e._previousPosition=-1,e._lastPollTime=0},this._resetTimeupdate=function(){
e._lastTimeupdate=0,e._timeupdate=0},this._log=function(a){this._loggingInterface.log(a,Conviva.SystemSettings.LogLevel.DEBUG)},d.apply(this,arguments),this.cleanup=function(){this._log("Html5PlayerInterface.cleanup()"),
this._stopPolling(),this._removeVideoEventHandlers(),this._videoElement=null,this._playerStateManager=null}},Conviva.Impl=Conviva.Impl||{},Conviva.Impl.Html5Http=function(){function a(){}a.apply(this,arguments),
this.makeRequest=function(a,b,c,d,e,f){return this.makeRequestStandard.apply(this,arguments)},this.makeRequestStandard=function(a,b,c,d,e,f){var g=new XMLHttpRequest;return g.open(a,b,!0),d&&g.overrideMimeType&&(g.overrideMimeType=d),
d&&g.setRequestHeader&&g.setRequestHeader("Content-Type",d),e>0&&(g.timeout=e,g.ontimeout=function(){g.ontimeout=g.onreadystatechange=null,f&&f(!1,"timeout after "+e+" ms")}),g.onreadystatechange=function(){
4===g.readyState&&(g.ontimeout=g.onreadystatechange=null,200==g.status?f&&f(!0,g.responseText):f&&f(!1,"http status "+g.status))},g.send(c),null},this.release=function(){}},Conviva.Impl=Conviva.Impl||{},
Conviva.Impl.Html5Logging=function(){function a(){}a.apply(this,arguments),this.consoleLog=function(a,b){"undefined"!=typeof console&&(console.log&&b===Conviva.SystemSettings.LogLevel.DEBUG||b===Conviva.SystemSettings.LogLevel.INFO?console.log(a):console.warn&&b===Conviva.SystemSettings.LogLevel.WARNING?console.warn(a):console.error&&b===Conviva.SystemSettings.LogLevel.ERROR&&console.error(a));
},this.release=function(){}},Conviva.Impl=Conviva.Impl||{},Conviva.Impl.Html5Metadata=function(){function a(){}a.apply(this,arguments),this.getBrowserName=function(){return null},this.getBrowserVersion=function(){
return null},this.getDeviceBrand=function(){return null},this.getDeviceManufacturer=function(){return null},this.getDeviceModel=function(){return null},this.getDeviceType=function(){return null},this.getDeviceVersion=function(){
return null},this.getFrameworkName=function(){return"HTML5"},this.getFrameworkVersion=function(){return null},this.getOperatingSystemName=function(){return null},this.getOperatingSystemVersion=function(){
return null},this.getDeviceCategory=function(){return null},this.release=function(){}},Conviva.Impl=Conviva.Impl||{},Conviva.Impl.Html5Storage=function(){function a(){}a.apply(this,arguments),this.saveData=function(a,b,c,d){
var e=a+"."+b;try{localStorage.setItem(e,c),d(!0,null)}catch(f){d(!1,f.toString())}},this.loadData=function(a,b,c){var d=a+"."+b;try{var e=localStorage.getItem(d);c(!0,e)}catch(f){c(!1,f.toString())}},
this.release=function(){}},Conviva.Impl=Conviva.Impl||{},Conviva.Impl.Html5Time=function(){function a(){}a.apply(this,arguments),this.getEpochTimeMs=function(){var a=new Date;return a.getTime()},this.release=function(){};
},Conviva.Impl=Conviva.Impl||{},Conviva.Impl.Html5Timer=function(){function a(){}a.apply(this,arguments),this.createTimer=function(a,b,c){var d=setInterval(a,b),e=function(){-1!==d&&(clearInterval(d),d=-1);
};return e},this.release=function(){}};

var loadConviva = typeof ConvivaPrivateLoader === 'undefined';
// Copyright (c) 2014 Conviva Inc. All Rights Reserved.
// Author: Alban Nicolas (anicolas@conviva.com)

// Modifies the global loadConviva flag to ensure our JS libraries are disabled in non-supported browsers.
// Don't see a need to make this into a real class/module yet. Maybe after we add new exclusion criteria.

function convivaBrowserSupportsVideoElement() { //NO_RENAME:document,createElement,canPlayType
    try {
        return !!document.createElement('video').canPlayType;
    } catch (e) {
        return false;
    }
}
function convivaBrowserSupportsLocalStorage() { //NO_RENAME:window
    try {
        return 'localStorage' in window && window['localStorage'] !== null;
    } catch (e) {
        return false;
    }
}

var convivaSupportedBrowser = (convivaBrowserSupportsVideoElement() && convivaBrowserSupportsLocalStorage());

loadConviva = loadConviva && convivaSupportedBrowser;
if (loadConviva) {
var ConvivaPrivateLoader = (typeof ConvivaPrivateLoader !== 'undefined') ? ConvivaPrivateLoader : (function () { });
(function () {
// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-
// Copyright Conviva Inc 2010
// Author: George Necula (necula@conviva.com)

// Library for SLASH generated Javascript
// This is included first in the LivePass.js

// ConvivaPrivateLoader is defined at top-level in LivePass.js
// ConvivaPrivateTestingLoader is defined at top-level in TetingLivePassModule.js, loaded in tests after LivePass.js
// ConvivaPrivateModule is defined at top-level in LivePassModule.js (loaded after LivePass.js)
//   - this contains duplicate of classes from ConvivaPrivateLoader (the common ones)
//   - it is cleaned on LivePassInit.Cleanup ()
function registerName(cls, clsname) {
    if( typeof(ConvivaPrivateModule) != "undefined") {
        ConvivaPrivateModule[clsname] = cls;
    } else if( typeof(ConvivaPrivateTestingModule) != "undefined") {
        ConvivaPrivateTestingModule[clsname] = cls;
    } else {
        // We must be populating the Loader classes
        ConvivaPrivateLoader[clsname] = cls;
    }
}
registerName(registerName,"registerName");

// A special function used to mark identifiers for renaming
function __id(x) { return x; }
registerName(__id,"__id");


// Find the definition of a Conviva type by name
function getConvivaType(className) {
    if(typeof(ConvivaPrivateModule) != "undefined" && ConvivaPrivateModule.hasOwnProperty(className)) {
        return ConvivaPrivateModule[className];
    } else if(typeof(ConvivaPrivateTestingModule) != "undefined" && ConvivaPrivateTestingModule.hasOwnProperty(className)) {
        return ConvivaPrivateTestingModule[className];
    } else if(ConvivaPrivateLoader.hasOwnProperty(className)) {
        return ConvivaPrivateLoader[className];
    } else {
        return null;
    }
}
registerName(getConvivaType, "getConvivaType");

/* Construct a JS program that defines in the current scope all the names
 * from ConvivaPrivate
 */
function importConvivaPrivateProgram(fromWhere, fromWhereName) {
    var res="";
    var p;
    for(p in fromWhere) {
        if(fromWhere.hasOwnProperty(p)) {
            res += "var "+p+"="+__id(fromWhereName)+"."+p+";"
        }
    }
    return res;
}
registerName(importConvivaPrivateProgram,"importConvivaPrivateProgram");

// A special object user to mark the static initializer
function STAT_INIT () {
    return "STAT_INIT";
}
registerName(STAT_INIT,"STAT_INIT");

// Call the static initializer
function statInit(cls, clsname) {
    cls.call(STAT_INIT);
    registerName(cls, clsname);
}
registerName(statInit,"statInit");

// Define a public method
function defPubMeth(obj, name, m) {
    if(obj != STAT_INIT) {
        if(obj[name] == undefined) {
            obj[name] = m;
        } else {
            // overwriting
            obj[__id("super_")+name] = m;
        }
    }
}
registerName(defPubMeth,"defPubMeth");

// Define a private method
function defPrivMeth(obj,name,m) {
    if(obj != STAT_INIT) obj[name] = m;
}
registerName(defPrivMeth,"defPrivMeth");

// Define a static method
function defStatMeth(obj,cls,name,m) {
    if(obj == STAT_INIT) cls[name]= m;
}
registerName(defStatMeth,"defStatMeth");

// Define a getter
function defGet(obj,name,m) {
    if(obj != STAT_INIT) { //NO_RENAME: Object,configurable,enumerable,get
        if (typeof(Object.defineProperty) != 'undefined') {
            Object.defineProperty(obj, name, {
                configurable : true,
                enumerable : true,
                get : m
            });
        } else {
            obj.__defineGetter__(name, m);
        }
    }
}
registerName(defGet,"defGet");

function defSet(obj,name,m) {
    if(obj != STAT_INIT) { //NO_RENAME: Object,configurable,set
        if (typeof(Object.defineProperty) != 'undefined') {
            Object.defineProperty(obj, name, {
                configurable : true,
                set : m
            });
        } else { // The browser must support either defineProperty or __defineSetter__, or we will completely fail.
            obj.__defineSetter__(name, m);
        }
    }
}
registerName(defSet,"defSet");

function defStatGet(obj,cls,name,m) {
    if(obj == STAT_INIT) defGet(cls, name, m);
}
registerName(defStatGet,"defStatGet");

function defStatSet(obj,cls,name,m) {
    if(obj == STAT_INIT) defSet(cls, name, m);
}
registerName(defStatSet,"defStatSet");

function slIsArray(inObj) {
    // Is it an array, or an Object
    if(inObj.constructor == Array) {
        return true;
    } else if(typeof(inObj.length) == 'undefined') {
        return false;
    } else {
        return true;
    }
}
registerName(slIsArray,"slIsArray");

function slForEachPropValue(a, f) {
    var ist = slIsArray(a);
    if(slIsArray(a)) {
        for(var i=0;i<a.length;i++) {
            f(a[i]);
        }
    } else {
        for(var p in a) {
            if(a.hasOwnProperty(p)) f(a[p]);
        }
    }
}
registerName(slForEachPropValue,"slForEachPropValue");

function slForEachProp(a, f) {
    if(slIsArray(a)) {
        for(var i=0;i<a.length;i++) {
            f(i);
        }
    } else {
        for(var p in a) {
            if(a.hasOwnProperty(p)) f(p);
        }
    }
}
registerName(slForEachProp,"slForEachProp");

/* Support for declaring test classes and methods */
// Upon static initialization, declare the test class
function declTestClass(obj,name,cls,meta) {
    if(obj == STAT_INIT) jstest.DeclareTestClass(name, cls, meta);
}
registerName(declTestClass,"declTestClass");

/* On static initialization, declare the test method; on instance
 * construction, set the method closure. We need to do it this late
 * to get the right closure.
 */
function declTestMethod(obj,clsname,mname,mcode,meta) {
    if(obj == STAT_INIT) {
        jstest.DeclareTestMethod(clsname, mname, meta);
    } else {
        jstest.SetTestMethodClosure(clsname, mname, mcode);
    }
}
registerName(declTestMethod,"declTestMethod");

// Slash unsigned integers
function sluint () {
    sluint.two32 = 0x100000000;

    sluint.Cast = function (v) {
        var vi = parseInt(v);
        if(vi > sluint.MaxValue) {
            vi = vi % sluint.two32; // 32-bits, positive
        } else if(vi < 0) {
            vi = (- vi) % sluint.two32; // 32-bits of negation, use % only on positive numbers
            vi =  sluint.two32 - vi;
        }
        return vi;
    };

    sluint.uintRegex = new RegExp("^[0-9]+$");
    sluint.Parse = function (v) {
        Lang.parseChecker(v, sluint.uintRegex);
        return sluint.Cast(v);
    }

    sluint.MaxValue = sluint.two32 - 1;
    sluint.MinValue = 0;
}
statInit(sluint,"sluint");

// Slash signed integers (do not use "int" because Firefox claims it is a reserved word)
function slint () {
    slint.Cast = function (v) {
        // Cast first to uint to bring it in the range [0 .. 2^32)
        var vu = sluint.Cast(v);
        if(vu > slint.MaxValue) {
            vu = vu - sluint.two32;
        }
        return vu;
    };

    slint.intRegex = new RegExp("^[+-]?[0-9]+$");
    slint.Parse = function (v) {
        Lang.parseChecker(v, slint.intRegex);
        return slint.Cast(v);
    }

    slint.MaxValue =   0x7FFFFFFF;
    slint.MinValue = - 0x80000000;
}
statInit(slint,"slint");

function Int64() {
    var _s = this;

    if(_s == STAT_INIT) Int64.TWO_TO_32 /* : Number*/ = 4294967296.0;

    /** We store the int64 as two integers, the most significant bits
     * are a _signed_ 32-bit integer, and the least significant bits are
     * an _unsigned_ 32-bit integer.
     *
     * Together they denote the Number:
     *    Number(_h) * Number(2^32) + Number(l)
     **/

    /** Make a new Int64 with the value 0 */
    function __constr() {
        _s._l = 0;
        _s._h = 0;
    };

    /** Initialize from an unsigned int */
    defStatMeth(_s,Int64,"fromUnsignedInt", __fromUnsignedInt);
    function __fromUnsignedInt ( i /*: uint*/ ) /*: Int64*/ {
        var res /*: Int64*/ = new Int64 ();
        res._h = 0;
        res._l = i;
        return res;
    };

    /** Initialize from a signed int */
    defStatMeth(_s,Int64,"fromInt", __fromInt);
    function __fromInt( i /*: int*/ ) /*: Int64*/  {
        var res /*: Int64*/ = new Int64 ();
        if(i >= 0) {
            res._h = 0;
            res._l = sluint.Cast(i);
        } else {
            res._h = -1;
            res._l = sluint.Cast(i);
        }
        return res;
    };

    /** Initialize from a Number */
    defStatMeth(_s,Int64, "fromNumber", __fromNumber);
    function __fromNumber ( n /*: Number*/ ) /*: Int64*/ {
        var l1 /*: Number*/ = n % Int64.TWO_TO_32;
        // In AS, the remainder has the same sign as n
        if(l1 < 0) {
            l1 = Number(sluint.MaxValue) + 1.0 + l1;
        }
        var res /*: Int64*/ = new Int64 ();
        res._l = sluint.Cast(l1 + 0.5); // round to nearest
        res._h = slint.Cast((n - l1) / Int64.TWO_TO_32);
        // ensure _h * 2^32 + _l = n
        return res;
    };


    /** Convert to a Number */
    defGet(_s,"asNumber", __asNumber);
    function __asNumber () /*: Number*/ {
        return Number(_s._h) * Int64.TWO_TO_32 + Number(_s._l);
    };


    if(_s != STAT_INIT) {
        this.toString = function () {
            return _s.asNumber.toString();
        }
    }

    if(_s != STAT_INIT) __constr.apply(this, arguments);

};
statInit(Int64,"Int64");


function UInt64() {

    var _s = this;

    function __constr() {
        // Inherit a bunch of stuff from Int64
        Int64.call(_s);
        _s._l = 0;
        _s._h = 0;
    }

    /** Initialize from an unsigned int */
    defStatMeth(_s, UInt64,"fromUnsignedInt",__fromUnsignedInt);
    function __fromUnsignedInt(i /*: uint*/) /*: UInt64*/ {
        var res /*: UInt64*/ = new UInt64();
        res._h = 0;
        res._l = i;
        return res;
    };

    /** Initialize from a Number */
    defStatMeth(_s, UInt64,"fromNumber",__fromNumber);
    function __fromNumber ( n /*: Number*/ ) /*: UInt64*/ {
        var res /*: UInt64*/ = new UInt64();
        res._h = Math.floor(n / Int64.TWO_TO_32);  // 2^32
        res._l = n % Int64.TWO_TO_32;
        return res;
    };


    if(_s != STAT_INIT) __constr.apply(arguments);
};
statInit(UInt64,"UInt64");

// DO NOT EDIT! THIS FILE WAS GENERATED BY Slash from ../csClient/CwsClient/CandidateStream.cs
// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-

// Copyright (c) 2011, Conviva Inc. All Rights Reserved.
// Author: Henry Milner (henry@conviva.com)



// namespace
    // API_ENTER
    /// <summary>
    /// A stream to which a ConvivaStreamerProxy can potentially switch.
    /// This object contains no information about the actual URL of the stream it represents.
    /// </summary>
    function CandidateStream() {
        var _s = this;

        /// <summary>
        /// Construct a stream having bitrate <paramref name="bitrate"/> in kilo-bits-per-second and streaming
        /// from a resource named <paramref name="resource"/>.
        /// </summary>
        /// <param name="id">The ID of this stream. Used to identify the stream in cases where multiple streams can have the same bitrate and resource. Otherwise, this can be null.</param>
        /// <param name="bitrate">The bitrate of the stream, in kilo-bits-per-second, or 1000 bits per second. Pass -1 if the bitrate of this stream is unknown or irrelevant.</param>
        /// <param name="resource">The name of the resource from which this stream is loaded. For example, this could be the name of a CDN. Pass null if the resource of this stream is unknown or irrelevant.</param>
        function _constr(id /* : String */, bitrate /* : int */, resource /* : String */) {
            _s.id = id;
            _s.bitrate = bitrate;
            _s.resource = resource;
        }

        /// <summary>
        /// Destroy this object.
        /// </summary>
        defPubMeth(_s,"Cleanup",__Cleanup);
        function __Cleanup() /* : void */  {
            _s.id = null;
            _s.bitrate = 0;
            _s.resource = null;
        }

        /// <summary>
        /// An identifier for this stream. Should be unique across all CandidateStreams
        /// used by a ConvivaStreamerProxy. However, if this is null, it is assumed that
        /// streams are uniquely identified by their bitrate and resource fields.
        /// </summary>
// Use a property to allow the obfuscator to keep an unobfuscated version
        if(_s != STAT_INIT) _s.__auto_id /* : String */ = undefined;
        defGet(_s,"id",__get_id);
        function __get_id()  { return _s.__auto_id; }
        defSet(_s,"id",__set_id);
        function __set_id(value /* : String */)  { _s.__auto_id = value; }


        /// <summary>
        /// The bitrate (in kilo-bits-per-second) at which this stream plays media.
        ///
        /// -1 if unknown.
        /// </summary>

        if(_s != STAT_INIT) _s.__auto_bitrate /* : int */ = undefined;
        defGet(_s,"bitrate",__get_bitrate);
        function __get_bitrate()  { return _s.__auto_bitrate; }
        defSet(_s,"bitrate",__set_bitrate);
        function __set_bitrate(value /* : int */)  { _s.__auto_bitrate = value; }


        /// <summary>
        /// The resource from which this stream loads media.
        ///
        /// Null if unknown.
        /// </summary>

        if(_s != STAT_INIT) _s.__auto_resource /* : String */ = undefined;
        defGet(_s,"resource",__get_resource);
        function __get_resource()  { return _s.__auto_resource; }
        defSet(_s,"resource",__set_resource);
        function __set_resource(value /* : String */)  { _s.__auto_resource = value; }


        /////////////////////////////////////////////////////////////////////////////////
        /// The following methods are not part of the API and are for Conviva internal
        /// use only.
        /////////////////////////////////////////////////////////////////////////////////

        /**
         * Checks whether this object is valid.  This is necessary for languages
         * that are not typesafe, where users can set fields arbitrarily.
         *
         * @return null if this object is valid.  Otherwise return a string
         * describing the problem.
         *
         * @private
         */
        defPubMeth(_s,"CheckValidity",__CheckValidity);
        function __CheckValidity() /* : String */  {
            // In dynamically-typed languages, we must ensure that fields are of the proper types.
            if (_s.id != null && !((typeof _s.id === "string"))) {
                return "CandidateStream.id is not a string";
            } else if (_s.bitrate != null && !((typeof _s.bitrate === "number"))) {
                return "CandidateStream.bitrate is not an int";
            } else if (_s.resource != null && !((typeof _s.resource === "string"))) {
                return "CandidateStream.resource is not a string";
            }
            return null;
        }

        /**
         * Construct clone of the proper type, from a similar object perhaps constructed
         * in another module. We copy fields one by one
         */
        defStatMeth(_s,CandidateStream,"ConstructClone",__ConstructClone);
        function __ConstructClone(fromObj /* : Object */) /* : CandidateStream */  {
            if (fromObj == null) return null;
            var res /* : CandidateStream */ = new CandidateStream("", -1, null);
            res.id = NativeLang.GetStringField("id", fromObj);
            res.bitrate = slint.Cast(NativeLang.GetField("bitrate", fromObj));
            res.resource = NativeLang.GetStringField("resource", fromObj);
            return res;
        }

        if(_s != STAT_INIT) _constr.apply(_s, arguments);
    }
statInit(CandidateStream,"CandidateStream");
    // API_EXIT

// DO NOT EDIT! THIS FILE WAS GENERATED BY Slash from ../csClient/CwsClient/ConvivaContentInfo.cs
// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-

// Copyright (c) 2011, 2012 Conviva Inc. All Rights Reserved.
// Author: Gary Kumfert (gary@conviva.com) (Original AS3 code)
// Author: George Necula (necula@conviva.com) (Ported to C#)
// Author: Henry Milner (henry@conviva.com) (Unified C# and AS3 versions)
// Author: Yan Li (yan@conviva.com)


// namespace
    // API_ENTER

    ///<summary>
    /// Encapsulates all the information required to play video content
    ///</summary>
    function ConvivaContentInfo() {
        var _s = this;

        ///////////////////////////////////////////////////////////////////////
        // Begin constants
        ///////////////////////////////////////////////////////////////////////

        // Potential values for cdnName.
        //
        //NOTE(henry): These constants should be kept consistent with the
        // enumeration of CDN names in CommonWithReporting.xml.  Enum names
        // in that file should equal string values in this file.  For example,
        // CDN_NAME_AKAMAI has a value of "AKAMAI" here and corresponds to
        // the CDNName.AKAMAI enum in CommonWithReporting.xml.
        //
        // CDNName.UNKNOWN is the one exception to this rule.  That enum
        // should not be part of the client API, since the client should never
        // report it.

        /// <summary>
        /// The value of the cdnName field for videos streamed from Akamai
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_AKAMAI /* : String */ = "AKAMAI";

        /// <summary>
        /// The value of the cdnName field for videos streamed from Amazon.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_AMAZON /* : String */ = "AMAZON";

        /// <summary>
        /// The value of the cdnName field for videos streamed from AT&T CDN.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_ATT /* : String */ = "ATT";

        /// <summary>
        ///  The value of the cdnName field for videos streamed from BitGravity.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_BITGRAVITY /* : String */ = "BITGRAVITY";

        /// <summary>
        /// The value of the cdnName field for videos streamed from BT (British Telecom).
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_BT /* : String */ = "BT";

        /// <summary>
        /// The value of the cdnName field for videos streamed from CDNetworks
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_CDNETWORKS /* : String */ = "CDNETWORKS";

        /// <summary>
        /// The value of the cdnName field for videos streamed from ChinaCache.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_CHINACACHE /* : String */ = "CHINACACHE";

        /// <summary>
        /// The value of the cdnName field for videos streamed from EdgeCast.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_EDGECAST /* : String */ = "EDGECAST";

        /// <summary>
        ///  The value of the cdnName field for videos streamed from Highwinds.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_HIGHWINDS /* : String */ = "HIGHWINDS";

        /// <summary>
        /// The value of the cdnName field for videos streamed from Internap.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_INTERNAP /* : String */ = "INTERNAP";

        /// <summary>
        /// The value of the cdnName field for videos streamed from Level3 Communications.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_LEVEL3 /* : String */ = "LEVEL3";

        /// <summary>
        /// The value of the cdnName field for videos streamed from Limelight Networks.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_LIMELIGHT /* : String */ = "LIMELIGHT";

        /// <summary>
        /// The value of the cdnName field for videos streamed via Octoshape.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_OCTOSHAPE /* : String */ = "OCTOSHAPE";

        /// <summary>
        /// The value of the cdnName field for videos streamed via Swarmcast.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_SWARMCAST /* : String */ = "SWARMCAST";

        /// <summary>
        ///  The value of the cdnName field for videos streamed from Velocix.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_VELOCIX /* : String */ = "VELOCIX";

        /// <summary>
        /// The value of the cdnName field for videos streamed from Telefonica.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_TELEFONICA /* : String */ = "TELEFONICA";

        /// <summary>
        /// The value of the cdnName field for videos streamed from Microsoft.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_MICROSOFT /* : String */ = "MICROSOFT";

        /// <summary>
        /// The value of the cdnName field for videos streamed from CDNvideo.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_CDNVIDEO /* : String */ = "CDNVIDEO";

        /// <summary>
        /// The value of the cdnName field for videos streamed from Qbrick.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_QBRICK /* : String */ = "QBRICK";

        /// <summary>
        /// The value of the cdnName field for videos streamed from NGENIX.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_NGENIX /* : String */ = "NGENIX";

        /// <summary>
        /// The value of the cdnName field for videos streamed from IP-Only.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_IPONLY /* : String */ = "IPONLY";

        /// <summary>
        /// The value of the cdnName field for videos streamed from TALKTALK.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_TALKTALK /* : String */ = "TALKTALK";

        /// <summary>
        /// The value of the cdnName field for videos streamed from in-house servers.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_INHOUSE /* : String */ = "INHOUSE";

        /// <summary>
        /// The value of the cdnName field for videos streamed from Comcast.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_COMCAST /* : String */ = "COMCAST";

        /// <summary>
        /// The value of the cdnName field for videos streamed from NICE.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_NICE /* : String */ = "NICE";

        /// <summary>
        /// The value of the cdnName field for videos streamed from TELENOR.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_TELENOR /* : String */ = "TELENOR";

        /// <summary>
        /// The value of the cdnName field for videos streamed from FASTLY.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_FASTLY /* : String */ = "FASTLY";

        /// <summary>
        /// The value of the cdnName field for videos streamed from TELIA.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_TELIA /* : String */ = "TELIA";

        /// <summary>
        /// The value of the cdnName field for videos streamed from CHINANETCENTER.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_CHINANETCENTER /* : String */ = "CHINANETCENTER";

        /// <summary>
        /// The value of the cdnName field for videos streamed from MIRRORIMAGE.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_MIRRORIMAGE /* : String */ = "MIRRORIMAGE";

        /// <summary>
        /// The value of the cdnName field for videos streamed from SONIC.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_SONIC /* : String */ = "SONIC";

        /// <summary>
        /// The value of the cdnName field for videos streamed from ATLAS.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_ATLAS /* : String */ = "ATLAS";

        /// <summary>
        /// The value of the cdnName field for videos streamed from OOYALA.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_OOYALA /* : String */ = "OOYALA";

        /// <summary>
        /// The value of the cdnName field for videos streamed from TATA.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_TATA /* : String */ = "TATA";

        /// <summary>
        /// The value of the cdnName field for videos streamed from GOOGLE.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_GOOGLE /* : String */ = "GOOGLE";

        /// <summary>
        /// The value of the cdnName field for videos streamed from INSTARTLOGIC.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_INSTARTLOGIC /* : String */ = "INSTARTLOGIC";

        /// <summary>
        /// The value of the cdnName field for videos streamed from TELSTRA.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_TELSTRA /* : String */ = "TELSTRA";

        /// <summary>
        /// The value of the cdnName field for videos streamed from OPTUS.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_OPTUS /* : String */ = "OPTUS";

	/// <summary>
        /// The value of the cdnName field for videos streamed from a CDN not listed here.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.CDN_NAME_OTHER /* : String */ = "OTHER";

        /// <summary>
        ///  The value of the frameworkName field for Brightcove-based players.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.FRAMEWORK_NAME_BRIGHTCOVE /* : String */ = "Brightcove";

        /// <summary>
        /// The value of the frameworkName field for Kaltura-based players.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.FRAMEWORK_NAME_KALTURA /* : String */ = "Kaltura";

        /// <summary>
        /// The value of the frameworkName field for Ooyala-based players.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.FRAMEWORK_NAME_OOYALA /* : String */ = "Ooyala";

        /// <summary>
        /// The value of the frameworkName field for OSMF-based players.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.FRAMEWORK_NAME_OSMF /* : String */ = "OSMF";

        /// <summary>
        /// The value of the frameworkName field for players based on thePlatform.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.FRAMEWORK_NAME_THE_PLATFORM /* : String */ = "thePlatform";

        /// <summary>
        /// The value of the deviceType field for gaming consoles.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.DEVICE_TYPE_CONSOLE /* : String */ = "Console";

        /// <summary>
        /// The value of the deviceType field for mobile devices.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.DEVICE_TYPE_MOBILE /* : String */ = "Mobile";

        /// <summary>
        ///  The value of the deviceType field for personal computers.
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.DEVICE_TYPE_PC /* : String */ = "PC";

        /// <summary>
        /// The value of the deviceType field for set-top boxes
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.DEVICE_TYPE_SET_TOP_BOX /* : String */ = "Settop";

        /// <summary>
        /// The value of the pluginName field for Kaltura plugin (insights+precision).
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.PLUGIN_NAME_KALTURA /* : String */ = "ConvivaKalturaPlugin";


        /// <summary>
        /// Use in place of a resource when not known
        /// </summary>
        if(_s == STAT_INIT) ConvivaContentInfo.NO_RESOURCE /* : String */ = "no_resource";

        ///////////////////////////////////////////////////////////////////////
        // End constants
        ///////////////////////////////////////////////////////////////////////

        ///////////////////////////////////////////////////////////////////////
        // Begin public fields
        ///////////////////////////////////////////////////////////////////////


        /// <summary>
        /// A unique identifier for the content, preferably human-readable.
        /// </summary>
        if(_s != STAT_INIT) _s.assetName /* : String */ = undefined;

        /// <summary>
        /// Duration of the asset in seconds.
        /// </summary>
        if(_s != STAT_INIT) _s.duration /* : int */ = -1;

        /// <summary>
        /// Encoded fps of the asset
        /// </summary>
        if(_s != STAT_INIT) _s.encodedFps /* : int */ = -1;

        if(_s != STAT_INIT) _s._tags /* : DictionaryCS(string, string) */ = null;

        /// <summary>
        /// A set of key-value pairs used in resource selection and policy evaluation
        /// </summary>

        defGet(_s,"tags",__get_tags);
        function __get_tags()  { return  Lang.StringDictionaryToRepr(_s._tags); }
        defSet(_s,"tags",__set_tags);
        function __set_tags(value /* : Object */)  {  _s._tags =  Lang.DictionaryFromRepr/*string, string*/(value); }


        /// <summary>
        /// Set this to the bitrate (1000 bits-per-second) to be used for the integrations
        /// where the streamer does not know the bitrate being player. This value is used
        /// until the streamer reports a bitrate.
        /// </summary>
        if(_s != STAT_INIT) _s.defaultReportingBitrateKbps /* : int */ = -1;


        /// <summary>
        /// A string identifying the CDN used to stream video.  This must be
        /// chosen from the list of CDN_NAME_* constants in this class.
        ///
        /// If you use a CDN whose name is not in the list of CDN_NAME_*
        /// constants, please use CDN_NAME_OTHER temporarily and initiate a
        /// service request with Conviva so that we can add your CDN to the
        /// list.
        ///
        /// If content is served in-house instead of using a CDN, use CDN_NAME_IN_HOUSE.
        /// </summary>
        if(_s != STAT_INIT) _s.defaultReportingCdnName /* : String */ = ConvivaContentInfo.CDN_NAME_OTHER;


        /// <summary>
        /// Set this to a string that will be used as the resource name for the integrations
        /// where the streamer does not itself know the resource being played. If this is null,
        /// then the value of cdnName is used for this purpose.
        /// </summary>
        if(_s != STAT_INIT) _s.defaultReportingResource /* : String */ = null;




        /// <summary>
        /// A string identifying the code framework for the player, if any.
        /// Check the list of FRAMEWORK_NAME_* constants in this class for
        /// an applicable name.  If none is available, choose an appropriate
        /// name instead.
        ///
        /// For example, players developed with OSMF should set this to
        /// FRAMEWORK_NAME_OSMF.  For players developed with an OVPP, this
        /// should be the same as the OVPP name.
        ///
        /// This field is optional.
        /// </summary>
        if(_s != STAT_INIT) _s.frameworkName /* : String */ = null;


        /// <summary>
        /// The version number of the framework code, if any.  For example, a player
        /// using version 1.0 of OSMF should set this to "1.0".
        ///
        /// This field is optional and should only be populated if frameworkName
        /// is populated.
        /// </summary>
        if(_s != STAT_INIT) _s.frameworkVersion /* : String */ = null;

        /// <summary>
        /// @private
        ///
        /// A string identifying the Conviva plugin used for the integration.
        /// For example, an OSMF-based player using the Conviva OSMF plugin
        /// for OSMF 1.0 and Flash 10.1 should set this to
        /// "ConvivaOSMFPlugin_OSMF1_0_FP10_1".
        ///
        /// This field is optional.
        /// </summary>
        if(_s != STAT_INIT) _s.pluginName /* : String */ = null;

        /// <summary>
        /// @private
        ///
        /// The version number of the Conviva plugin used for the integration,
        /// if any.  For example, "2.30.0.12345" or "2.30.0".
        ///
        /// This field is optional and should only be populated if pluginName
        /// is populated.
        /// </summary>
        if(_s != STAT_INIT) _s.pluginVersion /* : String */ = null;

        /// <summary>
        /// A string identifying the viewer.
        ///
        /// This field is optional.
        /// </summary>
        if(_s != STAT_INIT) _s.viewerId /* : String */ = null;

        /// <summary>
        /// A string identifying the device in use.  This should not be used
        /// to identify the type of device, but rather the particular instance
        /// of the device on which this session is running.  For example, if
        /// the session is running on a SmartPhone 2 revision 1.2.3.4 with ID
        /// #0123456789, set this to "0123456789".
        ///
        /// This field is optional.
        /// </summary>
        if(_s != STAT_INIT) _s.deviceId /* : String */ = null;

        /// <summary>
        /// A string identifying the kind of device being used to play video.
        /// If specified, this must be chosen from the list of DEVICE_TYPE_*
        /// constants.  For example, a session on a mobile device should use
        /// DEVICE_TYPE_MOBILE.
        ///
        /// LivePass may be able to infer the device type in some cases.  The
        /// integration guide for your platform will note whether it is
        /// necessary to set this field.
        /// </summary>
        if(_s != STAT_INIT) _s.deviceType /* : String */ = null;

        /// <summary>
        /// A string identifying the player in use, preferably human-readable.
        /// If you have multiple players, this can be used to distinguish between them.
        ///
        /// This field is optional.
        /// </summary>
        if(_s != STAT_INIT) _s.playerName /* : String */ = null;

        /// <summary>
        /// The URL from which video is loaded.
        ///
        /// Note: If this changes during a session, there is no need to update
        /// this value - just use the URL from which loading initially occurs.
        /// </summary>
        if(_s != STAT_INIT) _s.streamUrl /* : String */ = null;

        if(_s != STAT_INIT) _s._isLive /* : Boolean */ = false;
        /// <summary>
        /// Set to true if the session includes live content, and false otherwise.
        /// </summary>

        defGet(_s,"isLive",__get_isLive);
        function __get_isLive()  { return  _s._isLive; }
        defSet(_s,"isLive",__set_isLive);
        function __set_isLive(value /* : Boolean */)  {
                  if (value === "true") { value = true; }
                  if (value === "false") { value = false; }
                  if (value !== true && value !== false) {
                      var utils /* : Utils */ = Utils.getInstance();
                      utils.err("Invalid value for ConvivaContentInfo.isLive, expected boolean. Defaulting to false.");
                      value = false;
                  }
                  _s._isLive = value;
                }


        ///////////////////////////////////////////////////////////////////////
        // End public fields
        ///////////////////////////////////////////////////////////////////////


        ///<summary>
        ///Create a new ConvivaContentInfo for a give asset
        /// </summary>
        /// <param name="assetName">The asset name for the content to be played</param>
        /// <param name="tags">The tag dictionary (mapping string to string)</param>
        function _constr(assetName /* : String */, tags /* : Object */) {
            _s.assetName = assetName;
            _s.tags = tags; // Use the setter
            if (_s._tags == null) {
                _s._tags = new DictionaryCS/*<string, string>*/();
            }

        }


       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_AKAMAI
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_AMAZON
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_ATLAS
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_ATT
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_BITGRAVITY
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_BT
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_CDNETWORKS
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_CDNVIDEO
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_CHINACACHE
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_CHINANETCENTER
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_COMCAST
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_EDGECAST
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_FASTLY
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_GOOGLE
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_HIGHWINDS
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_INHOUSE
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_INSTARTLOGIC
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_INTERNAP
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_IPONLY
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_LEVEL3
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_LIMELIGHT
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_MICROSOFT
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_MIRRORIMAGE
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_NGENIX
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_NICE
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_OCTOSHAPE
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_OOYALA
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_OPTUS
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_OTHER
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_QBRICK
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_SONIC
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_SWARMCAST
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_TALKTALK
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_TATA
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_TELEFONICA
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_TELENOR
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_TELIA
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_TELSTRA
       //JSRENAME:constant:_s:ConvivaContentInfo:CDN_NAME_VELOCIX
       //JSRENAME:constant:_s:ConvivaContentInfo:DEVICE_TYPE_CONSOLE
       //JSRENAME:constant:_s:ConvivaContentInfo:DEVICE_TYPE_MOBILE
       //JSRENAME:constant:_s:ConvivaContentInfo:DEVICE_TYPE_PC
       //JSRENAME:constant:_s:ConvivaContentInfo:DEVICE_TYPE_SET_TOP_BOX
       //JSRENAME:constant:_s:ConvivaContentInfo:FRAMEWORK_NAME_BRIGHTCOVE
       //JSRENAME:constant:_s:ConvivaContentInfo:FRAMEWORK_NAME_KALTURA
       //JSRENAME:constant:_s:ConvivaContentInfo:FRAMEWORK_NAME_OOYALA
       //JSRENAME:constant:_s:ConvivaContentInfo:FRAMEWORK_NAME_OSMF
       //JSRENAME:constant:_s:ConvivaContentInfo:FRAMEWORK_NAME_THE_PLATFORM
       //JSRENAME:constant:_s:ConvivaContentInfo:NO_RESOURCE
       //JSRENAME:constant:_s:ConvivaContentInfo:PLUGIN_NAME_KALTURA
        if(_s != STAT_INIT) _constr.apply(_s, arguments);
    }
statInit(ConvivaContentInfo,"ConvivaContentInfo");
    // API_EXIT



// DO NOT EDIT! THIS FILE WAS GENERATED BY Slash from ../csClient/CwsClient/ConvivaStreamerProxy.cs
// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-

// Copyright (c) 2011-2013 Conviva Inc. All Rights Reserved.
// Author: George Necula (necula@conviva.com), Henry Milner (henry@conviva.com), Yan Li (yan@conviva.com)



// #if CWS
// #endif
// #if !CWS
// #endif

// namespace
    /// \mainpage
    /// This is the main interface between the Conviva clients and the actual streamer objects. You can construct a subclass of ConvivaStreamerProxy
    /// (abbreviated CSP below) for each streamer that you want to interface to Conviva LivePass.
    ///
    /// The CSP class exposes getters for data and provides callback for some state changes.
    ///
    /// The CSP is expected to have the following state machine
    ///
    /// <b>State Machine:</b>
    ///
    /// | State\ Input| Play() \n when BF | Play() \n when !BF  |  Pause()   |  Stop()   |Seek() \n when BF|Seek() \n when !BF|  BE     |  BF    |  EOS  |
    /// | :---------: | :------------  --:|:-------------------:|:----------:|:---------:|:---------------:|:----------------:|:-------:|:------:|:------|
    /// | STOPPED     | PLAYING           | BUFFERING           |PAUSED      |           | PAUSED          | PAUSED           |         |        |       |
    /// | PLAYING     |                   |                     |PAUSED      | STOPPED   |                 |BUFFERING         |BUFFERING|        |STOPPED|
    /// |PAUSED       | PLAYING           | BUFFERING           |            |STOPPED    |                 |                  |         |        |       |
    /// |BUFFERING    | PLAYING           |                     |PAUSED      |STOPPED    | PLAYING         |                  |         | PLAYING|       |
    ///
    /// <b>Legend:</b> \n
    /// <b>BF (Buffer Full) :</b> GetBufferLengthMs() >= GetStartingBufferLengthMs() \n
    /// <b>BE (Buffer Empty):</b> GetBufferLengthMs() == 0 \n
    /// <b>EOS</b> : End Of Stream
    ///
    /// The dynamic sequence of calls and events:
    /// <ol>
    /// <li> The Application creates an instance of ConvivaStreamerProxy, or actually an instance of a subclass of CSP
    ///    that is specific to the streamer to be monitored. Since CSP is constructed early, it can already record state
    ///    changes, and errors.
    /// </li>
    /// <li> The ConvivaStreamerProxy constructor:
    ///
    ///    *  The CSP should read the initial state from the underlying streamer and should call the setters
    ///     for example, SetPlayingState, SetError, SetMetadata, SetBitrate.
    ///     No notification to the Monitor will be provided just yet because the connection to the Monitor has not yet been
    ///     established. In fact, the CSP may be in the static loader, and the Monitor is not yet loaded.
    ///
    /// <li> When the Monitor receives the instance of CSP, it will call SetMonitoringNotifier to set a callback to receive state change notification.
    ///    * Upon call of SetMonitoringNotifier, if the proxy already contains state or errors that have been set, the state change notification will
    ///    be called immediately.

    ///
    ///     Note that for some streamers, the streamer itself (not the corresponding CSP) is passed to the LivePassModule. When the module containing
    ///     the monitor loads, it will create the corresponding CSP. Note that this means that for such streamers we can implement the
    ///     CSP subclass in the module itself (e.g., MonitorMediaElement for Silverlight), but it also means that we do not get the
    ///     benefit of the early monitoring before the monitor loads.
    ///
    ///
    /// <li> During the lifetime of the streamer, the CSP instance will read metrics from the streamer and call corresponding setters
    ///    (e.g., SetPlayingState), which will in turn trigger notification of the corresponding to the registered callback functions.
    ///
    /// <li> The Monitor can read streamer metrics, by calling getters on CSP (e.g., GetPlayheadTimeMs).
    /// </ol>


    /// <summary>
    /// This class is part of the API and may be instantiated outside the LivePass module. This class,
    /// must have accessors that take and return only base types (integers, strings). We cannot use user-defined types
    /// because they have different identities in the LivePass module and the module where this class is instantiated.
    ///
    /// </summary>
    // API_ENTER
    function ConvivaStreamerProxy() {
        var _s = this;

        if(_s != STAT_INIT) _s._notifiers /* : ListCS(Action(string, object)) */ = new ListCS/*Action(string, object)*/();

        // Private state values
        if(_s != STAT_INIT) _s._stream /* : StreamInfo */ = new StreamInfo(-1, ConvivaContentInfo.CDN_NAME_OTHER, ConvivaContentInfo.NO_RESOURCE, -1, -1, -1);
        if(_s != STAT_INIT) _s._playingState /* : String */ = ConvivaStreamerProxy.UNKNOWN;

        // The last metadata received, or null if none
        if(_s != STAT_INIT) _s._lastMetadata /* : Object */ = null;

        // The last error encountered, or null if none
        if(_s != STAT_INIT) _s._lastError /* : StreamerError */ = null;
        // If we are told about errors, before we have a notifier from the monitor, we store them
        if(_s != STAT_INIT) _s._pendingErrors /* : ListCS(StreamerError) */ = new ListCS/*StreamerError*/();


        // display width in pixels
        if(_s != STAT_INIT) _s._displayWidth /* : int */ = -1;

        // display height in pixels
        if(_s != STAT_INIT) _s._displayHeight /* : int */ = -1;


        if(_s != STAT_INIT) _s._availableStreams /* : ListCS(StreamInfo) */ = null;

        if(_s != STAT_INIT) _s._currentLoadingStatus /* : DownloadStatus */ = null;

        if(_s != STAT_INIT) _s.isProxyInitialized /* : Boolean */ = undefined;

        // event reasons
        /// <summary>
        /// Identifies the event is related to network info change.
        /// @see SetMonitoringNotifier
        /// </summary>
        if(_s == STAT_INIT) ConvivaStreamerProxy.REASON_NETWORKINFOCHANGE /* : String */ = "NetworkInfoChange";

        /// <summary>
        /// Identifies the event is related to player state change.
        /// @see SetMonitoringNotifier
        /// </summary>
        if(_s == STAT_INIT) ConvivaStreamerProxy.REASON_PLAYINGSTATECHANGE /* : String */ = "PlayingStateChange";

        /// <summary>
        /// Identifies an event to indicate that there is an update to any of the components of the presentation  rendered by the streamer.
        /// The changes to the presentation components can be to bitrate, resource, cdn, audio track or camera angle.
        /// @see SetMonitoringNotifier
        /// </summary>
        if(_s == STAT_INIT) ConvivaStreamerProxy.REASON_STREAMINFOCHANGE /* : String */ = "StreamInfoChange";

        /// <summary>
        /// Identifies an event to indicate that there are new bitrate variants (or tracks)  available for switching.
        /// @see SetMonitoringNotifier
        /// </summary>
        if(_s == STAT_INIT) ConvivaStreamerProxy.REASON_AVAILABLESTREAMINFOCHANGE /* : String */ = "AvailableStreamInfoChange";

        /// <summary>
        /// Identifies an event to indicate that Proxy had been initialized. When a notifier is registered with the CSP using the
        /// SetMonitoringNotifier() , this should be the first event which should be fired.
        /// @see SetMonitoringNotifier
        /// </summary>
        if(_s == STAT_INIT) ConvivaStreamerProxy.REASON_PROXYINITIALIZED /* : String */ = "ProxyInitialized";

        /// <summary>
        /// Passed when a Metadata is encountered
        /// @see SetMonitoringNotifier
        /// </summary>
        if(_s == STAT_INIT) ConvivaStreamerProxy.REASON_METADATACHANGE /* : String */ = "MetadataChange";


        /// <summary>
        /// Identifies the event related to File download status.
        /// @see SetMonitoringNotifier
        /// </summary>
        if(_s == STAT_INIT) ConvivaStreamerProxy.REASON_LOADINGSTATUSCHANGE /* : String */ = "LoadingStatusChange";

        /// <summary>
        /// Identifies an event to indicate that that download status has changed.
        /// @see SetMonitoringNotifier
        /// </summary>
        if(_s == STAT_INIT) ConvivaStreamerProxy.REASON_DOWNLOADSTATECHANGE /* : String */ = "DownloadStateChange";

        /// <summary>
        /// Identifies the event related to display size change.
        /// @see SetMonitoringNotifier
        /// </summary>
        ///
        if(_s == STAT_INIT) ConvivaStreamerProxy.REASON_DISPLAYSIZECHANGE /* : String */ = "DisplaySizeChange";

        /// <summary>
        /// Passed when a new Error is encountered
        /// @see SetMonitoringNotifier
        /// </summary>
        if(_s == STAT_INIT) ConvivaStreamerProxy.REASON_ERRORCHANGE /* : String */ = "ErrorChange";

        /// <summary>
        /// Passed when a logging string is passed.
        /// @see SetMonitoringNotifier
        /// </summary>
        if(_s == STAT_INIT) ConvivaStreamerProxy.REASON_LOG /* : String */ = "Log";

        /// <summary>
        /// Indicates a resource error occurring.
        /// </summary>
        if(_s == STAT_INIT) ConvivaStreamerProxy.REASON_RESOURCE_ERROR /* : String */ = "ResourceError";

        /// <summary>
        /// Indicates a presentation change occurring.
        /// </summary>
        if(_s == STAT_INIT) ConvivaStreamerProxy.REASON_PRESENTATION_CHANGE /* : String */ = "PresentationChange";


        /// STOPPED: player state of stopped and the play position is 0.
        /// @see GetPlayingState()
        if(_s == STAT_INIT) ConvivaStreamerProxy.STOPPED /* : String */ = "STOPPED";
        /// PLAYING: player state of playing.  In this state the play position is advancing.
        /// @see GetPlayingState()
        if(_s == STAT_INIT) ConvivaStreamerProxy.PLAYING /* : String */ = "PLAYING";
        /// BUFFERING: player state of buffering. In this state streamer is loading data for playback and the play position is not moving.
        /// If the streamer was already playing video before entering this state, it continues to display the last displayed frame.
        /// @see GetPlayingState()
        if(_s == STAT_INIT) ConvivaStreamerProxy.BUFFERING /* : String */ = "BUFFERING";
        /// PAUSED: player state of paused. In this state the okay position is not moving.  If the streamer was playing video, it continues to display the last displayed frame.
        /// @see GetPlayingState()
        if(_s == STAT_INIT) ConvivaStreamerProxy.PAUSED /* : String */ = "PAUSED";
        /// <summary>
        /// NOT_MONITORED: The streamer is not currently attached to the monitor.
        /// @see GetPlayingState()
        /// </summary>
        if(_s == STAT_INIT) ConvivaStreamerProxy.NOT_MONITORED /* : String */ = "NOT_MONITORED";
        /// ERROR: player state of error
        /// @see GetPlayingState()
        if(_s == STAT_INIT) ConvivaStreamerProxy.ERROR /* : String */ = "ERROR";
        /// UNKNOWN: unknown player state
        /// @see GetPlayingState()
        if(_s == STAT_INIT) ConvivaStreamerProxy.UNKNOWN /* : String */ = "UNKNOWN";

        /// <summary>
        /// A state of the Downloader to  indicate that it is capable of downloading the stream.
        /// @see REASON_DOWNLOADSTATECHANGE
        /// </summary>
        if(_s == STAT_INIT) ConvivaStreamerProxy.DOWNLOADSTATE_ACTIVE /* : int */ = 1;

        /// <summary>
        /// A state of the Downloader to  indicate that it is not capable of downloading the stream.
        /// @see REASON_DOWNLOADSTATECHANGE
        /// </summary>
        if(_s == STAT_INIT) ConvivaStreamerProxy.DOWNLOADSTATE_INACTIVE /* : int */ = 0;

        // Constants for the required metadata keys
        /// <summary>
        /// METADATA_DURATION: The duration of the content, in seconds.
        ///
        /// Useful for communicating content duration when it becomes known after the start of streaming.
        /// </summary>
        if(_s == STAT_INIT) ConvivaStreamerProxy.METADATA_DURATION /* : String */ = "duration";
        /// METADATA_ENCODED_FRAMERATE: The encoded frame rate of the content, in frames per second.
        if(_s == STAT_INIT) ConvivaStreamerProxy.METADATA_ENCODED_FRAMERATE /* : String */ = "framerate";
        /// METADATA_STREAM_URL: The url of the content, being played
        if(_s == STAT_INIT) ConvivaStreamerProxy.METADATA_STREAM_URL /* : String */ = "streamUrl";

        /// <summary>
        /// Indicates a event need to be Enqueued.
        /// </summary>
        if(_s == STAT_INIT) ConvivaStreamerProxy.REASON_SEND_SEEK_EVENT /* : String */ = "SendSeekEvent";

        /** Constants for the valid switching statuses */
        /// <summary>
        /// The switch has not yet started.
        /// </summary>

        /// NO_LOADING_STATE: No loading state is available.
        //public const string NO_LOADING_STATE = "NO_LOADING_STATE";

        // Constants for boolean values that may also be unavailable
        if(_s == STAT_INIT) ConvivaStreamerProxy.BOOLEAN_TRUE /* : int */ = 1;
        if(_s == STAT_INIT) ConvivaStreamerProxy.BOOLEAN_FALSE /* : int */ = -1;
        if(_s == STAT_INIT) ConvivaStreamerProxy.BOOLEAN_UNAVAILABLE /* : int */ = 0;


        /// Constants for proxy Capabilities
        /// @see GetCapabilities()
        /// Constants for encoding the capabilities
        if(_s == STAT_INIT) ConvivaStreamerProxy.CAPABILITY_VIDEO /* : int */ = 1;
        if(_s == STAT_INIT) ConvivaStreamerProxy.CAPABILITY_QUALITY_METRICS /* : int */ = 2;
        if(_s == STAT_INIT) ConvivaStreamerProxy.CAPABILITY_BITRATE_METRICS /* : int */ = 4;

        /// constants for switching capabilities
        if(_s == STAT_INIT) ConvivaStreamerProxy.CAPABILITY_BITRATE_SWITCHING /* : int */ = 8;
        if(_s == STAT_INIT) ConvivaStreamerProxy.CAPABILITY_CDN_SWITCHING /* : int */ = 16;

        /// Bitrate is reported manually by the integration
        /// The conflict with CAPABILITY_CDN_SWITCHING is misleading
        /// CWS sends capabilities the backend, while LivePass only uses them on the client.
        /// While it doesn't look good, it should not create issues either.
        /// TODO: rethink/untangle these on the next major overhaul.
        if(_s == STAT_INIT) ConvivaStreamerProxy.CAPABILITY_BITRATE_EXTERNAL /* : int */ = 16;

        /// Constants for protocol capabilities
        if(_s == STAT_INIT) ConvivaStreamerProxy.CAPABILITY_SOURCE_HTTP /* : int */ = 32;
        if(_s == STAT_INIT) ConvivaStreamerProxy.CAPABILITY_SOURCE_CHUNKED /* : int */ = 64;
        if(_s == STAT_INIT) ConvivaStreamerProxy.CAPABILITY_SOURCE_STREAMING /* : int */ = 128;

        function _constr() {
            // Explicit constructor here for inheritance in Lua.

            // ALBAN: switching state away from UKNOWN without even having a streamer attached yet doesn't look right.
            // SetPlayingState(STOPPED);

        }

        /// <summary>
        /// Cleanup : This function is called when the monitoring session is terminated.
        /// </summary>
        defPubMeth(_s,"Cleanup",__Cleanup);
        function __Cleanup() /* : void */  {
            if (_s._notifiers != null) {
                _s._notifiers.Clear();
            }
        }

        /// <summary>
        /// GetCapabilities :
        /// Get a bitmap with the capabilities supported by this ConvivaStreamerProxy
        /// </summary>
        /// <returns></returns>
        defPubMeth(_s,"GetCapabilities",__GetCapabilities);
        function __GetCapabilities() /* : int */  {
            return 0;
        }


        /// <summary>
        /// GetPlayheadTimeMs
        /// The current position of the play head, in milliseconds since the start of the content.
        ///
        /// -1 if not available.
        ///
        /// </summary>
        defPubMeth(_s,"GetPlayheadTimeMs",__GetPlayheadTimeMs);
        function __GetPlayheadTimeMs() /* : int */  {
            return -1;
        }


        /// <summary>
        /// GetIsPHTAccurate
        /// @deprecated
        /// Return true if the Player head time is accurate, and false otherwise.
        ///
        /// </summary>
        defPubMeth(_s,"GetIsPHTAccurate",__GetIsPHTAccurate);
        function __GetIsPHTAccurate() /* : Boolean */  {
            return true;
        }


        /// <summary>
        /// GetBufferLengthMs
        ///
        /// The number of milliseconds-worth of data present in the buffer.
        ///
        /// -1 if not available.
        ///
        /// </summary>
        defPubMeth(_s,"GetBufferLengthMs",__GetBufferLengthMs);
        function __GetBufferLengthMs() /* : int */  {
            return -1;
        }


        /// <summary>
        /// GetVideoBufferLengthMs
        ///
        /// The number of milliseconds-worth of video data present in the buffer.
        ///
        /// -1 if not available.
        ///
        /// </summary>
        defPubMeth(_s,"GetVideoBufferLengthMs",__GetVideoBufferLengthMs);
        function __GetVideoBufferLengthMs() /* : int */  {
            return -1;
        }


        /// <summary>
        /// GetAudioBufferLengthMs
        ///
        /// The number of milliseconds-worth of audio data present in the buffer.
        ///
        /// -1 if not available.
        ///
        /// </summary>
        defPubMeth(_s,"GetAudioBufferLengthMs",__GetAudioBufferLengthMs);
        function __GetAudioBufferLengthMs() /* : int */  {
            return -1;
        }


        /// <summary>
        /// GetStartingBufferLengthMs :
        /// return the buffer length threshold (in milliseconds) at which the streamer will
        /// transition from buffering to playing.
        ///
        /// Most streamers do not begin playing immediately
        /// when data is available, but rather wait for the buffer to reach a certain threshold before
        /// playing, ensuring smoother playback. For example, if this number is 1000, and the streamer
        /// enters the buffering state with an empty buffer at time 0, the streamer will begin playing
        /// once the buffer is sufficient to play 1000ms of media.
        ///
        /// This threshold can change.
        ///
        /// -1 if unknown or unavailable.
        /// </summary>
        defPubMeth(_s,"GetStartingBufferLengthMs",__GetStartingBufferLengthMs);
        function __GetStartingBufferLengthMs() /* : int */  {
            return -1;
        }

        /// <summary>
        /// SetStartingBufferLengthMs:
        /// Sets the buffer length in ms.
        /// The maximum bufferlength which can be supported by a streamer varies.  Setters should verify that the setvalue of bufferlength has
        /// taken effect by calling GetStartingBufferLengthMs()
        /// </summary>
        /// <param name="ms"> bufferlength in ms</param>
        defPubMeth(_s,"SetStartingBufferLengthMs",__SetStartingBufferLengthMs);
        function __SetStartingBufferLengthMs(ms /* : int */) /* : void */  {

        }


        /// <summary>
        /// GetIsStartingBufferFull:
        /// Retruns true if the buffer length is large enough to transition from BUFFERING to PLAYING state
        /// </summary>
        /// <returns></returns>
        defPubMeth(_s,"GetIsStartingBufferFull",__GetIsStartingBufferFull);
        function __GetIsStartingBufferFull() /* : Boolean */  {
            return false;
        }


        /// <summary>
        /// GetRenderedFrameRate
        /// @deprecated
        ///
        /// The current rendering frame rate (frames per second).
        /// It is recommended that the rendering frame rate is based on a rolling average computed for the last 30 secs.
        ///
        /// -1.0 if not available.
        /// </summary>
        defPubMeth(_s,"GetRenderedFrameRate",__GetRenderedFrameRate);
        function __GetRenderedFrameRate() /* : Number */  {
            return -1.0;
        }

        /// <summary>
        /// GetSourceFrameRate
        ///
        /// The current encoded frame rate for the presented video stream (frames per second).
        ///
        /// -1.0 if not available.
        /// </summary>
        defPubMeth(_s,"GetSourceFrameRate",__GetSourceFrameRate);
        function __GetSourceFrameRate() /* : Number */  {
            return -1.0;
        }


        /// <summary>
        /// GetDroppedFrames
        /// The number of dropped frames, cumulative since the start of the session.
        ///
        /// -1 if not available.
        /// </summary>
        defPubMeth(_s,"GetDroppedFrames",__GetDroppedFrames);
        function __GetDroppedFrames() /* : int */  {
            return -1;
        }


        /// <summary>
        /// GetCpuPercent : return the percentage of CPU usage.
        /// -1.0 if not available.
        /// </summary>
        defPubMeth(_s,"GetCpuPercent",__GetCpuPercent);
        function __GetCpuPercent() /* : Number */  {
            return -1.0;
        }

        /// <summary>
        /// GetMemoryPercent : return the amount of memory available in KB
        /// @deprecated
        /// -1.0 if not available.
        /// </summary>
        defPubMeth(_s,"GetMemoryAvailable",__GetMemoryAvailable);
        function __GetMemoryAvailable() /* : Number */  {
            return -1.0;
        }

        /// <summary>
        /// GetCapacityKbps :
        /// return an estimation of the current capacity, in kilo-bits-per-second (i.e. 1000 bits per
        /// second), of the connection between this client and the specified resource.
        /// It is recommended that the estimation of the current capacity is calculated using a simple moving average of the bit rate for the last 2 downloaded chunks.
        ///
        /// -1 if not available.
        /// </summary>
        /// <param name="resource">Instance of Resource for which the bandwidth capacity is requested</param>
        defPubMeth(_s,"GetCapacityKbps",__GetCapacityKbps);
        function __GetCapacityKbps(resource /* : String */) /* : int */  {
            return -1;
        }


        /// <summary>
        /// GetServerAddress :
        ///
        /// Return the server address for the current playing resource. The returned string should be
        /// a representation of the IP address if available (e.g., "127.0.0.1"), or a domain name
        /// otherwise.
        ///
        /// Null if the server address is not known.
        /// </summary>
        defPubMeth(_s,"GetServerAddress",__GetServerAddress);
        function __GetServerAddress() /* : String */  {
            return null;
        }


        /// <summary>
        /// GetIsLive :
        /// @deprecated
        ///
        /// Return ConvivaStreamerProxy.BOOLEAN_TRUE if the streamer is streaming live media, and
        /// ConvivaStreamerProxy.BOOLEAN_FALSE otherwise.
        ///
        /// ConvivaStreamerProxy.BOOLEAN_UNAVAILABLE if unknown.
        /// </summary>
        defPubMeth(_s,"GetIsLive",__GetIsLive);
        function __GetIsLive() /* : int */  {
            return ConvivaStreamerProxy.BOOLEAN_UNAVAILABLE;
        }

        /// <summary>
        /// GetStreamerVersion :
        /// return a version number associated with the StreamerType above.
        ///
        /// At a minimum,
        /// this number should be changed whenever the streamer implementation changes in a
        /// way that could substantially impact switching.
        ///
        ///  -1 if the streamer type is null
        /// </summary>
        defPubMeth(_s,"GetStreamerVersion",__GetStreamerVersion);
        function __GetStreamerVersion() /* : int */  {
            return -1;
        }


        /// <summary>
        /// FetchCandidateStreams :
        /// This API will be supported on platforms where a return from GetCapabilities() has either the  ConvivaStreamerProxy.CAPABILITY_CDN_SWITCHING or the
        /// ConvivaStreamerProxy.CAPABILITY_BITRATE_SWITCHING bit fields set.

        /// An Async call to retrieve the  available tracks (bitrate variants) on a resource. The list of tracks are only for the current presentation.  For ex. if the
        /// current presentation includes Video_Angle1 & Audio_Eng then this API will retrieve the available bit-rate variants for Video_Angle1 & Audio_Eng.
        /// The bit-rate variants will be delivered to the async callback registered using the SetMonitoringNotifier()
        ///
        /// @see ConvivaStreamerProxy.SetMonitoringNotifier()
        /// @see ConvivaStreamerProxy.REASON_AVAILABLESTREAMINFOCHANGE
        /// </summary>
        /// <param name="resource"></param>
        defPubMeth(_s,"FetchCandidateStreams",__FetchCandidateStreams);
        function __FetchCandidateStreams(resource /* : String */) /* : void */  {

        }

        /// <summary>
        ///
        /// Play :
        /// This API will be supported on platforms where a return from GetCapabilities() has either the  ConvivaStreamerProxy.CAPABILITY_CDN_SWITCHING or the ConvivaStreamerProxy.CAPABILITY_BITRATE_SWITCHING bit fields set.
        ///
        /// Called by LivePass to indicate to the streamer that it should play the streams in the <paramref name="destination"/> list.  The destination object contains a list of streams
        /// which are part of the presentation that need to switched. The list of StreamInfo which are passed down to this function should contain atleast one stream corresponding
        /// to the Video stream.  All streams which are missing in this list will be mapped to the Video CDN.  For example  if the presentation is made up of Video_Angle1 & Audio_Eng and the
        /// call to Play() contains only the StreamInfo for the video stream, then the Audio_Eng stream will also be played from the same resource as the video.
        /// If the CSP is in the middle of downloading data when this function is called, then it is expected that the current download be canceled and a fresh download should be
        /// issued from the new <paramref name="destination"/>.
        ///
        /// A successful switch and display of the stream from the destination stream is signaled by the  ConvivaStreamerProxy.REASON_STREAMINFOCHANGE event.
        /// </summary>
        /// <impacts>
        /// Precision
        /// </impacts>
        defPubMeth(_s,"Play",__Play);
        function __Play(destination /* : ListCS(StreamInfo) */) /* : void */  {
        }



        /////////////////////////////////////////////////////////////////////////////////
        /// The following methods are not part of the API and are for Conviva internal
        /// use only.
        /////////////////////////////////////////////////////////////////////////////////

        /// The version of this class. This is for Conviva internal use only; do not modify or
        /// override it.
        defPubMeth(_s,"GetApiVersion",__GetApiVersion);
        function __GetApiVersion() /* : int */  {
            return ConvivaStreamerProxy.API_VERSION;
        }
        if(_s == STAT_INIT) ConvivaStreamerProxy.API_VERSION /* : int */ = 1;



        /// <summary>
        /// SetMonitoringNotifier :
        /// The Conviva LivePass will call this function to set a notifier. The notifier is a function that takes a string
        /// argument and an Object argument. The supported notifications are listed below. Each notification carries an encoding of the new state.
        /// The current (old) state can be read using the getters on this class (it has not yet been updated to the new value)
        ///
        /// When the notifier is set, if there are pending state changes or errors, the notifier is called immediately.
        ///
        /// - ConvivaStreamerProxy.REASON_PLAYINGSTATECHANGE - passed when the playing state changes. The Object argument is the new playing state (string).
        /// - ConvivaStreamerProxy.REASON_STREAMINFOCHANGE - passed when the StreamInfo changes (bitrate, resource, cdn). The Object argument is a List of
        ///                      StreamInfo.
        /// - ConvivaStreamerProxy.REASON_AVAILABLESTREAMINFOCHANGE -  passed when the list of available streams changes. The Object argument is List of StreamInfo.
        /// - ConvivaStreamerProxy.REASON_METADATACHANGE - passed when a new Metadata is encountered. The Object argument is a dictionary as described
        ///                   in the documentation of SetMetadata.
        /// - ConvivaStreamerProxy.REASON_DOWNLOADSTATECHANGE - passed when there is an update to the download status of a stream. The Object argument is a List<int>
        ///                   containing 2 items.The first item in the list being the stream type (StreamInfo.type) and the second being the state of the downloader;
        /// - ConvivaStreamerProxy.REASON_PROXYINITIALIZED - passed when the proxy has been initialized. The Object argument is null.
        /// - ConvivaStreamerProxy.REASON_LOADINGSTATUSCHANGE  - passed when updated status of the current download chunk is available.  The Object argument is the DownloadStatus
        /// - ConvivaStreamerProxy.REASON_DISPLAYSIZECHANGE - passed when display size changes. The object argument is a List<int> which contain the width and height in pixels.
        /// - ConvivaStreamerProxy.REASON_ERRORCHANGE - passed when a new error is encountered. The Object argument is the new StreamerError.
        /// - ConvivaStreamerProxy.REASON_LOG  - passed when the ConvivaStreamerProxy wants to log a string with the LivePassModule. The Object argument is the message to be logged (string).
        ///
        /// We use such an untyped interface because this class may be in a different module than the listener.
        /// </summary>
        /// <param name="notifier">the callback</param>
        defPubMeth(_s,"SetMonitoringNotifier",__SetMonitoringNotifier);
        function __SetMonitoringNotifier(notifier /* : Function(Action(String, object)) */) /* : void */  {

            if (notifier == null) return;

            var previousNotifiers /* : ListCS(Action(string, object)) */ = _s._notifiers;

            var newNotifiers /* : ListCS(Action(string, object)) */ = new ListCS/*Action(string, object)*/();
            newNotifiers.Add(notifier);
            _s._notifiers = newNotifiers;


            if (_s._notifiers != null) {
                // We trigger the notifications by setting the default values, and then replaying the
                // setters

                if (_s.isProxyInitialized) {
                    notifier(ConvivaStreamerProxy.REASON_PROXYINITIALIZED, null);
                }

                _s.SetDownloadStateChange(StreamInfo.VIDEO, ConvivaStreamerProxy.DOWNLOADSTATE_ACTIVE);
                _s.SetDownloadStateChange(StreamInfo.AUDIO, ConvivaStreamerProxy.DOWNLOADSTATE_ACTIVE);

                // We start with the stream info
                var newInfo /* : StreamInfo */ = _s._stream;
                _s._stream = new StreamInfo(-1, ConvivaContentInfo.CDN_NAME_OTHER, ConvivaContentInfo.NO_RESOURCE, -1, -1, -1);
                _s.SetStream(newInfo);

                // Shouldn't set the Previous Player State on AttachStreamer
                //var newState /* : String */ = _s._playingState;
                _s._playingState = ConvivaStreamerProxy.UNKNOWN;
                //_s.SetPlayingState(newState);
                _s.SetPlayingState(_s._playingState);
                // Need to reset to UNKNOWN by default and all the proxies should take care of Infer Logic

                //TODO: broken imo. If we picked up encoded framerate and then duration, _lastMetadata would only remember duration.
                // Shouldn't set the Previous Content Duration on AttachStreamer
                //var newMetadata /* : Object */ = _s._lastMetadata;
                //_s._lastMetadata = null;
                //_s.SetMetadata(newMetadata);

                // Now pass on all the pending errors, in the order in which we got them. This includes _lastError
                var _for_array_1 =  _s._pendingErrors.Values;
                for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
                  var strErr /* : StreamerError */ = _for_array_1[_for_idx_2];

                    _s.SetError(strErr);
                }

                var newStreams /* : ListCS(StreamInfo) */ = _s._availableStreams;
                _s._availableStreams = null;
                _s.SetAvailableStreams(newStreams);

                var newChunkDownloadStatus /* : DownloadStatus */ = (_s._currentLoadingStatus);
                _s._currentLoadingStatus = null;
                _s.SetLoadingStatus(newChunkDownloadStatus);

                var newDisplayWidth /* : int */ = _s._displayWidth;
                var newDisplayHeight /* : int */ = _s._displayHeight;
                _s._displayWidth = -1;
                _s._displayHeight = -1;
                _s.SetDisplaySize(newDisplayWidth, newDisplayHeight);
            }

            previousNotifiers.Add(notifier);
            _s._notifiers = previousNotifiers;
        }


        /// <summary>
        /// GetLoadingStatus :
        ///
        /// Return the ChunkDownloadStatus of the file which is currently being downloaded
        ///
        /// Returns NULL if chunk download is not in progress.
        ///
        /// </summary>

        defPubMeth(_s,"GetLoadingStatus",__GetLoadingStatus);
        function __GetLoadingStatus() /* : DownloadStatus */  {
            return _s._currentLoadingStatus;
        }




        /// <summary>
        /// GetPlayingState :
        /// return the current playing state. One of the playing state constants defined in ConvivaStreamerProxy
        ///
        /// UNKNOWN if unknown.
        /// </summary>
        defPubMeth(_s,"GetPlayingState",__GetPlayingState);
        function __GetPlayingState() /* : String */  {
            return _s._playingState;
        }


        /// <summary>
        /// GetBitrateKbps :
        /// return the bitrate of the currently-playing media (audio + video), in kilo-bits-per-second (i.e. 1000 bits per second).
        ///
        /// When this changes, the "StreamInfoChange" notifier should be called.
        ///
        /// -1 if not available.
        /// </summary>
        defPubMeth(_s,"GetBitrateKbps",__GetBitrateKbps);
        function __GetBitrateKbps() /* : int */  {
            return _s._stream.bitrateKbps;
        }

        /// <summary>
        /// GetCdnName :
        /// @deprecated
        /// return the current CDN name
        ///
        /// </summary>
        defPubMeth(_s,"GetCdnName",__GetCdnName);
        function __GetCdnName() /* : String */  {
            return _s._stream.cdnName;
        }



        /// <summary>
        /// GetResource :
        /// @deprecated
        /// return the current resource
        ///
        /// null if unknown.
        /// </summary>
        defPubMeth(_s,"GetResource",__GetResource);
        function __GetResource() /* : String */  {
            return _s._stream.resource;
        }




        /// <summary>
        /// The current Stream. Do not use this accessor across module boundaries. Use instead the
        /// GetBitrateKbps, GetCdnName, and GetResource because they return primitive types. You should not
        /// set directly fields of the returned StreamInfo.
        ///
        /// This method will return the primary component of the presentation.  eg if the presentation is composed of Video, audio and text, this API will
        /// return a stream corresponding to the video stream
        /// </summary>
        /// <returns></returns>
        defPubMeth(_s,"GetStream",__GetStream);
        function __GetStream() /* : StreamInfo */  {
            return _s._stream;
        }

        /// <summary>
        /// GetStreams :
        /// This method returns list of Streams which are part of the current presentation.
        /// </summary>
        /// <returns></returns>
        defPubMeth(_s,"GetStreams",__GetStreams);
        function __GetStreams() /* : ArrayCS(StreamInfo) */  {
            return null;
        }




        /// <summary>
        /// GetLastError :
        /// Return the last error, or null, if none
        /// </summary>
        /// <returns></returns>
        defPubMeth(_s,"GetLastError",__GetLastError);
        function __GetLastError() /* : StreamerError */  {
            return _s._lastError;
        }



        /// <summary>
        /// Get the last received metadata, or null if none
        /// </summary>
        /// <returns></returns>
        defPubMeth(_s,"GetLastMetadata",__GetLastMetadata);
        function __GetLastMetadata() /* : Object */  {
            return _s._lastMetadata;
        }





        /// <summary>
        /// GetDisplayWidth :
        /// </summary>
        /// <returns> Returns the last set display width in pixels</returns>
        defPubMeth(_s,"GetDisplayWidth",__GetDisplayWidth);
        function __GetDisplayWidth() /* : Object */  {
            return _s._displayWidth;
        }

        /// <summary>
        /// GetDisplayHeight :
        /// </summary>
        /// <returns> Returns the last set display height in pixels</returns>
        defPubMeth(_s,"GetDisplayHeight",__GetDisplayHeight);
        function __GetDisplayHeight() /* : Object */  {
            return _s._displayHeight;
        }



        /// <summary>
        /// GetStreamerType :
        /// return an identifier for the streamer this is proxying.
        ///
        /// This enables special
        /// switching logic that is particular to the streamer, if there is any. For
        /// example, a chunk-based streamer made by Conviva might identify itself here as
        /// "ConvivaChunkStreamer" so that LivePass can make switching decisions tailored for
        /// that particular streamer. The identifier should be negotatied with Conviva during
        /// integration.
        ///
        /// This should not change throughout the life of this ConvivaStreamerProxy.
        ///
        /// null if the streamer type is not known or does not need to be identified.
        /// </summary>
        defPubMeth(_s,"GetStreamerType",__GetStreamerType);
        function __GetStreamerType() /* : String */  {
            return null;
        }


        /// <summary>
        /// GetLoadedBytes :
        ///
        /// The number of bytes downloaded so far (cumulative, includes the bytes in the buffer) across all resources.
        /// If the upper layers are interested in the bytes loaded per resource, then it is expected to
        /// gather snapshots for every resource change events
        /// @see ConvivaStreamerProxy.REASON_STREAMINFOCHANGE
        /// Null if not available.
        /// </summary>
        defPubMeth(_s,"GetLoadedBytes",__GetLoadedBytes);
        function __GetLoadedBytes() /* : Number */  {
            return -1;
        }


        defPubMeth(_s,"SetDownloadStateChange",__SetDownloadStateChange);
        function __SetDownloadStateChange(type /* : int */, state /* : int */) /* : void */  {
            var downloadStateChange /* : ListCS(int) */ = new ListCS/*int*/();
            downloadStateChange.Add(type);
            downloadStateChange.Add(state);
            var _for_array_1 =  _s._notifiers.Values;
            for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
              var notifier /* : Function(Action(string, object)) */ = _for_array_1[_for_idx_2];

                _s.notifyListeners(notifier, ConvivaStreamerProxy.REASON_DOWNLOADSTATECHANGE, downloadStateChange);
            }
        }

        /// <summary>
        /// SetStream :
        /// @deprecated
        /// Set a new resource and bitrate switch. The updatedStream object only needs to
        /// contain the fields that are beings set. Use defaults for the other fields: -2 for bitrateKbps,
        /// and null for the cdnName and resource.
        /// </summary>
        /// <param name="updatedStream">the updated stream.</param>
        defPubMeth(_s,"SetStream",__SetStream);
        function __SetStream(updatedStream /* : StreamInfo */) /* : void */  {
            // Populate the defaults updatedStream
            if (updatedStream.bitrateKbps <= -2) updatedStream.bitrateKbps = _s._stream.bitrateKbps;
            if (updatedStream.cdnName == null) updatedStream.cdnName = _s._stream.cdnName;
            if (updatedStream.resource == null) updatedStream.resource = _s._stream.resource;
            if (!_s._stream.equals(updatedStream)) {
                var _for_array_1 =  _s._notifiers.Values;
                for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
                  var notifier /* : Function(Action(string, object)) */ = _for_array_1[_for_idx_2];

                    _s.notifyListeners(notifier, ConvivaStreamerProxy.REASON_STREAMINFOCHANGE, updatedStream);
                }
            }
            _s._stream = updatedStream;
        }

        /// <summary>
        /// SetError :
        /// @deprecated
        /// The streamer proxy should invoke this function whenever an error is encountered.
        ///
        /// For streamers that support Bitrate Switching or CDN Resource Switching, it is especially important to report as many errors
        /// as possible. In particular, any errors that might be resolved by a switch should be reported.
        /// </summary>
        /// <param name="error">An instance of Error must be passed into the callback.
        ///                     The Error instance should be created by calling one of the makeError_* function defined in Error.
        /// </param>
        defPubMeth(_s,"SetError",__SetError);
        function __SetError(error /* : StreamerError */) /* : void */  {

            _s._lastError = error;

            if (_s._notifiers != null && _s._notifiers.Count > 0) {
                var _for_array_1 =  _s._notifiers.Values;
                for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
                  var notifier /* : Function(Action(string, object)) */ = _for_array_1[_for_idx_2];

                    _s.notifyListeners(notifier, ConvivaStreamerProxy.REASON_ERRORCHANGE, error);
                }
            } else {
                _s._pendingErrors.Add(error);
            }
        }


        /// <summary>
        /// OnMetadata :
        /// @deprecated
        /// The streamer proxy should invoke the callback whenever metadata is received for the streaming content.
        ///
        /// The metadata object
        ///
        /// If the callback is called multiple times, the most recent value for each key will be used. For
        /// example, calling the callback first with { "duration":"100" } and immediately thereafter with
        /// { "framerate":"30" } is equivalent to calling it once with { "duration":"100", "framerate":"30" }.
        /// </summary>
        /// <param name="metadata"> A dictionary from metadata field names to metadata values.
        ///   The names of the valid keys are defined in ConvivaStreamerProxy as constants.
        ///   Other keys are ignored.
        /// </param>
        defPubMeth(_s,"SetMetadata",__SetMetadata);
        function __SetMetadata(metadata /* : Object */) /* : void */  {

            _s._lastMetadata = metadata;

            if (metadata != null) {
                var _for_array_1 =  _s._notifiers.Values;
                for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
                  var notifier /* : Function(Action(string, object)) */ = _for_array_1[_for_idx_2];

                    _s.notifyListeners(notifier, ConvivaStreamerProxy.REASON_METADATACHANGE, metadata);
                }
            }

        }



        /// <summary>
        /// @deprecated
        /// The ConvivaStreamerProxy can use this function to add a log message to Conviva LivePass.
        /// </summary>
        /// <param name="message"></param>
        defPubMeth(_s,"Log",__Log);
        function __Log(message /* : String */) /* : void */  {
            var _for_array_1 =  _s._notifiers.Values;
            for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
              var notifier /* : Function(Action(string, object)) */ = _for_array_1[_for_idx_2];

                _s.notifyListeners(notifier, ConvivaStreamerProxy.REASON_LOG, message);
            }

        }


        /// <summary>
        /// @deprecated
        /// The ConvivaStreamerProxy can use this function to add an error log message to Conviva LivePass.
        /// </summary>
        /// <param name="message"></param>
        defPubMeth(_s,"LogError",__LogError);
        function __LogError(message /* : String */) /* : void */  {
            var _for_array_1 =  _s._notifiers.Values;
            for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
              var notifier /* : Function(Action(string, object)) */ = _for_array_1[_for_idx_2];

                _s.notifyListeners(notifier, ConvivaStreamerProxy.REASON_LOG, "ERROR:" + message);
            }
        }


        //TODO: This feels that it is putting too much burden on the CSP implementor, to keep this much state.
        //      A simpler API that allows the CSP to return only bytes loaded since the last call, might be easier.
        //      An even simpler API where the CSP does not have to keep the data per-resource may be the only
        //      thing that is available.
        //
        /// <summary>
        /// @deprecated use GetLoadedBytes() instead
        /// GetTotalLoadedBytes
        ///
        /// The number of bytes downloaded so far (cumulative, includes the bytes in the buffer),
        /// per resource. The returned dictionary is indexed by resource name. Use a single
        /// entry with key NO_RESOURCE if the implementation does not use resources.
        ///
        /// Null if not available.
        /// </summary>
        defPubMeth(_s,"GetTotalLoadedBytes",__GetTotalLoadedBytes);
        function __GetTotalLoadedBytes() /* : DictionaryCS(string, double) */  {
            return null;
        }


        // --- end deprecated

        /// <summary>
        /// SetLoadingStatus :
        /// Should be called only by subclasses
        /// </summary>
        /// <param name="loadingStatus"></param>

        defPubMeth(_s,"SetLoadingStatus",__SetLoadingStatus);
        function __SetLoadingStatus(loadingStatus /* : DownloadStatus */) /* : void */  {
            _s._currentLoadingStatus = loadingStatus;
            if (loadingStatus != null) {
                var _for_array_1 =  _s._notifiers.Values;
                for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
                  var notifier /* : Function(Action(string, object)) */ = _for_array_1[_for_idx_2];

                    _s.notifyListeners(notifier, ConvivaStreamerProxy.REASON_LOADINGSTATUSCHANGE, loadingStatus);
                }
            }
        }

        /// <summary>
        /// SetPlayingState:
        /// set the current playing state. Should be used by ConvivaStreamerProxy to update the playing state
        /// and send a notification to LivePass.
        /// @see GetPlayingState()
        /// <param name="newState">the new state (one of the constants defined in ConvivaStreamerProxy)</param>
        /// </summary>
        defPubMeth(_s,"SetPlayingState",__SetPlayingState);
        function __SetPlayingState(newState /* : String */) /* : void */  {

            if (newState != _s._playingState) {
                var _for_array_1 =  _s._notifiers.Values;
                for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
                  var notifier /* : Function(Action(string, object)) */ = _for_array_1[_for_idx_2];

                    _s.notifyListeners(notifier, ConvivaStreamerProxy.REASON_PLAYINGSTATECHANGE, newState);
                }
            }
            _s._playingState = newState;
        }

        /// <summary>
        /// SetBitrateKbps :
        /// Set the new bitrate (in 1000 bits per second). Use this function when only the bitrate changes. If the cdnName, or the resource name
        /// also change, use SetStream instead.
        ///
        /// null if unknown.
        /// </summary>
        defPubMeth(_s,"SetBitrateKbps",__SetBitrateKbps);
        function __SetBitrateKbps(updatedBitrateKbps /* : int */) /* : void */  {
            var updatedStream /* : StreamInfo */ = new StreamInfo(updatedBitrateKbps, null, null, -1, -1, -1);
            _s.SetStream(updatedStream);
        }

        /// <summary>
        /// SetCdnName :
        /// @deprecated
        /// Set the new CDN name. Use this function when only the CDN name changes. If the bitrate, or the resource name
        /// also change, use SetStream instead.
        ///
        /// null if unknown.
        /// </summary>
        defPubMeth(_s,"SetCdnName",__SetCdnName);
        function __SetCdnName(updatedCdnName /* : String */) /* : void */  {
            var updatedStream /* : StreamInfo */ = new StreamInfo(-2, updatedCdnName, null, -1, -1, -1);
            _s.SetStream(updatedStream);
        }

        /// <summary>
        /// SetResource :
        /// @deprecated
        /// Set the new current resource. Use this function when only the resource changes. If the bitrate, or the CDN name
        /// also change, use SetStream instead.
        ///
        /// null if unknown.
        /// </summary>
        defPubMeth(_s,"SetResource",__SetResource);
        function __SetResource(updatedResource /* : String */) /* : void */  {
            var updatedStream /* : StreamInfo */ = new StreamInfo(-2, null, updatedResource, -1, -1, -1);
            _s.SetStream(updatedStream);
        }

        /// <summary>
        /// Streamer Proxy should invoke this API whenever the display size changes.
        ///
        /// </summary>
        /// <param name="displaySize">  An object which contains a List<int>, the first item being the width in pixels and the next item is the height in pixels</param>
        defPubMeth(_s,"SetDisplaySize",__SetDisplaySize);
        function __SetDisplaySize(displayWidth /* : int */, displayHeight /* : int */) /* : void */  {

            if (displayWidth != -1 && displayHeight != -1) {

                _s._displayWidth = displayWidth;
                _s._displayHeight = displayHeight;

                var displaySize /* DictionaryCS(String, int) */ = new DictionaryCS/* String, int */();
                displaySize.Add("width", displayWidth);
                displaySize.Add("height", displayHeight);
                var _for_array_1 =  _s._notifiers.Values;
                for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
                  var notifier /* : Function(Action(string, object)) */ = _for_array_1[_for_idx_2];

                    _s.notifyListeners(notifier, ConvivaStreamerProxy.REASON_DISPLAYSIZECHANGE, displaySize);
                }
            }
        }


        /// <summary>
        /// SetAvailableStreams :
        /// Streamer Proxy should invoke this API whenever a new set of tracks (bitrate variants) become available.
        ///
        /// </summary>
        /// <param name="streams"> A List of StreamInfo objects which contains the bitrate variants for each stream in the current presentation.</param>
        defPubMeth(_s,"SetAvailableStreams",__SetAvailableStreams);
        function __SetAvailableStreams(streams /* : ListCS(StreamInfo) */) /* : void */  {
            _s._availableStreams = streams;
            if (streams != null) {
                var _for_array_1 =  _s._notifiers.Values;
                for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
                  var notifier /* : Function(Action(string, object)) */ = _for_array_1[_for_idx_2];

                    _s.notifyListeners(notifier, ConvivaStreamerProxy.REASON_AVAILABLESTREAMINFOCHANGE, streams);
                }
            }
        }

        /// <summary>
        /// SendEvent:
        /// Send Seek Event. Should be used by ConvivaStreamerProxy to send Seek Event
        /// <param name="type"> Seek Action type pss/pse/bu/bd</param>
        /// <param name="pos"> Seek to Position value, if not available need to be set as -1 by default</param>
        /// </summary>
        defPubMeth(_s,"SendSeekEvent",__SendSeekEvent);
        function __SendSeekEvent(type /* : LivePass.SEEK_ACTIONS_TYPE */, pos /* : int */) /* : void */  {
            var eventAttributes /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
            eventAttributes.SetValue("act", type);
            if(pos >= 0) {
                eventAttributes.SetValue("skto", pos);
            }
            var _for_array_1 =  _s._notifiers.Values;
            for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
                var notifier /* : Function(Action(string, object)) */ = _for_array_1[_for_idx_2];
                _s.notifyListeners(notifier, ConvivaStreamerProxy.REASON_SEND_SEEK_EVENT, eventAttributes);
            }
        }

        /// <summary>
        /// SetProxyInitialized :
        /// Set the Proxy as initialized
        /// </summary>
        defPubMeth(_s,"SetProxyInitialized",__SetProxyInitialized);
        function __SetProxyInitialized() /* : void */  {
            if (!_s.isProxyInitialized) {
                _s.isProxyInitialized = true;
                var _for_array_1 =  _s._notifiers.Values;
                for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
                  var notifier /* : Function(Action(string, object)) */ = _for_array_1[_for_idx_2];

                    _s.notifyListeners(notifier, ConvivaStreamerProxy.REASON_PROXYINITIALIZED, null);
                }
            }
        }

        /// <summary>
        /// SetNetworkInfo :
        /// Set the network information if detected from proxy.
        /// properties can be null if unknown.
        /// </summary>
        defPubMeth(_s,"SetNetworkInfo",__SetNetworkInfo);
        function __SetNetworkInfo(networkInfo /* : NetworkInfo */) /* : void */  {
            var _for_array_1 =  _s._notifiers.Values;
            for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
                var notifier /* : Function(Action(string, object)) */ = _for_array_1[_for_idx_2];
                _s.notifyListeners(notifier, ConvivaStreamerProxy.REASON_NETWORKINFOCHANGE, networkInfo);
            }
        }

        defPrivMeth(_s,"notifyListeners",__notifyListeners);
        function __notifyListeners(notifier /* : Function(Action(string, object)) */, reason /* : String */, arg /* : Object */) /* : void */  {
            try {
                notifier(reason, arg);
            } catch(e /* : Error */) {
                notifier(ConvivaStreamerProxy.REASON_LOG, "ConvivaStreamerProxy : uncaught exception " + e);
            }
        }

       //JSRENAME:constant:_s:ConvivaStreamerProxy:API_VERSION
       //JSRENAME:constant:_s:ConvivaStreamerProxy:BOOLEAN_FALSE
       //JSRENAME:constant:_s:ConvivaStreamerProxy:BOOLEAN_TRUE
       //JSRENAME:constant:_s:ConvivaStreamerProxy:BOOLEAN_UNAVAILABLE
       //JSRENAME:constant:_s:ConvivaStreamerProxy:BUFFERING
       //JSRENAME:constant:_s:ConvivaStreamerProxy:CAPABILITY_BITRATE_EXTERNAL
       //JSRENAME:constant:_s:ConvivaStreamerProxy:CAPABILITY_BITRATE_METRICS
       //JSRENAME:constant:_s:ConvivaStreamerProxy:CAPABILITY_BITRATE_SWITCHING
       //JSRENAME:constant:_s:ConvivaStreamerProxy:CAPABILITY_CDN_SWITCHING
       //JSRENAME:constant:_s:ConvivaStreamerProxy:CAPABILITY_QUALITY_METRICS
       //JSRENAME:constant:_s:ConvivaStreamerProxy:CAPABILITY_SOURCE_CHUNKED
       //JSRENAME:constant:_s:ConvivaStreamerProxy:CAPABILITY_SOURCE_HTTP
       //JSRENAME:constant:_s:ConvivaStreamerProxy:CAPABILITY_SOURCE_STREAMING
       //JSRENAME:constant:_s:ConvivaStreamerProxy:CAPABILITY_VIDEO
       //JSRENAME:constant:_s:ConvivaStreamerProxy:DOWNLOADSTATE_ACTIVE
       //JSRENAME:constant:_s:ConvivaStreamerProxy:DOWNLOADSTATE_INACTIVE
       //JSRENAME:constant:_s:ConvivaStreamerProxy:ERROR
       //JSRENAME:constant:_s:ConvivaStreamerProxy:METADATA_DURATION
       //JSRENAME:constant:_s:ConvivaStreamerProxy:METADATA_ENCODED_FRAMERATE
       //JSRENAME:constant:_s:ConvivaStreamerProxy:NOT_MONITORED
       //JSRENAME:constant:_s:ConvivaStreamerProxy:PAUSED
       //JSRENAME:constant:_s:ConvivaStreamerProxy:PLAYING
       //JSRENAME:constant:_s:ConvivaStreamerProxy:REASON_AVAILABLESTREAMINFOCHANGE
       //JSRENAME:constant:_s:ConvivaStreamerProxy:REASON_DISPLAYSIZECHANGE
       //JSRENAME:constant:_s:ConvivaStreamerProxy:REASON_DOWNLOADSTATECHANGE
       //JSRENAME:constant:_s:ConvivaStreamerProxy:REASON_ERRORCHANGE
       //JSRENAME:constant:_s:ConvivaStreamerProxy:REASON_LOADINGSTATUSCHANGE
       //JSRENAME:constant:_s:ConvivaStreamerProxy:REASON_LOG
       //JSRENAME:constant:_s:ConvivaStreamerProxy:REASON_METADATACHANGE
       //JSRENAME:constant:_s:ConvivaStreamerProxy:REASON_PLAYINGSTATECHANGE
       //JSRENAME:constant:_s:ConvivaStreamerProxy:REASON_PRESENTATION_CHANGE
       //JSRENAME:constant:_s:ConvivaStreamerProxy:REASON_PROXYINITIALIZED
       //JSRENAME:constant:_s:ConvivaStreamerProxy:REASON_RESOURCE_ERROR
       //JSRENAME:constant:_s:ConvivaStreamerProxy:REASON_STREAMINFOCHANGE
       //JSRENAME:constant:_s:ConvivaStreamerProxy:STOPPED
       //JSRENAME:constant:_s:ConvivaStreamerProxy:UNKNOWN
       //JSRENAME:constant:_s:ConvivaStreamerProxy:REASON_SEND_SEEK_EVENT
        if(_s != STAT_INIT) _constr.apply(_s, arguments);
    }
statInit(ConvivaStreamerProxy,"ConvivaStreamerProxy");
    // API_EXIT

// DO NOT EDIT! THIS FILE WAS GENERATED BY Slash from ../csClient/CwsClient/LivePass.cs
// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-

// Copyright (c) 2011, 2012 Conviva Inc. All Rights Reserved.
// Author: George Necula (necula@conviva.com), Henry Milner (henry@conviva.com), Yan Li (yan@conviva.com)



// namespace

/// @mainpage
/// @author George Necula
/// @author Henry Milner
/// @author Saiguang Che
/// @author Ali Lakhia
/// @author Yan Li
///
/// The top level class for Application interaction with the Conviva client is LivePass.
///
/// The typical sequence of actions taken by the Application are:
/// <ol>
/// <li> Call LivePass.init () to pass some global parameters
/// <li> Optionally call LivePass.sendEvent() to send custom events not related to a particular session
/// <li> Call LivePass.createSession() to create a session tied to one viewing of a resource. The session should
///      be constructed as early as possible in order to compute an accurate join time. The following operations are
///      typical operations that can be performed on a session
///      <ul>
///      <li> LivePass.sendSessionEvent() to send a custom event for this session
///      <li> LivePass.cleanupSession() to destroy the session
///      </ul>
/// </ol>


    /// <summary>
    /// This is the top-level class for Application interaction with the Conviva CWS client.
    /// </summary>
function LivePass() {
    var _s = this;

    /// SEEK_ACTIONS_TYPE: action type of the event. This is to record the type of the SeekEvent we received.
    LivePass.SEEK_ACTIONS_TYPE = {
         SEEK_START  : "pss", // Player called SeekTo
         SEEK_END    : "pse", // player received SeekEnd
         BUTTON_UP   : "bu",  // User button up the position bar
         BUTTON_DOWN : "bd" };// User button down the position bar

    /// READY : LivePass state is ready for use.
    if(_s == STAT_INIT) LivePass.READY /* : String */ = "READY";


    ///STREAM_SELECTION_SUCC : return code for initial or midstream selection success
    if(_s == STAT_INIT) LivePass.STREAM_SELECTION_SUCC /* : int */ = 0;
    /// STREAM_SELECTION_FAILURE : return code for initial or midstream selection failure
    if(_s == STAT_INIT) LivePass.STREAM_SELECTION_FAILURE /* : int */ = 1;
    /// STREAM_SELECTION_TIMEOUT : return code for initial or midstream selection timeout
    if(_s == STAT_INIT) LivePass.STREAM_SELECTION_TIMEOUT /* : int */ = 2;

    /// Some situations require that bitrate be reported externally and
    /// internal bitrate reporting is ignored.
    /// See createSession() that allows passing in options dictionary
    if(_s == STAT_INIT) LivePass.OPTION_EXTERNAL_BITRATE_REPORTING /* : String */ = "externalBitrateReporting";

    /// state: is LivePass ready?
    if(_s == STAT_INIT) LivePass.readyState /* : Boolean */ = false;

    //@owner
    if(_s == STAT_INIT) LivePass._settings /* : Settings */ = null;

    //@owner
    if(_s == STAT_INIT) LivePass._utils /* : Utils */ = null;
    //@owner
    if(_s == STAT_INIT) LivePass._sessionFactory /* : SessionFactory */ = null;

    //flag indicating if toggleTraces is set in LivePass. Needed if the traces are toggled before LivePass is loaded
    if(_s == STAT_INIT) LivePass._toggleTracesUsed /* : Boolean */ = false;
    //the set value of toggleTraces
    if(_s == STAT_INIT) LivePass._toggleTracesValue /* : Boolean */ = false;

    // The id of the global session. -1 if not yet created.
    if(_s == STAT_INIT) LivePass._globalSessionId /* : int */ = -1;

    /// <summary>
    /// init : initialize the LivePass module
    ///
    /// see Conviva integration guide for details of how to use this method.
    /// </summary>
    /// <param name="customerKey">a key assigned by Conviva to uniquely identify a Conviva customer</param>
    defStatMeth(_s,LivePass,"init",__init);
    function __init(customerKey /* : String */) /* : void */  {
        if (LivePass.readyState) {
            LivePass._utils.log("LivePass.init(): already initialized.");
            return;
        }
        if (LivePass._utils == null) {
            // Retrieve, or create Utils object.
            // Needs to happen early to enable logging capabilities.
            LivePass._utils = Utils.CreateUtils(null);
        }
        if (customerKey == null || customerKey.length == 0) {
            LivePass._utils.err("LivePass.init(): invalid customerKey: " + customerKey);
            return;
        }
        LivePass._utils.runProtectedSync(
            function () {
                LivePass._settings = LivePass._utils.getSettings();
                // Alban: prevents conflicts when passing settings.enableLogging to initWithSettings
                if (LivePass._toggleTracesUsed) {
                    LivePass._settings.enableLogging = LivePass._toggleTracesValue;
                }

                // Gateways expect instanceId to be an unsigned int.
                LivePass._settings.clientInstanceId = LivePass._utils.randUInt();

                LivePass._settings.customerKey = customerKey;
                LivePass._utils.log("LivePass.init(): url=" + LivePass._settings.gatewayUrl + " customerKey=" + LivePass._settings.customerKey);
                LivePass._utils.startFetchClientId();
                PlayerStates.init();
                LivePass._sessionFactory = new SessionFactory();
                LivePass.readyState = true;
                LivePass._utils.log("LivePass.init(): done.");
                LivePass.networkInfo = new NetworkInfo();// Create network info instance to collect network information
             }, "LivePass.init");
    }


    /// <summary>
    /// initWithSettings : initialize LivePass, with advanced settings parameters.
    /// This function should be used only under guidance from Conviva.
    /// </summary>
    /// <param name="customerKey">a key assigned by Conviva to uniquely identify a Conviva customer </param>
    /// <param name="settings">a dictionary with string keys and object values</param>
    defStatMeth(_s,LivePass,"initWithSettings",__initWithSettings);
    function __initWithSettings(customerKey /* : String */, settings /* : Object */) /* : void */  {
        /* We prefer to bundle the settings with the init, to ensure that the settings take effect
         * as soon as possible, without possibility of interleaving other work between settings and init.
         */
        if (LivePass.readyState) {
            LivePass._utils.log("LivePass.initWithSettings(): already initialized.");
            return;
        }
        LivePass._utils = Utils.CreateUtils(settings); // update the settings
        LivePass.init(customerKey);
    }


    /// <summary>
    /// cleanup : method to clean up the LivePass when exiting.
    /// </summary>
    defStatMeth(_s,LivePass,"cleanup",__cleanup);
    function __cleanup() /* : void */  {
        if (LivePass._utils != null) {
            LivePass._utils.runProtected(
                function () {
                    LivePass._utils.log("LivePass.cleanup()");
                    if (LivePass._sessionFactory != null) {
                        LivePass._sessionFactory.cleanup(); // Cleans up all sessions, too.
                    }
                    LivePass._sessionFactory = null;
                    LivePass._globalSessionId  = -1;
                    if (LivePass._utils != null) {
                        LivePass._utils.cleanup();
                    }
                    LivePass._utils = null;
                    LivePass._settings = null;
                }, "LivePass.cleanup");
        }
        LivePass.readyState = false;
    }

    /// <summary>
    /// createSession : Create a monitoring session, without Conviva PreCision control.
    ///
    /// Please refer to Conviva integration guide for more details and examples.
    /// </summary>
    /// <param name="streamer"> a streamer or a ConvivaStreamerProxy object for this session</param>
    /// <param name="contentInfo"> the ConvivaContentInfo object used for this session</param>
    /// <param name="options"> an object specifying special options used for this session</param>
    defStatMeth(_s,LivePass,"createSession",__createSession);
    function __createSession(streamer /* : Object */, contentInfo /* : ConvivaContentInfo */, options /* : Object */) /* : int */  {
        if (!LivePass.readyState) {
            LivePass.ping("LivePass.createSession before LivePass.init");
            return -1;
        }
        return LivePass.createSessionWithGlobal(streamer, contentInfo, options, false, LivePass.networkInfo);
    }

    /// <summary>
    /// createSessionWithGlobal: Create a global or video monitoring session, without Conviva PreCision control.
    /// </summary>
    /// <param name="streamer"> a streamer or a ConvivaStreamerProxy object for this session</param>
    /// <param name="contentInfo"> the ConvivaContentInfo object used for this session</param>
    /// <param name="options"> an object specifying special options used for this session</param>
    /// <param name="global"> whether the session is global or not</param>
    /// <param name="networkInfo"> whether the session is global or not</param>
    defStatMeth(_s,LivePass,"createSessionWithGlobal",__createSessionWithGlobal);
    function __createSessionWithGlobal(streamer /* : Object */, contentInfo /* : ConvivaContentInfo */, options /* : Object */, global /* : Boolean */, networkInfo /* NetworkInfo */) /* : int */  {
        // We generate the session id outside runProtected because the latter may be asynchronous
        var sid /* : int */ = LivePass._sessionFactory.newSessionId();
        LivePass._utils.runProtected(
            function () {
                var session /* : Session */ = LivePass._sessionFactory.makeSession(streamer, contentInfo, options, sid, global, networkInfo);
            }, "LivePass.createSession");
        return sid;
    }

    /// <summary>
    /// reportError : manual error reporting
    /// </summary>
    /// <param name="sessionId">The session identifier</param>
    /// <param name="errorMsg">The error message to be reported to the backend</param>
    /// <param name="errorSeverity">The error severity to be reported to the backend</param>
    defStatMeth(_s,LivePass,"reportError",__reportError);
    function __reportError(sessionId /* : int */, errorMsg /* : String */, errorSeverity /* enum */) /* : void */  {
        if (!LivePass.readyState) {
            LivePass.ping("LivePass.reportError before LivePass.init");
            return;
        }
        if (errorSeverity === undefined) {  // Backward compatibility
          errorSeverity = StreamerError.SEVERITY_FATAL;
        }
        if (errorSeverity !== StreamerError.SEVERITY_FATAL &&
            errorSeverity !== StreamerError.SEVERITY_WARNING) {
            LivePass._utils.log("LivePass.reportError(): invalid errorSeverity parameter: " + errorSeverity);
            return;
        }
        LivePass._utils.runProtected(
            function () {
                var session /* : Session */ = LivePass._sessionFactory.getSession(sessionId);
                if (session != null) {
                    session.reportError(StreamerError.makeUnscopedError(errorMsg, errorSeverity));
                }
            }, "LivePass.reportError");
    }

    /// <summary>
    /// setBitrate : manual bitrate reporting
    ///
    /// To use this method, session should be created with the options parameter
    /// LivePass.OPTION_EXTERNAL_BITRATE_REPORTING set to true.
    /// </summary>
    /// <param name="sessionId">The session identifier</param>
    /// <param name="bitrateKbps">A positive value for the bitrate to be reported to the backend, in Kbps.</param>
    defStatMeth(_s,LivePass,"setBitrate",__setBitrate);
    function __setBitrate(sessionId /* : int */, bitrateKbps /* : int */) /* : void */  {
        if (!LivePass.readyState) {
            LivePass.ping("LivePass.setBitrate before LivePass.init");
            return;
        }
        LivePass._utils.runProtected(
            function () {
                var session /* : Session */ = LivePass._sessionFactory.getSession(sessionId);
                if (session != null) {
                    session.setBitrate(bitrateKbps);
                }
            }, "LivePass.setBitrate");
    }

    /// <summary>
    /// setCurrentStreamMetadata : Set various metadata parameters for the stream
    /// The metadata object should be a dictionary from metadata field names to metadata values (as strings).
    /// The names of the valid keys are defined in ConvivaStreamerProxy as constants:
    ///  - duration  (duration of the stream in seconds)
    ///  - framerate (encoded framerate)
    /// Other keys are ignored.
    ///
    /// If the callback is called multiple times, the most recent value for each key will be used. For
    /// example, calling the callback first with { "duration":"100" } and immediately thereafter with
    /// { "framerate":"30" } is equivalent to calling it once with { "duration":"100", "framerate":"30" }.
    /// </summary>
    /// <param name="sessionId">The session identifier</param>
    /// <param name="metadata">The new metadata</param>
    defStatMeth(_s,LivePass,"setCurrentStreamMetadata",__setCurrentStreamMetadata);
    function __setCurrentStreamMetadata(sessionId /* : int */, metadata /* : Object */) /* : void */  {
        if (!LivePass.readyState) {
            LivePass.ping("LivePass.setCurrentStreamMetadata before LivePass.init");
            return;
        }
        LivePass._utils.runProtected(
            function () {
                var session /* : Session */ = LivePass._sessionFactory.getSession(sessionId);
                if (session != null) {
                    session.setCurrentStreamMetadata(metadata);
                }
            }, "LivePass.setCurrentStreamMetadata");
    }

    /// <summary>
    /// setCdnNameOrResource : Set the cdnName/resource for the session
    /// </summary>
    /// <param name="sessionId">The session identifier</param>
    /// <param name="resource">The new resource</param>
    defStatMeth(_s,LivePass,"setCdnNameOrResource",__setCdnNameOrResource);
    function __setCdnNameOrResource(sessionId /* : int */, resource /* : String */) /* : void */  {
        if (!LivePass.readyState) {
            LivePass.ping("LivePass.setCdnNameOrResource before LivePass.init");
            return;
        }
        LivePass._utils.runProtected(
            function () {
                var session /* : Session */ = LivePass._sessionFactory.getSession(sessionId);
                if (session != null) {
                    session.setCdnNameOrResource(resource);
                }
            }, "LivePass.setCdnNameOrResource");
    }

    /// <summary>
    /// updateContentMetedata : Set the changed metadata items for the session
    /// </summary>
    /// <param name="sessionId">The session identifier</param>
    /// <param name="metadata">The new metadata JSON</param>
    defStatMeth(_s,LivePass,"updateContentMetadata",__updateContentMetadata);
    function __updateContentMetadata(sessionId /* : int */, metadata /* : Object */) /* : void */  {
        if (!LivePass.readyState) {
            LivePass.ping("LivePass.updateContentMetadata before LivePass.init");
            return;
        }
        LivePass._utils.runProtected(
            function () {
                var session /* : Session */ = LivePass._sessionFactory.getSession(sessionId);
                if (session != null) {
                    session.updateContentMetadata(metadata);
                }
            }, "LivePass.updateContentMetadata");
    }

    /// <summary>
    /// Pause session monitoring with specified id such that it can be resumed later
    /// Note: the existing streamer is detached from the session
    /// See resumeSession()
    /// </summary>
    /// <param name="sessionId">The session identifier</param>
    defStatMeth(_s,LivePass,"detachStreamer",__detachStreamer);
    function __detachStreamer(sessionId /* : int */) /* : void */  {
        if (!LivePass.readyState) {
            LivePass.ping("LivePass.detachStreamer before LivePass.init");
            return;
        }
        LivePass._utils.runProtected(
            function () {
                var session /* : Session */ = LivePass._sessionFactory.getSession(sessionId);
                if (session != null) {
                    session.detachStreamer();
                }
            }, "LivePass.detachStreamer");
    }

    /// <summary>
    /// Attach streamer to session identified by the session id
    /// See createSession()
    /// </summary>
    /// <param name="sessionId">The session identifier</param>
    /// <param name="streamer">The streamer to be attached to the session</param>
    defStatMeth(_s,LivePass,"attachStreamer",__attachStreamer);
    function __attachStreamer(sessionId /* : int */, streamer /* : Object */) /* : void */  {
        if (!LivePass.readyState) {
            LivePass.ping("LivePass.attachStreamer before LivePass.init");
            return;
        }
        LivePass._utils.runProtected(
            function () {
                var session /* : Session */ = LivePass._sessionFactory.getSession(sessionId);
                if (session != null) {
                    session.attachStreamer(streamer);
                }
            }, "LivePass.attachStreamer");
    }


    /// <summary>
    /// This function is used to send Conviva Player Insights Event, associated with a session.
    /// Events have a name and a list of key value pair as event attributes.
    ///
    /// </summary>
    /// <param name="sessionId"> returned by the createSession, createPrecisionSession </param>
    /// <param name="eventName"> a name for the event </param>
    /// <param name="eventAttributes"> a dictionary of key value pair associated with the event </param>
    defStatMeth(_s,LivePass,"sendSessionEvent",__sendSessionEvent);
    function __sendSessionEvent(sessionId /* : int */, eventName /* : String */, eventAttributes /* : Object */) /* : void */  {
        if (!LivePass.readyState) {
            LivePass.ping("LivePass.sendSessionEvent before LivePass.init");
            return;
        }
        var eventAttrDictCS /* : DictionaryCS(string, object) */ = null;
        eventAttrDictCS = Lang.DictionaryFromRepr/*string, string*/(eventAttributes);
        LivePass._utils.runProtected(
            function () {
                var session /* : Session */ = LivePass._sessionFactory.getSession(sessionId);
                if (session != null) {
                    session.sendCustomEvent(eventName, eventAttrDictCS);
                }
            }, "LivePass.sendSessionEvent");
    }


    /// <summary>
    /// This function is used to send Conviva Player Insights Event, not assocated with a video session
    /// Events have a name and a list of key value pair as event attributes.
    ///
    /// </summary>
    /// <param name="eventName"> a name for the event </param>
    /// <param name="eventAttributes"> a dictionary of key value pair associated with the event </param>
    defStatMeth(_s,LivePass,"sendEvent",__sendEvent);
    function __sendEvent(eventName /* : String */, eventAttributes /* : Object */) /* : void */  {

        if (!LivePass.readyState) {
            LivePass.ping("LivePass.sendEvent before LivePass.init");
            return;
        }
        LivePass._utils.runProtected(
            function () {
                // Have we created the global session already ?
                if (LivePass._globalSessionId < 0) {
                    var cci /* : ConvivaContentInfo */ = new ConvivaContentInfo("", new DictionaryCS/*<string,string>*/ ());
                    LivePass._globalSessionId = LivePass.createSessionWithGlobal(null, cci, null, true);
                }
                LivePass.sendSessionEvent(LivePass._globalSessionId, eventName, eventAttributes);
            }, "LivePass.sendEvent"
        );

    }

    /// <summary>
    /// This function is used to send Conviva Player the Seek Start Event associated with a video session
    ///
    /// </summary>
    /// <param name="sessionId"> id returned by the createSession </param>
    /// <param name="seekToPos"> Position to which seek is requested. If not available need to set to -1 </param>
    defStatMeth(_s,LivePass,"setPlayerSeekStart",__setPlayerSeekStart);
    function __setPlayerSeekStart(sessionId /* : int */, seekToPos /* : int */) /* : void */  {
        if(!LivePass.readyState) {
            LivePass.ping("LivePass.setPlayerSeekStart before LivePass.init");
            return;
        }
        LivePass._utils.runProtected(
            function() {
                var session = LivePass._sessionFactory.getSession(sessionId);
                if(session != null) {
                    session.sendSeekEvent(LivePass.SEEK_ACTIONS_TYPE.SEEK_START, seekToPos);
                }
             }, "LivePass.setPlayerSeekStart"
         );
    }

    /// <summary>
    /// This function is used to send Conviva Player the Seek End Event associated with a video session
    ///
    /// </summary>
    /// <param name="sessionId"> id returned by the createSession </param>
    defStatMeth(_s,LivePass,"setPlayerSeekEnd",__setPlayerSeekEnd);
    function __setPlayerSeekEnd(sessionId /* : int */) /* : void */  {
        if(!LivePass.readyState) {
            LivePass.ping("LivePass.setPlayerSeekEnd before LivePass.init");
            return;
        }
        LivePass._utils.runProtected(
            function() {
                var session = LivePass._sessionFactory.getSession(sessionId);
                if(session != null) {
                    session.sendSeekEvent(LivePass.SEEK_ACTIONS_TYPE.SEEK_END, -1);
                }
             }, "LivePass.setPlayerSeekEnd"
         );
    }

    /// <summary>
    /// This function is used to send Conviva Player the Button Up Event associated with a video session
    ///
    /// </summary>
    /// <param name="sessionId"> id returned by the createSession </param>
    defStatMeth(_s,LivePass,"setUserSeekButtonUp",__setUserSeekButtonUp);
    function __setUserSeekButtonUp(sessionId /* : int */) /* : void */  {
        if(!LivePass.readyState) {
            LivePass.ping("LivePass.setUserSeekButtonUp before LivePass.init");
            return;
        }
        LivePass._utils.runProtected(
            function(){
                var session = LivePass._sessionFactory.getSession(sessionId);
                if(session != null) {
                    session.sendSeekEvent(LivePass.SEEK_ACTIONS_TYPE.BUTTON_UP, -1);
                }
             }, "LivePass.setUserSeekButtonUp"
         );
    }

    /// <summary>
    /// This function is used to send Conviva Player the Button Down Event associated with a video session
    ///
    /// </summary>
    /// <param name="sessionId"> id returned by the createSession </param>
    defStatMeth(_s,LivePass,"setUserSeekButtonDown",__setUserSeekButtonDown);
    function __setUserSeekButtonDown(sessionId /* : int */) /* : void */  {
        if(!LivePass.readyState) {
            LivePass.ping("LivePass.setUserSeekButtonDown before LivePass.init");
            return;
        }
        LivePass._utils.runProtected(
            function() {
                var session = LivePass._sessionFactory.getSession(sessionId);
                if(session != null) {
                    session.sendSeekEvent(LivePass.SEEK_ACTIONS_TYPE.BUTTON_DOWN, -1);
                }
             }, "LivePass.setUserSeekButtonDown"
         );
    }

    /// <summary>
    /// cleanupSession : should be called when a video session is over and to be cleaned up.
    ///
    /// </summary>
    /// <param name="sessionId"> id returned by the createSession, createPrecisionSession </param>
    defStatMeth(_s,LivePass,"cleanupSession",__cleanupSession);
    function __cleanupSession(sessionId /* : int */) /* : void */  {
        if (!LivePass.readyState) {
            LivePass.ping("LivePass.cleanupSession before LivePass.init");
            return;
        }
        LivePass._utils.runProtected(
            function () {
                LivePass._sessionFactory.cleanupSession(sessionId);
            }, "Livepass.cleanupSession");
    }

    /// <summary>
    /// @deprecated: shouldn't be up to customer.
    /// Suspend the accumulation of join time. Use, e.g., when an ad is starting and the time should not
    /// be counted as part of the join time.
    /// </summary>
    /// <param name="sessionId">The session identifier</param>
    defStatMeth(_s,LivePass,"pauseJoinTime",__pauseJoinTime);
    function __pauseJoinTime(sessionId /* : int */) /* : void */  {
        if (!LivePass.readyState) {
            LivePass.ping("LivePass.pauseJoinTime before LivePass.init");
            return;
        }
        LivePass.adStart(sessionId);
    }

    /// <summary>
    /// @deprecated: shouldn't be up to customer.
    /// Resume the accumulation of join time.
    /// </summary>
    /// <param name="sessionId">The session identifier</param>
    defStatMeth(_s,LivePass,"resumeJoinTime",__resumeJoinTime);
    function __resumeJoinTime(sessionId /* : int */) /* : void */  {
        if (!LivePass.readyState) {
            LivePass.ping("LivePass.resumeJoinTime before LivePass.init");
            return;
        }
        LivePass.adEnd(sessionId);
    }

    /// <summary>
    /// Notifies our library that an ad is about to be played.
    /// </summary>
    /// <param name="sessionId">The session identifier</param>
    defStatMeth(_s,LivePass,"adStart",__adStart);
    function __adStart(sessionId /* : int */) /* : void */  {
        if (!LivePass.readyState) {
            LivePass.ping("LivePass.adStart before LivePass.init");
            return;
        }
        LivePass._utils.runProtected(
            function () {
                var session /* : Session */ = LivePass._sessionFactory.getSession(sessionId);
                if (session != null) {
                    session.adStart();
                }
            }, "LivePass.adStart");
    }

    /// <summary>
    /// Notifies our library that an ad is over.
    /// </summary>
    /// <param name="sessionId">The session identifier</param>
    defStatMeth(_s,LivePass,"adEnd",__adEnd);
    function __adEnd(sessionId /* : int */) /* : void */  {
        if (!LivePass.readyState) {
            LivePass.ping("LivePass.adEnd before LivePass.init");
            return;
        }
        LivePass._utils.runProtected(
            function () {
                var session /* : Session */ = LivePass._sessionFactory.getSession(sessionId);
                if (session != null) {
                    session.adEnd();
                }
            }, "LivePass.adEnd");
    }

    /// <summary>
    /// Toggle on/off console traces.
    /// </summary>
    /// <param name="b"> true if enble console trace. false otherwise </param>
    defStatMeth(_s,LivePass,"toggleTraces",__toggleTraces);
    function __toggleTraces(b /* : Boolean */) /* : void */  {
        // We cannot use _utils.runProtected because this function can be used before we LivePass.init
        // Fortunately, there is not much that can go wrong in this function, but be extra careful.
        LivePass._toggleTracesUsed = true;
        if (LivePass._settings != null) {
            LivePass._settings.enableLogging = b;
        } else {
            LivePass._toggleTracesValue = b;
        }
    }

    /// <summary>
    /// Set network connection type. Has to be used after initializing LivePass
    /// </summary>
    /// <param name="ct"> String </param>
    defStatMeth(_s,LivePass,"setConnectionType",__setConnectionType);
    function __setConnectionType(ct /* : String */) /* : void */  {
        if (LivePass.networkInfo != null) {
            LivePass.networkInfo.connectionType = ct;
            //Report change to monitor to raise statechangeevent
            LivePass._utils.runProtected(
            function () {
                var session /* : Session */ = LivePass._sessionFactory.getSession(LivePass._sessionFactory.lastSessionId);
                if (session != null) {
                    session.setConnectionType(ct);
                }
            }, "LivePass.setConnectionType");
        }
    }

    /// <summary>
    /// Set network SSID or friendly name. Has to be used after initializing LivePass
    /// </summary>
    /// <param name="ssid"> String </param>
    defStatMeth(_s,LivePass,"setSsid",__setSsid);
    function __setSsid(ssid /* : String */) /* : void */  {
        if (LivePass.networkInfo != null) {
            LivePass.networkInfo.ssid = ssid;
            //Report change to monitor to raise statechangeevent
            LivePass._utils.runProtected(
            function () {
                var session /* : Session */ = LivePass._sessionFactory.getSession(LivePass._sessionFactory.lastSessionId);
                if (session != null) {
                    session.setSsid(ssid);
                }
            }, "LivePass.setSsid");
        }
    }

    /// <summary>
    /// Set Signal Strength. Has to be used after initializing LivePass
    /// </summary>
    /// <param name="ss"> Double </param>
    defStatMeth(_s,LivePass,"setSignalStrength",__setSignalStrength);
    function __setSignalStrength(ss /* : double */) /* : void */  {
        if (LivePass.networkInfo != null) {
            LivePass.networkInfo.signalStrength = ss;
            //Report change to monitor to raise statechangeevent
            LivePass._utils.runProtected(
            function () {
                var session /* : Session */ = LivePass._sessionFactory.getSession(LivePass._sessionFactory.lastSessionId);
                if (session != null) {
                    session.setSignalStrength(ss);
                }
            }, "LivePass.setSignalStrength");
        }
    }

    /// <summary>
    /// Set network connection type. Has to be used after creating session
    /// </summary>
    /// <param name="le"> String </param>
    defStatMeth(_s,LivePass,"setLinkEncryption",__setLinkEncryption);
    function __setLinkEncryption(le /* : double */) /* : void */  {
        if (LivePass.networkInfo != null) {
            LivePass.networkInfo.linkEncryption = le;
            //Report change to monitor to raise statechangeevent
            LivePass._utils.runProtected(
            function () {
                var session /* : Session */ = LivePass._sessionFactory.getSession(LivePass._sessionFactory.lastSessionId);
                if (session != null) {
                    session.setLinkEncryption(le);
                }
            }, "LivePass.setLinkEncryption");
        }
    }

    /// <summary>
    /// Only send ping if the _utils object has been initialized.
    ///
    /// </summary>
    defStatMeth(_s,LivePass,"ping",__ping);
    function __ping(msg /* : String */) /* : void */  {
        if (LivePass._utils != null) {
            LivePass._utils.ping(msg);
        }
    }
       //JSRENAME:constant:_s:LivePass:OPTION_EXTERNAL_BITRATE_REPORTING
       //JSRENAME:constant:_s:LivePass:READY
       //JSRENAME:constant:_s:LivePass:STREAM_SELECTION_FAILURE
       //JSRENAME:constant:_s:LivePass:STREAM_SELECTION_SUCC
       //JSRENAME:constant:_s:LivePass:STREAM_SELECTION_TIMEOUT
}
statInit(LivePass,"LivePass");
// Copyright (c) 2017 Conviva Inc. All Rights Reserved.
// Author: Kedar Marsada (kmarsada@conviva.com)

///<summary>
/// Encapsulates all the information required to report network related metadata
/// Currently, browsers cannot provide these values. Collect from customer directly.
/// If available, fetch from monitor in constructor and populate.
///</summary>
function NetworkInfo() {
    var _s = this;
    ///////////////////////////////////////////////////////////////////////
    // Begin public fields
    ///////////////////////////////////////////////////////////////////////

    /// <summary>
    /// A string representing connection type
    /// Primary acceptable values: "802.11 a", "802.11b", "802.11n", "802.11g", "LTE" (band values), If not possible, then use secondary values
    /// Secondary acceptable values:Ethernet, Wifi, 2G, 3G, 4G, OTHER
    /// </summary>
    if(_s != STAT_INIT) _s.connectionType /* : String */ = undefined;

    /// <summary>
    /// A string representing Wi-fi SSID or Wi-fi network friendly name
    /// </summary>
    if(_s != STAT_INIT) _s.ssid /* : String */ = undefined;

    /// <summary>
    /// A double value representing network signal strength
    /// Signal strength is represented in -dBm format (0 to -100). This is the power ratio in decibels (dB) of the measured power referenced to one milliwatt
    /// </summary>
    if(_s != STAT_INIT) _s.signalStrength /* : double */ = 1.0;

    /// <summary>
    /// A string representing Link encryption support
    /// Wireless networks are designed to provide enhanced security using privacy profiles. This metadata item detects if such profile is available in the end-user's platform.
    /// Possible primary values - WEP, WEP2 etc.
    /// Possible secondary values - "Yes", "No"
    /// </summary>
    if(_s != STAT_INIT) _s.linkEncryption /* : String */ = undefined;

    ///////////////////////////////////////////////////////////////////////
    // End public fields
    ///////////////////////////////////////////////////////////////////////


    ///<summary>
    ///Create a new NetworkInfo for current device
    /// </summary>
    function _constr(ctype /* String */, ssid /* string */, ss /* double */, le /* String */) {
        _s.connectionType = ctype;
        _s.ssid = ssid;
        _s.linkEncryption = le;
        _s.signalStrength = ss;
    }

    defPubMeth(_s,"GetConnectionType",__GetConnectionType);
    function __GetConnectionType() /* : void */  {
        return _s.connectionType;
    }

    defPubMeth(_s,"GetSsid",__GetSsid);
    function __GetSsid() /* : void */  {
        return _s.ssid;
    }

    defPubMeth(_s,"GetSignalStrength",__GetSignalStrength);
    function __GetSignalStrength() /* : void */  {
        return _s.signalStrength;
    }

    defPubMeth(_s,"GetLinkEncryption",__GetLinkEncryption);
    function __GetLinkEncryption() /* : void */  {
        return _s.linkEncryption;
    }
    if(_s != STAT_INIT) _constr.apply(_s, arguments);
}
statInit(NetworkInfo,"NetworkInfo");// DO NOT EDIT! THIS FILE WAS GENERATED BY Slash from ../csClient/CwsClient/PlayerStates.cs
// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-


// namespace
    function PlayerStates() {
        var _s = this;
        // Expose the mapping from stateToInt, as a way to expose the set of states
        if(_s == STAT_INIT) PlayerStates.stateToInt /* : DictionaryCS(string, int) */ = null;

        if(_s == STAT_INIT) PlayerStates.intToState /* : DictionaryCS(int, string) */ = null;

        // ALBAN: This state is deprecated in CWS
        // However this code is shared with LivePass
        // So it will remain here for the time being
        if(_s == STAT_INIT) PlayerStates.UNINITIALIZED /* : String */ = "UNINITIALIZED";
        if(_s == STAT_INIT) PlayerStates.eUninitialized /* : int */ = 0;

        if(_s == STAT_INIT) PlayerStates.PLAYING /* : String */ = "PLAYING";
        if(_s == STAT_INIT) PlayerStates.ePlaying /* : int */ = 3;
        if(_s == STAT_INIT) PlayerStates.STOPPED /* : String */ = "STOPPED";
        if(_s == STAT_INIT) PlayerStates.eStopped /* : int */ = 1;
        if(_s == STAT_INIT) PlayerStates.PAUSED /* : String */ = "PAUSED";
        if(_s == STAT_INIT) PlayerStates.ePaused /* : int */ = 12;
        if(_s == STAT_INIT) PlayerStates.BUFFERING /* : String */ = "BUFFERING";
        if(_s == STAT_INIT) PlayerStates.eBuffering /* : int */ = 6;
        if(_s == STAT_INIT) PlayerStates.NOT_MONITORED /* : String */ = "NOT_MONITORED";
        if(_s == STAT_INIT) PlayerStates.eNotMonitored /* : int */ = 98;
        if(_s == STAT_INIT) PlayerStates.UNKNOWN /* : String */ = "UNKNOWN";
        if(_s == STAT_INIT) PlayerStates.eUnknown /* : int */ = 100;

        defStatMeth(_s,PlayerStates,"init",__init);
        function __init() /* : void */  {
            PlayerStates.stateToInt = new DictionaryCS/*<string, int>*/();
            PlayerStates.intToState = new DictionaryCS/*<int,string>*/ ();
            PlayerStates.stateToInt.SetValue(PlayerStates.UNINITIALIZED, PlayerStates.eUninitialized); PlayerStates.intToState.SetValue(PlayerStates.eUninitialized, PlayerStates.UNINITIALIZED);
            PlayerStates.stateToInt.SetValue(PlayerStates.PLAYING, PlayerStates.ePlaying); PlayerStates.intToState.SetValue(PlayerStates.ePlaying, PlayerStates.PLAYING);
            PlayerStates.stateToInt.SetValue(PlayerStates.STOPPED, PlayerStates.eStopped); PlayerStates.intToState.SetValue(PlayerStates.eStopped, PlayerStates.STOPPED);
            PlayerStates.stateToInt.SetValue(PlayerStates.PAUSED, PlayerStates.ePaused); PlayerStates.intToState.SetValue(PlayerStates.ePaused, PlayerStates.PAUSED);
            PlayerStates.stateToInt.SetValue(PlayerStates.BUFFERING, PlayerStates.eBuffering); PlayerStates.intToState.SetValue(PlayerStates.eBuffering, PlayerStates.BUFFERING);
            PlayerStates.stateToInt.SetValue(PlayerStates.NOT_MONITORED, PlayerStates.eNotMonitored); PlayerStates.intToState.SetValue(PlayerStates.eNotMonitored, PlayerStates.NOT_MONITORED);
            PlayerStates.stateToInt.SetValue(PlayerStates.UNKNOWN, PlayerStates.eUnknown); PlayerStates.intToState.SetValue(PlayerStates.eUnknown, PlayerStates.UNKNOWN);
        }

        defStatMeth(_s,PlayerStates,"stringToInt",__stringToInt);
        function __stringToInt(stateStr /* : String */) /* : int */  {
            if (PlayerStates.stateToInt == null) {
                PlayerStates.init();
            }
            if (PlayerStates.stateToInt.ContainsKey(stateStr)) {
                return PlayerStates.stateToInt.GetValue(stateStr);
            } else {
                return PlayerStates.eUnknown;
            }
        }

        defStatMeth(_s,PlayerStates,"intToString",__intToString);
        function __intToString(stateInt /* : int */) /* : String */  {
            if (PlayerStates.intToState == null) {
                PlayerStates.init();
            }
            if (PlayerStates.intToState.ContainsKey(stateInt)) {
                return PlayerStates.intToState.GetValue(stateInt);
            } else {
                return PlayerStates.UNKNOWN;
            }
        }

        defStatMeth(_s,PlayerStates,"cleanup",__cleanup);
        function __cleanup() /* : void */  {
            PlayerStates.stateToInt = null;
        }
       //JSRENAME:constant:_s:PlayerStates:BUFFERING
       //JSRENAME:constant:_s:PlayerStates:NOT_MONITORED
       //JSRENAME:constant:_s:PlayerStates:PAUSED
       //JSRENAME:constant:_s:PlayerStates:PLAYING
       //JSRENAME:constant:_s:PlayerStates:STOPPED
       //JSRENAME:constant:_s:PlayerStates:UNINITIALIZED
       //JSRENAME:constant:_s:PlayerStates:UNKNOWN
       //JSRENAME:constant:_s:PlayerStates:eBuffering
       //JSRENAME:constant:_s:PlayerStates:eNotMonitored
       //JSRENAME:constant:_s:PlayerStates:ePaused
       //JSRENAME:constant:_s:PlayerStates:ePlaying
       //JSRENAME:constant:_s:PlayerStates:eStopped
       //JSRENAME:constant:_s:PlayerStates:eUninitialized
       //JSRENAME:constant:_s:PlayerStates:eUnknown
    }
statInit(PlayerStates,"PlayerStates");

// DO NOT EDIT! THIS FILE WAS GENERATED BY Slash from ../csClient/CwsClient/StreamInfo.cs
// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-

// Copyright (c) 2011, 2012 Conviva Inc. All Rights Reserved.
// Author: George Necula (necula@conviva.com), Henry Milner (henry@conviva.com), Yan Li (yan@conviva.com)

// NOTE: This class is shared between the CWS client and the LivePass client



// namespace
    // API_ENTER

    /// <summary>
    /// A stream to which a ConvivaStreamerProxy can potentially switch.
    /// This object contains no information about the actual URL of the stream it represents.
    /// </summary>
    function StreamInfo() {
        var _s = this;

        /// <summary>
        /// Construct a stream having bitrate <paramref name="bitrate"/> in kilo-bits-per-second and streaming
        /// from a resource named <paramref name="resource"/>.

        /// Stream Types
        /// Undetected stream type
        if(_s == STAT_INIT) StreamInfo.UNKNOWN /* : int */ = -1;

        /// Stream type Audio
        if(_s == STAT_INIT) StreamInfo.AUDIO /* : int */ = 0;

        /// Stream type Video
        if(_s == STAT_INIT) StreamInfo.VIDEO /* : int */ = 1;

        /// Stream type Text
        if(_s == STAT_INIT) StreamInfo.TEXT /* : int */ = 2;

        /// Stream type resource
        if(_s == STAT_INIT) StreamInfo.RESOURCE /* : int */ = 3;

        /// <summary>
        /// Unknown resource string.
        /// </summary>
        if(_s == STAT_INIT) StreamInfo.UNKNOWN_RESOURCE /* : String */ = "";

        /// <summary>
        /// A large value standing for no bit-rate cap
        /// </summary>
        if(_s == STAT_INIT) StreamInfo.MAX_BITRATE /* : int */ = 2147483647; // Int32.MaxValue

        /// TODO Manifest
        /// <summary>
        /// Stream type (eg. StreamInfo::AUDIO, StreamInfo::VIDEO, StreamInfo::TEXT or StreamInfo::RESOURCE)
        /// UNKNOWN if this info is unavailable.
        ///
        /// </summary>
// Use accessors to allow the obfuscator to keep an unobfuscated version
        if(_s != STAT_INIT) _s.__auto_type /* : int */ = undefined;
        defGet(_s,"type",__get_type);
        function __get_type()  { return _s.__auto_type; }
        defSet(_s,"type",__set_type);
        function __set_type(value /* : int */)  { _s.__auto_type = value; }

        /// <summary>
        /// Specifies the display height in pixels. -1 if this info is unavailable.
        ///
        /// </summary>

        if(_s != STAT_INIT) _s.__auto_sourceHeightPixels /* : int */ = undefined;
        defGet(_s,"sourceHeightPixels",__get_sourceHeightPixels);
        function __get_sourceHeightPixels()  { return _s.__auto_sourceHeightPixels; }
        defSet(_s,"sourceHeightPixels",__set_sourceHeightPixels);
        function __set_sourceHeightPixels(value /* : int */)  { _s.__auto_sourceHeightPixels = value; }

        /// <summary>
        /// Specifies the display width in pixels. -1 if this info is unavailable.
        ///
        /// </summary>

        if(_s != STAT_INIT) _s.__auto_sourceWidthPixels /* : int */ = undefined;
        defGet(_s,"sourceWidthPixels",__get_sourceWidthPixels);
        function __get_sourceWidthPixels()  { return _s.__auto_sourceWidthPixels; }
        defSet(_s,"sourceWidthPixels",__set_sourceWidthPixels);
        function __set_sourceWidthPixels(value /* : int */)  { _s.__auto_sourceWidthPixels = value; }

        /// <summary>
        /// The bitrate of the stream, in kilo-bits-per-second, or 1000 bits per second.
        /// -1 if the bitrate of this stream is unknown.
        ///
        /// </summary>

        if(_s != STAT_INIT) _s.__auto_bitrateKbps /* : int */ = undefined;
        defGet(_s,"bitrateKbps",__get_bitrateKbps);
        function __get_bitrateKbps()  { return _s.__auto_bitrateKbps; }
        defSet(_s,"bitrateKbps",__set_bitrateKbps);
        function __set_bitrateKbps(value /* : int */)  { _s.__auto_bitrateKbps = value; }

        /// <summary>
        /// The name of the resource from which this stream is loaded. For example, this could be the name of a CDN.
        /// Use null if the resource of this stream is unknown or irrelevant
        ///
        /// </summary>

        if(_s != STAT_INIT) _s.__auto_resource /* : String */ = undefined;
        defGet(_s,"resource",__get_resource);
        function __get_resource()  { return _s.__auto_resource; }
        defSet(_s,"resource",__set_resource);
        function __set_resource(value /* : String */)  { _s.__auto_resource = value; }

        /// <summary>
        /// The name of the CDN on which the resource exists.
        /// Use null if the CDN is unknown
        ///
        /// </summary>

        if(_s != STAT_INIT) _s.__auto_cdnName /* : String */ = undefined;
        defGet(_s,"cdnName",__get_cdnName);
        function __get_cdnName()  { return _s.__auto_cdnName; }
        defSet(_s,"cdnName",__set_cdnName);
        function __set_cdnName(value /* : String */)  { _s.__auto_cdnName = value; }

        /// </summary>
        /// <param name="_bitrateKbps">The bitrate of the stream, in kilo-bits-per-second, or 1000 bits per second. Pass -1 if the bitrate of this stream is unknown or irrelevant.</param>
        /// <param name="_cdnName">The name of the CDN from which the resource is loaded. Pass null if the CDN is unknown</param>
        /// <param name="_resource">The name of the resource from which this stream is loaded. Pass null if the resource of this stream is unknown or irrelevant.</param>
        /// <param name="type"> Stream type (eg. StreamInfo::AUDIO, StreamInfo::VIDEO, StreamInfo::TEXT or StreamInfo::RESOURCE)</param>
        /// <param name="widthPixels">Specifies the display width in pixels. Pass -1 if this info is unavailable</param>
        /// <param name="heightPixels">Specifies the display height in pixels. Pass -1 if this info is unavailable</param>
        function _constr(_bitrateKbps /* : int */, _cdnName /* : String */, _resource /* : String */, type /* : int */, widthPixels /* : int */, heightPixels /* : int */) {
            _s.bitrateKbps = _bitrateKbps;
            _s.cdnName = _cdnName;
            _s.resource = _resource;
            _s.type = type;
            _s.sourceHeightPixels = heightPixels;
            _s.sourceWidthPixels = widthPixels;
        }

        /// Returns the bitrate of the stream, in 1000 bits per second; -1 if unknown
        defPubMeth(_s,"GetBitrateKbps",__GetBitrateKbps);
        function __GetBitrateKbps() /* : int */  {
            return _s.bitrateKbps;
        }

        /// Returns the CDN name
        defPubMeth(_s,"GetCdnName",__GetCdnName);
        function __GetCdnName() /* : String */  {
            return _s.cdnName;
        }

        /// The resource from which the stream is loaded. null if unknown
        defPubMeth(_s,"GetResource",__GetResource);
        function __GetResource() /* : String */  {
            return _s.resource;
        }

        defPubMeth(_s,"equals",__equals);
        function __equals(other /* : StreamInfo */) /* : Boolean */  {
            if (other == null) return false;

            return _s.cdnName == other.cdnName && _s.resource == other.resource && _s.bitrateKbps == other.bitrateKbps && _s.type == other.type
                && _s.sourceHeightPixels == other.sourceHeightPixels && _s.sourceWidthPixels == other.sourceWidthPixels;
        }


        /**
         * Construct clone of the proper type, from a similar object perhaps constructed
         * in another module. We copy fields one by one
         */
        defStatMeth(_s,StreamInfo,"ConstructClone",__ConstructClone);
        function __ConstructClone(fromObj /* : Object */) /* : StreamInfo */  {
            if (fromObj == null) return null;
            var res /* : StreamInfo */ = new StreamInfo(-1, ConvivaContentInfo.CDN_NAME_OTHER, null, -1, -1, -1);
            res.type = slint.Cast(NativeLang.GetField("type", fromObj));
            res.bitrateKbps = slint.Cast(NativeLang.GetField("bitrateKbps", fromObj));
            res.resource = NativeLang.GetStringField("resource", fromObj);
            res.cdnName = NativeLang.GetStringField("cdnName", fromObj);
            res.sourceHeightPixels = slint.Cast(NativeLang.GetField("sourceHeightPixels", fromObj));
            res.sourceWidthPixels = slint.Cast(NativeLang.GetField("sourceWidthPixels", fromObj));
            return res;
        }

        defPubMeth(_s,"ToStr",__ToStr);
        function __ToStr() /* : String */  {
            var typeString /* : String */ = null;

            switch (_s.type) {
                case StreamInfo.UNKNOWN:
                    typeString = "UNKNOWN";
                    break;
                case StreamInfo.VIDEO:
                    typeString = "VIDEO";
                    break;
                case StreamInfo.AUDIO:
                    typeString = "AUDIO";
                    break;
                case StreamInfo.TEXT:
                    typeString = "TEXT";
                    break;
                case StreamInfo.RESOURCE:
                    typeString = "RESOURCE";
                    break;
                default:
                    throw new Error("Unknown stream type " + _s.type);
            }

            return "type=" + typeString +
                ", bitrateKbps=" + _s.bitrateKbps +
                ", resource=" + (_s.resource != null ? _s.resource : "null") +
                ", cdnName=" + (_s.cdnName != null ? _s.cdnName : "null") +
                ", sourceHeightPixels=" + _s.sourceHeightPixels +
                ", sourceWidthPixels=" + _s.sourceWidthPixels;
        }
       //JSRENAME:constant:_s:StreamInfo:AUDIO
       //JSRENAME:constant:_s:StreamInfo:MAX_BITRATE
       //JSRENAME:constant:_s:StreamInfo:RESOURCE
       //JSRENAME:constant:_s:StreamInfo:TEXT
       //JSRENAME:constant:_s:StreamInfo:UNKNOWN
       //JSRENAME:constant:_s:StreamInfo:UNKNOWN_RESOURCE
       //JSRENAME:constant:_s:StreamInfo:VIDEO
        if(_s != STAT_INIT) _constr.apply(_s, arguments);
    }
statInit(StreamInfo,"StreamInfo");
    // API_EXIT

// DO NOT EDIT! THIS FILE WAS GENERATED BY Slash from ../csClient/CwsClient/StreamSwitch.cs
// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-

// Copyright (c) 2011, Conviva Inc. All Rights Reserved.
// Author: Henry Milner (henry@conviva.com)



// namespace
    // API_ENTER
    /// <summary>
    /// A switch between media streams performed by a ConvivaStreamerProxy. A StreamSwitch contains
    /// instructions about the target and source streams for the switch and the way in which the
    /// switch should be executed. It also contains the current status of the switch.
    ///
    /// StreamSwitch's Status property indicates whether the stream is in progress, or has finished
    /// already and is in a terminal state, or has not started yet.
    ///
    /// This class has no externally-available public constructor. To create a StreamSwitch, use
    /// one of the static factory methods below. For Insights-only streamers, use MakeSwitchToStream.
    /// For streamers that support DMS or EMS, it is necessary to use the richer MakeSwitch instead.
    /// </summary>
    function StreamSwitch() {
        var _s = this;

        if(_s == STAT_INIT) StreamSwitch._nextId /* : int */ = 0;


        /** Constants for the valid switching statuses */
        /// <summary>
        /// The switch has not yet started.
        /// </summary>
        if(_s == STAT_INIT) StreamSwitch.PENDING /* : String */ = "PENDING";
        /// <summary>
        /// The switch has started but has not completed.
        /// </summary>
        if(_s == STAT_INIT) StreamSwitch.IN_PROGRESS /* : String */ = "IN_PROGRESS";
        /// <summary>
        /// The switch has completed successfully. The user has begun to get media from
        /// the target stream.
        /// </summary>
        if(_s == STAT_INIT) StreamSwitch.SUCCEEDED /* : String */ = "SUCCEEDED";
        /// <summary>
        /// The switch failed due to an error. The original stream is still in use.
        /// </summary>
        if(_s == STAT_INIT) StreamSwitch.FAILED /* : String */ = "FAILED";
        /// <summary>
        /// During the switch, user action caused the switch to be aborted, but no error
        /// occurred. The original stream is still in use.
        /// </summary>
        if(_s == STAT_INIT) StreamSwitch.INTERRUPTED /* : String */ = "INTERRUPTED";

        /// <summary>
        /// Return a switch from <paramref name="source"/> to <paramref name="target"/> with current status <paramref name="status"/>.
        ///
        /// Use this method to construct a StreamSwitch for a streamer that supports EMS or DMS.  For example,
        /// to create a representation of a switch that has just begun from sourceStream to targetStream, use:
        ///     MakeSwitch(sourceStream, targetStream, StreamSwitch.IN_PROGRESS)
        /// </summary>
        defStatMeth(_s,StreamSwitch,"MakeSwitch",__MakeSwitch);
        function __MakeSwitch(source /* : CandidateStream */, target /* : CandidateStream */, status /* : String */) /* : StreamSwitch */  {
            return new StreamSwitch(StreamSwitch.GetNextId(false), source, target, -1, null, status);
        }

        /// <summary>
        /// Return a switch to <paramref name="target"/> with current status <paramref name="status"/>.
        ///
        /// Use this method to construct a StreamSwitch when declaring a resource or bitrate change on an
        /// Insights-only streamer via the callback set by ConvivaStreamerProxy.SetSwitchingStatusChangeCallback().
        ///
        /// For example, to construct a StreamSwitch for declaring a resource change to a resource called
        /// newResource, and a bitrate newBitrate, construct a CandidateStream newStream representing the
        /// stream using newResource and newBitrate, then pass newStream to this method:
        ///     StreamSwitch.MakeSwitchToStream(newStream, StreamSwitch.SUCCEEDED);
        /// To declare that this switch has occurred, pass the resulting StreamSwitch to the ConvivaStreamerProxy
        /// callback.
        /// </summary>
        defStatMeth(_s,StreamSwitch,"MakeSwitchToStream",__MakeSwitchToStream);
        function __MakeSwitchToStream(target /* : CandidateStream */, status /* : String */) /* : StreamSwitch */  {
            return new StreamSwitch(StreamSwitch.GetNextId(false), null, target, -1, null, status);
        }

        /// <summary>
        /// Destroy this object.
        /// </summary>
        defPubMeth(_s,"Cleanup",__Cleanup);
        function __Cleanup() /* : void */  {
        }

        /// <summary>
        /// A unique identifier for this switch. Users should never provide their
        /// own IDs; factory methods for this class create IDs that are guaranteed
        /// to be unique.
        /// This cannot be null.
        /// </summary>
        /// <read-only/>
// Use accessors to allow the obfuscator to keep an unobfuscated version
        if(_s != STAT_INIT) _s.__auto_id /* : String */ = undefined;
        defGet(_s,"id",__get_id);
        function __get_id()  { return _s.__auto_id; }
        defSet(_s,"id",__set_id);
        function __set_id(value /* : String */)  { _s.__auto_id = value; }

        /// <summary>
        /// This switch must finish within TimeoutMs of its start. After that time,
        /// if the switch has not succeeded, it should be declared a failure and
        /// streaming should resume from the previous stream.
        /// -1 if no timeout is specified.
        /// </summary>
        /// <read-only/>

        if(_s != STAT_INIT) _s.__auto_timeoutMs /* : int */ = undefined;
        defGet(_s,"timeoutMs",__get_timeoutMs);
        function __get_timeoutMs()  { return _s.__auto_timeoutMs; }
        defSet(_s,"timeoutMs",__set_timeoutMs);
        function __set_timeoutMs(value /* : int */)  { _s.__auto_timeoutMs = value; }


        /// <summary>
        /// The stream in use before this switch.  If null, or if any field of the
        /// SourceStream is null, the source will be inferred from the current state
        /// of the streamer on which the switch is occurring.
        /// </summary>

        if(_s != STAT_INIT) _s.__auto_sourceStream /* : CandidateStream */ = undefined;
        defGet(_s,"sourceStream",__get_sourceStream);
        function __get_sourceStream()  { return _s.__auto_sourceStream; }
        defSet(_s,"sourceStream",__set_sourceStream);
        function __set_sourceStream(value /* : CandidateStream */)  { _s.__auto_sourceStream = value; }



        /// <summary>
        /// The target stream for this switch.
        /// Its Bitrate field must be valid if this switch causes a bitrate change.
        /// Otherwise, it is assumed that the target bitrate is the current bitrate of
        /// the stream on which the switch is occurring. Similarly so for the Resource
        /// field: it must be valid if this switch causes a resource change, and otherwise
        /// it is assumed that the target resource is the current resource.
        ///
        /// Must be non-null.
        /// </summary>
        /// <read-only/>

        if(_s != STAT_INIT) _s.__auto_targetStream /* : CandidateStream */ = undefined;
        defGet(_s,"targetStream",__get_targetStream);
        function __get_targetStream()  { return _s.__auto_targetStream; }
        defSet(_s,"targetStream",__set_targetStream);
        function __set_targetStream(value /* : CandidateStream */)  { _s.__auto_targetStream = value; }

        /// <summary>
        /// An identifier for a special way in which this switch should be executed.
        /// For example, "QuickSwitch" might indicate that a switch should be executed
        /// as quickly as possible, even if it causes a quality interruption.
        ///
        /// Modes must be negotiated with Conviva during integration. ("FastSwitch" is
        /// just an example.)
        ///
        /// Null if no special switching mode is specified.
        /// </summary>
        /// <read-only/>

        if(_s != STAT_INIT) _s.__auto_mode /* : String */ = undefined;
        defGet(_s,"mode",__get_mode);
        function __get_mode()  { return _s.__auto_mode; }
        defSet(_s,"mode",__set_mode);
        function __set_mode(value /* : String */)  { _s.__auto_mode = value; }


        /// <summary>
        /// The current status of this switch. The valid switching statuses listed above.
        /// A switch that has just started should have the IN_PROGRESS status.
        ///
        /// Must be one of the valid switching statuses listed above. This cannot be null.
        /// </summary>

        if(_s != STAT_INIT) _s.__auto_status /* : String */ = undefined;
        defGet(_s,"status",__get_status);
        function __get_status()  { return _s.__auto_status; }
        defSet(_s,"status",__set_status);
        function __set_status(value /* : String */)  { _s.__auto_status = value; }

        /////////////////////////////////////////////////////////////////////////////////
        /// The following methods are not part of the API and are for Conviva internal
        /// use only.
        /////////////////////////////////////////////////////////////////////////////////

        /** @private */
        function _constr(id /* : String */, sourceStream /* : CandidateStream */, targetStream /* : CandidateStream */, timeoutMs /* : int */, mode /* : String */, status /* : String */) {
            _s.id = id;
            _s.sourceStream = sourceStream;
            _s.targetStream = targetStream;
            _s.timeoutMs = timeoutMs;
            _s.mode = mode;
            _s.status = status;
        }

        /**
         * Checks whether this object is valid.  This is necessary for languages
         * that are not typesafe, where users can set fields arbitrarily.
         *
         * @return null if this object is valid.  Otherwise return a string
         * describing the problem.
         *
         * @private
         */
        defPubMeth(_s,"CheckValidity",__CheckValidity);
        function __CheckValidity() /* : String */  {
            if (_s.id == null) {
                return "StreamSwitch.id is null (and must be non-null)";
            }
            // In dynamically-typed languages, we must ensure that fields are of the proper types.
            if (_s.id != null && !((typeof _s.id === "string"))) {
                return "StreamSwitch.id is not a string";
            } else if (_s.timeoutMs != null && !((typeof _s.timeoutMs === "number"))) {
                return "StreamSwitch.timeoutMs is not an int";
            } else if (_s.mode != null && !((typeof _s.mode === "string"))) {
                return "StreamSwitch.mode is not a string";
            } else if (_s.status != null && !((typeof _s.status === "string"))) {
                return "StreamSwitch.status is not a string";
            } else if (_s.sourceStream != null && !(_s.sourceStream instanceof CandidateStream)) {
                return "StreamSwitch.sourceStream is not a CandidateStream";
            } else if (_s.targetStream != null && !(_s.targetStream instanceof CandidateStream)) {
                return "StreamSwitch.targetStream is not a CandidateStream";
            }
            var sourceStreamError /* : String */ = (_s.sourceStream != null ? _s.sourceStream.CheckValidity() : null);
            if (sourceStreamError != null) {
                return sourceStreamError;
            }
            var targetStreamError /* : String */ = (_s.targetStream != null ? _s.targetStream.CheckValidity() : null);
            if (targetStreamError != null) {
                return targetStreamError;
            }
            return null;
        }

        /**
         * Construct clone of the proper type, from a similar object perhaps constructed
         * in another module. We copy fields one by one
         */
        defStatMeth(_s,StreamSwitch,"ConstructClone",__ConstructClone);
        function __ConstructClone(fromObj /* : Object */) /* : StreamSwitch */  {
            var res /* : StreamSwitch */ = new StreamSwitch(null, null, null, -1, "", "");
            res.id = NativeLang.GetStringField("id", fromObj);
            res.sourceStream = CandidateStream.ConstructClone(NativeLang.GetField("sourceStream", fromObj));
            res.targetStream = CandidateStream.ConstructClone(NativeLang.GetField("targetStream", fromObj));
            res.timeoutMs = slint.Cast(NativeLang.GetField("timeoutMs", fromObj));
            res.mode = NativeLang.GetStringField("mode", fromObj);
            res.status = NativeLang.GetStringField("status", fromObj);
            return res;
        }


        /** @private */
        defStatMeth(_s,StreamSwitch,"StaticInit",__StaticInit);
        function __StaticInit() /* : void */  {
            StreamSwitch._nextId = 0;
        }

        /** @private */
        defStatMeth(_s,StreamSwitch,"StaticCleanup",__StaticCleanup);
        function __StaticCleanup() /* : void */  {
            StreamSwitch._nextId = 0;
        }

        defStatMeth(_s,StreamSwitch,"GetNextId",__GetNextId);
        function __GetNextId(useInternalNamespace /* : Boolean */) /* : String */  {
            var id /* : int */ = StreamSwitch._nextId;
            StreamSwitch._nextId += 1;
            if (useInternalNamespace) {
                return "c3." + Lang.ToString(id);
            } else {
                return Lang.ToString(id);
            }
        }
       //JSRENAME:constant:_s:StreamSwitch:FAILED
       //JSRENAME:constant:_s:StreamSwitch:INTERRUPTED
       //JSRENAME:constant:_s:StreamSwitch:IN_PROGRESS
       //JSRENAME:constant:_s:StreamSwitch:PENDING
       //JSRENAME:constant:_s:StreamSwitch:SUCCEEDED
        if(_s != STAT_INIT) _constr.apply(_s, arguments);
    }
statInit(StreamSwitch,"StreamSwitch");
    // API_EXIT

// DO NOT EDIT! THIS FILE WAS GENERATED BY Slash from ../csClient/CwsClient/StreamerError.cs
// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-

// Copyright (c) 2011, 2012 Conviva Inc. All Rights Reserved.
// Author: George Necula (necula@conviva.com), Henry Milner (henry@conviva.com), Yan Li (yan@conviva.com)

// NOTE: This class is shared between the CWS client and the LivePass client


// namespace

    /// <summary>
    /// This class encapsulates the infomation about a streaming error
    /// </summary>
    function StreamerError() {
        var _s = this;
        // API_ENTER

        //error scope
        //unknown scope.
        if(_s == STAT_INIT) StreamerError.ERROR_SCOPE_UNKNOWN /* : int */ = 0;
        //single media segment
        if(_s == STAT_INIT) StreamerError.ERROR_SCOPE_STREAM_SEGMENT /* : int */ = 1;
        //single cdn, bitrate
        if(_s == STAT_INIT) StreamerError.ERROR_SCOPE_STREAM /* : int */ = 2;
        //whole cdn
        if(_s == STAT_INIT) StreamerError.ERROR_SCOPE_RESOURCE /* : int */ = 3;


        //error severity level
        /// <summary>
        /// Severity level of warning.
        /// </summary>
        if(_s == STAT_INIT) StreamerError.SEVERITY_WARNING /* : int */ = 0;
        /// <summary>
        /// Severity level of fatal error.
        /// </summary>
        if(_s == STAT_INIT) StreamerError.SEVERITY_FATAL /* : int */ = 1;

        // String identifying the encountered error
// Use a property to allow the obfuscator to keep an unobfuscated version
        if(_s != STAT_INIT) _s.__auto_errorCode /* : String */ = undefined;
        defGet(_s,"errorCode",__get_errorCode);
        function __get_errorCode()  { return _s.__auto_errorCode; }
        defSet(_s,"errorCode",__set_errorCode);
        function __set_errorCode(value /* : String */)  { _s.__auto_errorCode = value; }

        // Level of severity. Must be selected from the constant defined above

        if(_s != STAT_INIT) _s.__auto_severity /* : int */ = undefined;
        defGet(_s,"severity",__get_severity);
        function __get_severity()  { return _s.__auto_severity; }
        defSet(_s,"severity",__set_severity);
        function __set_severity(value /* : int */)  { _s.__auto_severity = value; }

        // Instance of CandidateStream that the error is encountered for

        if(_s != STAT_INIT) _s.__auto_stream /* : StreamInfo */ = undefined;
        defGet(_s,"stream",__get_stream);
        function __get_stream()  { return _s.__auto_stream; }
        defSet(_s,"stream",__set_stream);
        function __set_stream(value /* : StreamInfo */)  { _s.__auto_stream = value; }

        // Index of media segment that the error is encountered for

        if(_s != STAT_INIT) _s.__auto_index /* : int */ = undefined;
        defGet(_s,"index",__get_index);
        function __get_index()  { return _s.__auto_index; }
        defSet(_s,"index",__set_index);
        function __set_index(value /* : int */)  { _s.__auto_index = value; }

        // One of the ERROR_SCOPE constants defined above

        if(_s != STAT_INIT) _s.__auto_scope /* : int */ = undefined;
        defGet(_s,"scope",__get_scope);
        function __get_scope()  { return _s.__auto_scope; }
        defSet(_s,"scope",__set_scope);
        function __set_scope(value /* : int */)  { _s.__auto_scope = value; }

        /// <summary>
        /// Create an Error object without any scope
        /// </summary>
        /// <param name="errorCode">String identifying the encountered error</param>
        /// <param name="severity">Level of severity. Must be selected from the constant defined in PrecisionConsts</param>
        /// <returns>Error object</returns>
        defStatMeth(_s,StreamerError,"makeUnscopedError",__makeUnscopedError);
        function __makeUnscopedError(errorCode /* : String */, severity /* : int */) /* : StreamerError */  {
            return new StreamerError(errorCode, null, -1, severity, StreamerError.ERROR_SCOPE_UNKNOWN);
        }

        /// <summary>
        ///  Create an Error instance with stream scope.
        /// </summary>
        /// <param name="errCode">String identifying the encountered error</param>
        /// <param name="severity">Level of severity. Must be selected from the constant defined in PrecisionConsts</param>
        /// <param name="stream">Instance of CandidateStream that the error is encountered for</param>
        /// <returns>Error object</returns>
        defStatMeth(_s,StreamerError,"makeStreamError",__makeStreamError);
        function __makeStreamError(errCode /* : String */, severity /* : int */, stream /* : StreamInfo */) /* : StreamerError */  {
            return new StreamerError(errCode, stream, -1, severity, StreamerError.ERROR_SCOPE_STREAM);
        }

        /// <summary>
        /// Create an Error instance with Resource Scope
        /// </summary>
        /// <param name="errCode">String identifying the encountered error</param>
        /// <param name="severity">Level of severity. Must be selected from the constant defined in PrecisionConsts</param>
        /// <param name="stream">Instance of CandidateStream that the error is encountered for</param>
        /// <returns>Error object</returns>
        defStatMeth(_s,StreamerError,"makeResourceError",__makeResourceError);
        function __makeResourceError(errCode /* : String */, severity /* : int */, stream /* : StreamInfo */) /* : StreamerError */  {
            return new StreamerError(errCode, stream, -1, severity, StreamerError.ERROR_SCOPE_RESOURCE);
        }

        /// <summary>
        /// @deprecated
        ///  Create an Error instance with segment scope.
        /// </summary>
        /// <param name="errCode">String identifying the encountered error</param>
        /// <param name="severity">Level of severity. Must be selected from the constant defined in PrecisionConsts</param>
        /// <param name="stream">Instance of CandidateStream that the error is encountered for</param>
        /// <param name="idx">Index of media segment that the error is encountered for</param>
        /// <returns>Error object</returns>
        defStatMeth(_s,StreamerError,"makeStreamSegmentError",__makeStreamSegmentError);
        function __makeStreamSegmentError(errCode /* : String */, severity /* : int */, stream /* : StreamInfo */, idx /* : int */) /* : StreamerError */  {
            return new StreamerError(errCode, stream, idx, severity, StreamerError.ERROR_SCOPE_STREAM_SEGMENT);
        }

        function _constr(_errorCode /* : String */, _stream /* : StreamInfo */, _index /* : int */, _severity /* : int */, _scope /* : int */) {
            _s.errorCode = _errorCode;

            _s.stream = _stream;
            _s.index = _index;
            _s.severity = _severity;
            _s.scope = _scope;
        }


        /**
         * Construct clone of the proper type, from a similar object perhaps constructed
         * in another module. We copy fields one by one
         */
        defStatMeth(_s,StreamerError,"ConstructClone",__ConstructClone);
        function __ConstructClone(fromObj /* : Object */) /* : StreamerError */  {
            if (fromObj == null) return null;
            var res /* : StreamerError */ = new StreamerError("", null, 0, 0, 0);
            res.errorCode = NativeLang.GetStringField("errorCode", fromObj);
            res.severity = slint.Cast(NativeLang.GetField("severity", fromObj));
            res.stream = StreamInfo.ConstructClone(NativeLang.GetField("stream", fromObj));
            res.scope = slint.Cast(NativeLang.GetField("scope", fromObj));
            res.index = slint.Cast(NativeLang.GetField("index", fromObj));
            return res;
        }

        defPubMeth(_s,"ToStr",__ToStr);
        function __ToStr() /* : String */  {
            return "errorCode=" + (_s.errorCode != null ? _s.errorCode : "null") +
                ", index=" + _s.index +
                ", severity=" + _s.severity +
                ", scope=" + _s.scope +
                ", stream=(" + _s.stream.ToStr() + ")";
        }

        // API_EXIT
       //JSRENAME:constant:_s:StreamerError:ERROR_SCOPE_RESOURCE
       //JSRENAME:constant:_s:StreamerError:ERROR_SCOPE_STREAM
       //JSRENAME:constant:_s:StreamerError:ERROR_SCOPE_STREAM_SEGMENT
       //JSRENAME:constant:_s:StreamerError:ERROR_SCOPE_UNKNOWN
       //JSRENAME:constant:_s:StreamerError:SEVERITY_FATAL
       //JSRENAME:constant:_s:StreamerError:SEVERITY_WARNING
        if(_s != STAT_INIT) _constr.apply(_s, arguments);
    }
statInit(StreamerError,"StreamerError");

// DO NOT EDIT! THIS FILE WAS GENERATED BY Slash from ../../csClient/CwsClient/monitor/Monitor.cs
// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-

// Copyright (c) 2011, 2012 Conviva Inc. All Rights Reserved.
// Author: Henry Milner (henry@conviva.com), George Necula (necula@conviva.com), Yan Li (yan@conviva.com)



// namespace monitor

    function Monitor() {
        var _s = this;


        if(_s != STAT_INIT) _s._sessionId /* : int */ = 0; // Used to identify the session in logs

        if(_s != STAT_INIT) _s._externalBitrateReporting /* : Boolean */ = false;

        //@owner
        if(_s != STAT_INIT) _s._streamer /* : ConvivaStreamerProxy */ = null;
        // Temporary object, saved until we start monitoring
        if(_s != STAT_INIT) _s._streamerObject /* : Object */ = null;

        if(_s != STAT_INIT) _s._eventQueue /* : EventQueue */ = null;
        if(_s != STAT_INIT) _s._contentInfo /* : ConvivaContentInfo */ = null;
        if(_s != STAT_INIT) _s._nextHeartbeat /* : DictionaryCS(string, object) */ = null;
        if(_s != STAT_INIT) _s._utils /* : Utils */ = null;

        //Proxy state
        if(_s != STAT_INIT) _s._playingState /* : String */ = ConvivaStreamerProxy.UNKNOWN;
        if(_s != STAT_INIT) _s._streamInfo /* : StreamInfo */ = null; // Current bitrate, cdn, resource
        if(_s != STAT_INIT) _s._sessionFlags /* : int */ = 1;

        if(_s != STAT_INIT) _s._startTimeMs /* : Number */ = 0;
        if(_s != STAT_INIT) _s._lastStateUpdateTimeMs /* : Number */ = 0; //TODO: deprecate in CWS 1.8

        // TODO we only need to compute the pause join time in the 1.6/1.7 hybrid client. We should remove this in CWS 1.9.
        if(_s != STAT_INIT) _s._pauseJoinTimeStartTimeMs /* : Number */ = 0; // The time when the pauseJoinTime was called. If 0, we are not after a pauseJoinTime
        if(_s != STAT_INIT) _s._pauseJointTimeTotalMs /* : Number */ = 0; // The total time we spent in pauseJoinTime state.

        // The time spent in all non-playing states before the first playing
        // state.  Negative iff no playing state has been observed yet.
        // There are two special negative values:
        //  o -1: Not yet joined.
        //  o -2: An error caused this session to fail to join.  (If the
        //        somehow joins anyway, this is ignored.)
        if(_s != STAT_INIT) _s._joinTimeMs /* : int */ = -1; //TODO: deprecate in CWS 1.8

        // Total of all nominal bits played
        if(_s != STAT_INIT) _s._nominalPlayingBitsTotal /* : Number */ = 0; //TODO: deprecate in CWS 1.8

        if(_s != STAT_INIT) _s._encodedFps /* : int */ = -1;
        if(_s != STAT_INIT) _s._contentLengthSec /* : int */ = -1;
        if(_s != STAT_INIT) _s._streamUrl /* : String */ = null;
        // Flag if duration is set by external API
        if(_s != STAT_INIT) _s._externalDurationReporting /* : boolean */ = false;
        // Flag if stream url is set by external API
        if(_s != STAT_INIT) _s._externalStreamUrlReporting /* : boolean */ = false;
        // Flag if bitrate is set by external API
        if(_s != STAT_INIT) _s._externalBitrateSet /* : boolean */ = false;
        // Flag if encodedFps is set by external API
        if(_s != STAT_INIT) _s._externalFpsReporting /* : boolean */ = false;
        // Number of times the framerate has been checked while in playing state.
        if(_s != STAT_INIT) _s._playingFpsObservationCount /* : int */ = 0;
        // Total of all playing FPS observations
        if(_s != STAT_INIT) _s._playingFpsTotal /* : Number */ = 0;

        function _constr(streamer /* : Object */, eventQueue /* : EventQueue */, contentInfo /* : ConvivaContentInfo */, options /* : Object */, sessionId /* : int */, networkInfo /* : NetworkInfo : */) {

            _s._eventQueue = eventQueue;
            _s._utils = Utils.getInstance();
            _s._contentInfo = contentInfo;
            _s._networkInfo = networkInfo;
            _s._sessionId = sessionId;
            _s._nextHeartbeat = new DictionaryCS/*<string, object>*/();
            _s._streamerObject = streamer;

            _s._startTimeMs = 0;
            _s._lastStateUpdateTimeMs = 0; //TODO: deprecate in CWS 1.8

            _s._pauseJoinTimeStartTimeMs = 0; //TODO: deprecate in CWS 1.9
            _s._pauseJointTimeTotalMs = 0; //TODO: deprecate in CWS 1.9

            _s._joinTimeMs = -1; //TODO: deprecate in CWS 1.8
            _s._nominalPlayingBitsTotal = 0; //TODO: deprecate in CWS 1.8

            if(_s._contentInfo.encodedFps != -1) {
                _s._encodedFps = _s._contentInfo.encodedFps;
                _s._externalFpsReporting = true;
            }
            if(_s._contentInfo.duration != -1) {
                _s._contentLengthSec = _s._contentInfo.duration;
                _s._externalDurationReporting = true;
            }
            if(_s._contentInfo.streamUrl) {
                _s._streamUrl = _s._contentInfo.streamUrl;
                _s._externalStreamUrlReporting= true;
            }

            _s._playingFpsObservationCount = 0;
            _s._playingFpsTotal = 0;

            if (options != null) {
                var optionsDict /* : DictionaryCS(string, bool) */ = Lang.DictionaryFromRepr/*string, bool*/(options);
                if (optionsDict.ContainsKey(LivePass.OPTION_EXTERNAL_BITRATE_REPORTING)) {
                    _s._externalBitrateReporting = optionsDict.GetValue(LivePass.OPTION_EXTERNAL_BITRATE_REPORTING);
                }
            }
        }

        defPubMeth(_s,"start",__start);
        function __start(nowMs /* : Number */) /* : void */  {
            _s._startTimeMs = nowMs;
            _s._lastStateUpdateTimeMs = nowMs; //TODO: deprecate in CWS 1.8
            _s.buildInitialStreamInfo();

            _s.attachStreamer(_s._streamerObject);
            _s._streamerObject = null;
        }

        /// Attach a streamer to the monitor and resume monitoring if suspended
        defPubMeth(_s,"attachStreamer",__attachStreamer);
        function __attachStreamer(streamerObject /* : Object */) /* : void */  { //NO_RENAME:GetCapabilities
            _s._utils.logSession("Monitor.attachStreamer()", _s._sessionId);
            if (_s._streamer != null) {
                _s._utils.logSession("Monitor.attachStreamer(): detach current streamer first", _s._sessionId);
                return;
            }
            if (streamerObject == null) {
                _s._utils.logSession("Monitor.attachStreamer(): received a null streamer", _s._sessionId);
                _s.SetPlayingState(ConvivaStreamerProxy.NOT_MONITORED);
                return;
            }

            // Create streamer proxy and get references to state and stream
            _s._streamer = Monitor.wrapInConvivaStreamerProxy(streamerObject, _s._sessionId);

            _s._sessionFlags = _s._streamer.GetCapabilities();
            if (_s._externalBitrateReporting) {
                _s._sessionFlags |= ConvivaStreamerProxy.CAPABILITY_BITRATE_EXTERNAL;
            }

            _s.SetPlayingState(ConvivaStreamerProxy.UNKNOWN);

            // This call will push the current proxy states to the monitor
            _s._streamer.SetMonitoringNotifier(_s.notificationFromStreamerProxy);

            _s._lastStateUpdateTimeMs = _s._utils.epochTimeMs();
        }

        /// Pause monitoring such that it can be restarted later and detach from current streamer
        defPubMeth(_s,"detachStreamer",__detachStreamer);
        function __detachStreamer() /* : void */  {
            _s._utils.logSession("Monitor.detachStreamer()", _s._sessionId);
            _s.updateMetrics();
            if (_s._streamer != null) {
                _s._streamer.Cleanup(); // removes notifiers
                _s.SetPlayingState(ConvivaStreamerProxy.NOT_MONITORED);
                _s._streamer = null;
            }
        }

        /**
         * Pause the computation of join time
         */
        defPubMeth(_s,"pauseJoinTime",__pauseJoinTime);
        function __pauseJoinTime() /* : void */  {
            _s._utils.logSession("Monitor.pauseJoinTime()", _s._sessionId);
            if (_s._pauseJoinTimeStartTimeMs == 0) { //TODO: deprecate in CWS 1.8
                _s._pauseJoinTimeStartTimeMs = _s._utils.epochTimeMs();

                var newState /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
                var oldState /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
                newState.SetValue("pj", true);
                oldState.SetValue("pj", false);
                _s.declareStateChange(newState, oldState);
            }

        }

        /**
         * Resume the computation of join time
         * @param addEvent : if true, then generate an event
         */
        defPubMeth(_s,"resumeJoinTime",__resumeJoinTime);
        function __resumeJoinTime(addEvent /* : Boolean */) /* : void */  {
            _s._utils.logSession("Monitor.resumeJoinTime()", _s._sessionId);
            if (_s._pauseJoinTimeStartTimeMs > 0) {
                _s._pauseJointTimeTotalMs += (_s._utils.epochTimeMs() - _s._pauseJoinTimeStartTimeMs);
                if (addEvent) {
                    var newState /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
                    var oldState /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
                    newState.SetValue("pj", false);
                    oldState.SetValue("pj", true);
                    _s.declareStateChange(newState, oldState);
                }
            }
            _s._pauseJoinTimeStartTimeMs = 0;
        }


        defGet(_s,"streamer",__get_streamer);
        function __get_streamer()  { return  _s._streamer; }

        defPrivMeth(_s,"buildInitialStreamInfo",__buildInitialStreamInfo);
        function __buildInitialStreamInfo() /* : void */  {
            var initialBitrateKbps /* : int */ = -1;
            var initialResource /* : String */ = null;
            var initialCdnName /* : String */ = ConvivaContentInfo.CDN_NAME_OTHER;

            if (_s._contentInfo != null) {
                initialCdnName = _s._contentInfo.defaultReportingCdnName;
                //TODO: deprecate in CWS 1.8. Backend should enforce resource=cdnName if it needs to.
                if (_s._contentInfo.defaultReportingResource == null ||
                    _s._contentInfo.defaultReportingResource == ConvivaContentInfo.NO_RESOURCE) {
                    initialResource = initialCdnName;
                } else {
                    initialResource = _s._contentInfo.defaultReportingResource;
                }
                if(_s._externalBitrateReporting && _s._contentInfo.defaultReportingBitrateKbps != -1) {
                    _s._externalBitrateSet = true;
                }
                initialBitrateKbps = _s._contentInfo.defaultReportingBitrateKbps;
            }
            _s._streamInfo = new StreamInfo(initialBitrateKbps, initialCdnName, initialResource, -1, -1, -1);
        }


        /* This is how we receive notifications from the ConvivaStreamerProxy */
        defPrivMeth(_s,"notificationFromStreamerProxy",__notificationFromStreamerProxy);
        function __notificationFromStreamerProxy(notificationName /* : String */, arg /* : Object */) /* : void */  {
            _s._utils.runProtected(
                function () {
                    switch (notificationName) {
                        case "PlayingStateChange":
                            var newState /* : String */ = (arg);
                            _s.OnPlayingStateChange(newState);
                            break;
                        case "StreamInfoChange":
                            var newInfo /* : StreamInfo */ = (arg);
                            _s.SetStream(newInfo);
                            break;
                        case "ErrorChange":
                            var newError /* : StreamerError */ = (arg);
                            _s.OnError(newError);
                            break;
                        case "MetadataChange":
                            _s.OnMetadata(arg);
                            break;
                        case "Log":
                            var logMsg /* : String */ = (arg);
                            _s._utils.logSession(logMsg, _s._sessionId);
                            break;
                        case "SendSeekEvent":
                            var evt /* : DictionaryCS(string, object) */ = (arg);
                            _s.OnSeekEvent(evt);
                            break;
                        case "DisplaySizeChange":
                            var evt /* : DictionaryCS (string, int) */ = (arg);
                            _s.OnStreamSizeChange(evt);
                            break;
                        case "NetworkInfoChange":
                            var evt /* : NetworkInfo */ = (arg);
                            _s.OnNetworkInfoChange(evt);
                            break;
                    }
                }, "notificationFromStreamerProxy");
        }

        /// Set display size & raise state change event
        defPrivMeth(_s,"OnStreamSizeChange",__OnStreamSizeChange);
        function __OnStreamSizeChange(size /* : DictionaryCS */) /* : void */  {
            var newState /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
            var oldState /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
            if((size.GetValue("width") > 0 && size.GetValue("width") != _s._width) || (size.GetValue("height") > 0 && size.GetValue("height") != _s._height)) {
                if(size.GetValue("width") > 0 && size.GetValue("width") != _s._width) {
                    newState.SetValue("w", size.GetValue("width"));
                    oldState.SetValue("w", _s._width);
                    _s._width = size.GetValue("width");
                }
                if(size.GetValue("height") > 0 && size.GetValue("height") != _s._height) {
                    newState.SetValue("h", size.GetValue("height"));
                    oldState.SetValue("h", _s._height);
                    _s._height = size.GetValue("height");
                }
                _s.declareStateChange(newState, oldState);
            }
        }
        /// Set Network Info & raise state change event
        defPrivMeth(_s,"OnNetworkInfoChange",__OnNetworkInfoChange);
        function __OnNetworkInfoChange(nwinfo /* : NetworkInfo */) /* : void */  {
            var newState /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
            var oldState /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
            if(nwinfo.connectionType != null && _s._connectionType != nwinfo.connectionType ) {
                newState.SetValue("ct", nwinfo.connectionType);
                oldState.SetValue("ct", _s._connectionType);
                _s._networkInfo.connectionType = nwinfo.connectionType;
                _s._connectionType = nwinfo.connectionType;
            }if(nwinfo.ssid != null && _s._ssid != nwinfo.ssid ) {
                newState.SetValue("ssid", nwinfo.ssid);
                oldState.SetValue("ssid", _s._ssid);
                _s._networkInfo.ssid = nwinfo.ssid;
                _s._ssid = nwinfo.ssid;
            }if(nwinfo.signalStrength <= 0) {
                _s._networkInfo.signalStrength = nwinfo.signalStrength;
            }if(nwinfo.linkEncryption != null && _s._linkEncryption != nwinfo.linkEncryption) {
                newState.SetValue("le", nwinfo.linkEncryption);
                oldState.SetValue("le", _s._linkEncryption);
                _s._networkInfo.linkEncryption = nwinfo.linkEncryption;
                _s._linkEncryption = nwinfo.linkEncryption;
            }
            _s.declareStateChange(newState, oldState);
        }

        defPrivMeth(_s,"OnPlayingStateChange",__OnPlayingStateChange);
        function __OnPlayingStateChange(newPlayingState /* : String */) /* : void */  {
            _s.updateStateCumulativeTime(); //TODO: deprecate in CWS 1.8
            if (_s._playingState == newPlayingState) {
                return;
            }

            var hasJoined /* : Boolean */ = _s._joinTimeMs >= 0;
            var newState /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
            var oldState /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
            newState.SetValue("ps", PlayerStates.stringToInt(newPlayingState));
            oldState.SetValue("ps", PlayerStates.stringToInt(_s._playingState));

            // Do we have a join?
            if (!hasJoined && newPlayingState == ConvivaStreamerProxy.PLAYING) {

                // If we have transitioned to play, and we were in pauseJoinTime mode, simulate a resumeJoinTime
                if (_s._pauseJoinTimeStartTimeMs > 0) { //TODO: deprecate in CWS 1.9
                    _s.resumeJoinTime(false);
                    newState.SetValue("pj", false);
                    oldState.SetValue("pj", true);
                }
                // Adjust join time for ad
                _s._joinTimeMs = slint.Cast(_s._utils.epochTimeMs() - _s._startTimeMs - _s._pauseJointTimeTotalMs); //TODO: deprecate in CWS 1.8

                if (_s._joinTimeMs < 0) { //TODO: deprecate in CWS 1.8
                    _s._joinTimeMs = 0;
                }
            }
            _s._utils.logSession("Monitor: change playing state to " + newPlayingState, _s._sessionId);
            _s._playingState = newPlayingState;
            _s.declareStateChange(newState, oldState);
        }

        /// Set state of streamer
        defPrivMeth(_s,"SetPlayingState",__SetPlayingState);
        function __SetPlayingState(newState /* : String */) /* : void */  {
            if (_s._playingState == newState) {
                return;
            }
            _s.OnPlayingStateChange(newState);
        }

        // Made "public" for use by Session.setCdnNameOrResource()
        defPubMeth(_s,"SetStream",__SetStream);
        function __SetStream(targetStream /* : StreamInfo */) /* : void */  {
            if (targetStream == null) {
                return;
            }
            // PD-14119
            // Prevent stale CSP state from being pushed to Monitor...
            // We can't change shared CSP behavior without affecting LivePass...
            // We can't use CSP.SetStream() to push the real state to CSP because
            // CSP.SetStream() is the original caller most of the time...
            // We can't synchronously call a separate method to accomplish the same objective either
            // since the last instruction of CSP.SetStream() will eventually override the state again...
            if (_s._streamer != null) {
                if (targetStream.bitrateKbps == _s._streamer.GetBitrateKbps()) {
                    // CSP trying to push current bitrate value as new bitrate value, reset it
                    targetStream.bitrateKbps = -2;
                }
                if (targetStream.cdnName == _s._streamer.GetCdnName()) {
                    // CSP trying to push current cdnName value as new cdnName value, reset it
                    targetStream.cdnName = null;
                }
                if (targetStream.resource == _s._streamer.GetResource()) {
                    // CSP trying to push current resource value as new resource value, reset it
                    targetStream.resource = null;
                }
            }
            // Continue matching resource and cdnName if necessary
            //TODO: deprecate in CWS 1.8. Backend should enforce resource=cdnName if it needs to.
            if (targetStream.resource == null && targetStream.cdnName != null && _s._streamInfo.cdnName == _s._streamInfo.resource) {
                 targetStream.resource = targetStream.cdnName;
            }
            if (targetStream.bitrateKbps <= -2 || _s._externalBitrateSet) targetStream.bitrateKbps = _s._streamInfo.bitrateKbps;
            if (targetStream.cdnName == null) targetStream.cdnName = _s._streamInfo.cdnName;
            if (targetStream.resource == null || targetStream.resource == ConvivaContentInfo.NO_RESOURCE) targetStream.resource = _s._streamInfo.resource;
            if (!_s._streamInfo.equals(targetStream)) {
                _s.updateStateCumulativeTime();
                _s.enqueueStreamChangeEvent(_s._streamInfo, targetStream);
                _s._streamInfo = targetStream;
            }
        }

        /// Set bitrate at integration level
        /// If external bitrate option is not enabled for the session, this method does nothing
        /// Called by Session.setBitrate()
        defPubMeth(_s,"setBitrate",__setBitrate);
        function __setBitrate(newBitrateKbps /* : int */) /* : void */  {
            if (_s._externalBitrateReporting) {
                var newStream /* : StreamInfo */ = StreamInfo.ConstructClone(_s._streamInfo);
                newStream.bitrateKbps = newBitrateKbps;
                if (newStream.bitrateKbps != _s._streamer.GetBitrateKbps()) {
                    _s.updateStateCumulativeTime();
                    _s.enqueueStreamChangeEvent(_s._streamInfo, newStream);
                    _s._streamInfo = newStream;
                    _s._externalBitrateSet = true;
                }
            } else {
                _s._utils.logSession("setBitrate() call ignored, enable external bitrate reporting first.", _s._sessionId);
            }
        }

        // Made "public" for use by Session.reportError()
        defPubMeth(_s,"OnError",__OnError);
        function __OnError(e /* : StreamerError */) /* : void */  {
            // When an error happens, we just send the error event
            _s.declareError(e.errorCode, (e.severity == StreamerError.SEVERITY_FATAL));
        }

        defPrivMeth(_s,"OnMetadata",__OnMetadata);
        function __OnMetadata(metadata /* : Object */) /* : void */  {
            // ##TODO: Won't work for settings tags, needs Dictionary<string, object>
            var metadataDict /* : DictionaryCS(string, string) */ = Lang.DictionaryFromRepr/*string, string*/(metadata);
            if (metadataDict.ContainsKey(ConvivaStreamerProxy.METADATA_ENCODED_FRAMERATE)&& !_s._externalFpsReporting) {
                _s._encodedFps = slint.Cast(_s._utils.parseNumber(metadataDict.GetValue(ConvivaStreamerProxy.METADATA_ENCODED_FRAMERATE), -1));
                _s._utils.logSession("Monitor: received " + ConvivaStreamerProxy.METADATA_ENCODED_FRAMERATE + " metadata: " + _s._encodedFps, _s._sessionId);
                _s._contentInfo.encodedFps = _s._encodedFps;
            }
            if (metadataDict.ContainsKey(ConvivaStreamerProxy.METADATA_DURATION) && !_s._externalDurationReporting) {
                _s._contentLengthSec = slint.Cast(_s._utils.parseNumber(metadataDict.GetValue(ConvivaStreamerProxy.METADATA_DURATION), -1));
                _s._utils.logSession("Monitor: received " + ConvivaStreamerProxy.METADATA_DURATION + " metadata: " + _s._contentLengthSec, _s._sessionId);
                _s._contentInfo.duration = _s._contentLengthSec;
            }
            if (metadataDict.ContainsKey(ConvivaStreamerProxy.METADATA_STREAM_URL) && !_s._externalStreamUrlReporting) {
                _s._streamUrl = metadataDict.GetValue(ConvivaStreamerProxy.METADATA_STREAM_URL);
                _s._utils.logSession("Monitor: received " + ConvivaStreamerProxy.METADATA_STREAM_URL + " metadata: " + _s._streamUrl, _s._sessionId);
                _s._contentInfo.streamUrl = _s._streamUrl ;
            }
        }

        defPubMeth(_s,"OnSeekEvent",__OnSeekEvent);
        function __OnSeekEvent(evt /* : DictionaryCS(string, object) */) /* : void */  {
            var data /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
            if(_s._streamer !== null && typeof(_s._streamer.GetPlayheadTimeMs) == "function" && _s._streamer.GetPlayheadTimeMs() >= 0) {
                data.SetValue("pht", Math.round(_s._streamer.GetPlayheadTimeMs()));
            }
            _s.enqueueEvent("CwsSeekEvent", evt);
        }

        /** Update @heartbeat with current metrics. */
        defPubMeth(_s,"updateHeartbeat",__updateHeartbeat);
        function __updateHeartbeat(heartbeat /* : DictionaryCS(string, object) */) /* : void */  {
            _s.updateMetrics();
            _s.buildDataSampleEvent();

            var averageFps /* : int */ = -1;
            if (_s._playingFpsObservationCount > 0) {
                averageFps = slint.Cast((_s._playingFpsTotal + 0.0) / _s._playingFpsObservationCount);
            }
            NativeLang.setDictValue(heartbeat, "ps", PlayerStates.stringToInt(_s._playingState));
            NativeLang.setDictValue(heartbeat, "pj", (_s._pauseJoinTimeStartTimeMs > 0 ? true : false));   // TODO: deprecate in CWS 1.9
            NativeLang.setDictValue(heartbeat, "sf", _s._sessionFlags);

            if (_s._contentLengthSec > 0) {
                NativeLang.setDictValue(heartbeat, "cl", _s._contentLengthSec);
            }
            if (_s._streamInfo.GetBitrateKbps() > 0) {
                NativeLang.setDictValue(heartbeat, "br", _s._streamInfo.GetBitrateKbps());
            }
            if(_s._streamInfo.GetResource()){
                 NativeLang.setDictValue(heartbeat, "rs", _s._streamInfo.GetResource());
            }

            if(_s._streamInfo.GetCdnName()){
                 NativeLang.setDictValue(heartbeat, "cdn", _s._streamInfo.GetCdnName());
            }

            if (_s._encodedFps >= 0) {
                NativeLang.setDictValue(heartbeat, "efps", _s._encodedFps);
            }
            if (_s._renderedFps >= 0) {
                NativeLang.setDictValue(heartbeat, "rfps", _s._renderedFps);
            }
            if (_s._droppedFps >= 0) {
                NativeLang.setDictValue(heartbeat, "dfps", _s._droppedFps);
            }

            if (averageFps >= 0) {
                NativeLang.setDictValue(heartbeat, "afps", averageFps);
            }
            if (_s._width > 0) {
                NativeLang.setDictValue(heartbeat, "w", _s._width);
            }
            if (_s._height > 0) {
                NativeLang.setDictValue(heartbeat, "h", _s._height);
            }
            if(_s._streamer !== null && typeof(_s._streamer.GetPlayheadTimeMs) == "function" && _s._streamer.GetPlayheadTimeMs() >= 0) {
                NativeLang.setDictValue(heartbeat, "pht", Math.round(_s._streamer.GetPlayheadTimeMs()));
            }
            if(_s._networkInfo.GetConnectionType()) {
                NativeLang.setDictValue(heartbeat, "ct", _s._networkInfo.GetConnectionType());
            }
            if(_s._networkInfo.GetSsid()) {
                NativeLang.setDictValue(heartbeat, "ssid", _s._networkInfo.GetSsid());
            }
            if(_s._networkInfo.GetSignalStrength() <= 0) {
                NativeLang.setDictValue(heartbeat, "ss", _s._networkInfo.GetSignalStrength());
            }
            if(_s._networkInfo.GetLinkEncryption()) {
                NativeLang.setDictValue(heartbeat, "le", _s._networkInfo.GetLinkEncryption());
            }
        }

        defPubMeth(_s,"cleanup",__cleanup);
        function __cleanup() /* : void */  {
            if (_s._streamer != null) {
                _s._streamer.Cleanup();
            }
            _s._streamer = null;
            _s._streamerObject = null;
            _s._eventQueue = null;
            _s._contentInfo = null;
            _s._nextHeartbeat = null;
            _s._streamInfo = null;
            _s._utils = null;
        }

        defPrivMeth(_s,"updateMetrics",__updateMetrics);
        function __updateMetrics() /* : void */  {
            if (_s._streamer == null) return;
            if (_s._playingState == ConvivaStreamerProxy.PLAYING) {
                if (!_s._externalFpsReporting) {
                    var efps /* : Number */ = _s._streamer.GetSourceFrameRate();//Returns encoded frame rate
                }
                var rfps /* : Number */ = _s._streamer.GetRenderedFrameRate(); //Returns Rendered frame rate
                var dfps /* : Number */ = _s._streamer.GetDroppedFrames(); //Returns dropped frame rate
                if (efps >= 0) {
                    _s._encodedFps = efps;
                }
                if (rfps >= 0) {
                    _s._renderedFps = rfps;
                    _s._playingFpsTotal += rfps;
                    _s._playingFpsObservationCount++;
                }
                if (dfps >= 0) {
                    _s._droppedFps = dfps;
                }
            }
            _s.updateStateCumulativeTime(); //TODO: deprecate in CWS 1.8
        }

        defPrivMeth(_s,"buildDataSampleEvent", __buildDataSampleEvent);
        function __buildDataSampleEvent() /* : void */  {
            var data /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
            if(_s._streamer !== null && typeof(_s._streamer.GetStartingBufferLengthMs) == "function" && _s._streamer.GetStartingBufferLengthMs() >= 0) {
                data.SetValue("bl", Math.round(_s._streamer.GetStartingBufferLengthMs()));
            }
            if(_s._networkInfo.GetSignalStrength() <= 0) {
                data.SetValue("ss", _s._networkInfo.GetSignalStrength());
            }
            if(_s._streamer !== null && typeof(_s._streamer.GetPlayheadTimeMs) == "function" && _s._streamer.GetPlayheadTimeMs() >= 0) {
                data.SetValue("pht", Math.round(_s._streamer.GetPlayheadTimeMs()));
            }
            _s.enqueueEvent("CwsDataSamplesEvent", data);
        }

        defPrivMeth(_s,"enqueueEvent",__enqueueEvent);
        function __enqueueEvent(type /* : String */, eventData /* : DictionaryCS(string, object) */) /* : void */  {
            _s._eventQueue.enqueueEvent(type, eventData, slint.Cast(_s._utils.epochTimeMs() - _s._startTimeMs));
        }

        defPrivMeth(_s,"enqueueStreamChangeEvent",__enqueueStreamChangeEvent);
        function __enqueueStreamChangeEvent(oldStream /* : StreamInfo */, newStream /* : StreamInfo */) /* : void */  {
            var newState /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
            var oldState /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
            if (oldStream.GetBitrateKbps() != newStream.GetBitrateKbps() && newStream.GetBitrateKbps() > 0) {
                oldState.SetValue("br", oldStream.GetBitrateKbps());
                newState.SetValue("br", newStream.GetBitrateKbps());
                _s._utils.logSession("Monitor: change bitrate from " + oldState.GetValue("br") + " to " + newState.GetValue("br"), _s._sessionId);
            }
            if (oldStream.GetCdnName() != newStream.GetCdnName()) {
                oldState.SetValue("cdn", oldStream.GetCdnName());
                newState.SetValue("cdn", newStream.GetCdnName());
                _s._utils.logSession("Monitor: change cdnName from " + oldState.GetValue("cdn") + " to " + newState.GetValue("cdn"), _s._sessionId);
            }
            if (oldStream.GetResource() != newStream.GetResource()) {
                oldState.SetValue("rs", oldStream.GetResource());
                newState.SetValue("rs", newStream.GetResource());
                _s._utils.logSession("Monitor: change resource from " + oldState.GetValue("rs") + " to " + newState.GetValue("rs"), _s._sessionId);
            }
            _s.declareStateChange(newState, oldState);
        }

        //TODO: deprecate in CWS 1.8
        defPrivMeth(_s,"updateStateCumulativeTime",__updateStateCumulativeTime);
        function __updateStateCumulativeTime() /* : void */  {
            var now /* : Number */ = _s._utils.epochTimeMs();
            var playingStateInt /* : int */ = PlayerStates.stringToInt(_s._playingState);
            if (_s._playingState != ConvivaStreamerProxy.UNKNOWN) {
                var delta /* : int */ = slint.Cast(now - _s._lastStateUpdateTimeMs);
                var bitrateKbps /* : int */ = _s._streamInfo.GetBitrateKbps();
                if (_s._playingState == ConvivaStreamerProxy.PLAYING && bitrateKbps != -1) {
                    _s._nominalPlayingBitsTotal += (delta * bitrateKbps); // ms * kilobits / s = bits
                }
            }
            _s._lastStateUpdateTimeMs = now;
        }

        defPrivMeth(_s,"declareError",__declareError);
        function __declareError(errorMsg /* : String */, isFatal /* : Boolean */) /* : void */  {
            if (_s._joinTimeMs < 0 && isFatal) { //TODO: deprecate in CWS 1.8
                // Join failure.
                _s._joinTimeMs = -2;
            }
            var data /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
            data.SetValue("ft", isFatal);
            data.SetValue("err", errorMsg);
            if(_s._streamer !== null && typeof(_s._streamer.GetPlayheadTimeMs) == "function" && _s._streamer.GetPlayheadTimeMs() >= 0) {
                data.SetValue("pht", Math.round(_s._streamer.GetPlayheadTimeMs()));
            }
            _s.enqueueEvent("CwsErrorEvent", data);
        }

        defPrivMeth(_s,"declareStateChange",__declareStateChange);
        function __declareStateChange(newState /* : DictionaryCS(string, object) */, oldState /* : DictionaryCS(string, object) */) /* : void */  {
            // We construct a native dictionary for the data
            var newStateNative = Lang.StringDictionaryToRepr(newState);
            var oldStateNative = Lang.StringDictionaryToRepr(oldState);
            var data /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
            data.SetValue("new", newStateNative);
            if (oldState != null) {
                data.SetValue("old", oldStateNative);
            }
            if(_s._streamer !== null && typeof(_s._streamer.GetPlayheadTimeMs) == "function" && _s._streamer.GetPlayheadTimeMs() >= 0) {
                data.SetValue("pht", Math.round(_s._streamer.GetPlayheadTimeMs()));
            }
            _s.enqueueEvent("CwsStateChangeEvent", data);
        }

        defStatMeth(_s,Monitor,"wrapInConvivaStreamerProxy",__wrapInConvivaStreamerProxy);
        function __wrapInConvivaStreamerProxy(streamer /* : Object */, sessionId /* : int */) /* : ConvivaStreamerProxy */  {
            //NO_RENAME:networkState,readyState,getStreamerType,getAttribute,indexOf
            //NO_RENAME:setQosData,licenseResponse,currentPTS,availableAudioStreams
            //NO_RENAME:textTrackDisplay,mediaLoader
            // Add wrappers for new streamer types here.
            // ALBAN: properly wrap around native Samsung streamers as well
            // That way we don't need to tweak the Touchstone Driver class
            // This should become default behavior if we manage to get rid of the SamsungStreamer class someday
            var realSamsungStreamerProxy /* : var */ = null;
            try {
                if (streamer.getAttribute && streamer.getAttribute("classid").indexOf("clsid:SAMSUNG-INFOLINK") >= 0) {
                    realSamsungStreamerProxy = new SamsungStreamerProxy(streamer);
                    realSamsungStreamerProxy.startMonitoring(); // Shouldn't this call happen in the constructor?
                }
            } catch(e) {}
            if (realSamsungStreamerProxy) {
                return realSamsungStreamerProxy;
            } else if (streamer.hasOwnProperty('getStreamerType') && streamer.getStreamerType() == 'Samsung') {
                return SamsungStreamerProxy.createSamsungStreamerProxy(streamer);
            } else if (streamer.setQosData !== undefined && streamer.licenseResponse !== undefined) {
                return new PlayStationTouchFactorStreamerProxy(); // streamer is global vod.player interface
            } else if (streamer.codecs !== undefined && streamer.maxBufferLength !== undefined) {
                return new PlayStationLibjscriptStreamerProxy(); // streamer is global videometrics interface
            } else if (streamer.textTrackDisplay !== undefined && streamer.mediaLoader !== undefined) {
                return new ConvivaVideojsStreamerProxy(streamer);
            } else if (streamer.networkState !== undefined && streamer.readyState !== undefined) {
                return new Html5ConvivaStreamerProxy(streamer);
            } else if (streamer.currentPTS !== undefined && streamer.availableAudioStreams !== undefined) {
                return new PlayStationTrilithiumStreamerProxy(streamer);
            } else if (streamer.mediaElementAdapter !== undefined) {
                return new Xbox1ConvivaStreamerProxy(streamer);
            } else if (streamer.MbId !== undefined && streamer.blockedParams !== undefined) {
                return new ConvivaOoyalaStreamerProxy(streamer);
            } else if (streamer.mb !== undefined && (streamer.mb.MbId !== undefined && streamer.mb.blockedParams !== undefined)) {
                return new ConvivaOoyalaStreamerProxy(streamer.mb);

            } else {
                return streamer;
            }
        }

        defPubMeth(_s,"UpdateConnectionType",__updateConnectionType);
        function __updateConnectionType(type) /* : void */  {
            if (_s._networkInfo != null && type != null) {
                var newState /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
                var oldState /* : DictionaryCS(string, object) */ = null; //No old values available
                newState.SetValue("ct", type);
                _s.declareStateChange(newState, oldState);
            }
        }
        defPubMeth(_s,"UpdateSsid",__updateSsid);
        function __updateSsid(ssid) /* : void */  {
            if (_s._networkInfo != null && ssid != null) {
                var newState /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
                var oldState /* : DictionaryCS(string, object) */ = null; //No old values available
                newState.SetValue("ssid", ssid);
                _s.declareStateChange(newState, oldState);
            }
        }
        defPubMeth(_s,"UpdateSignalStrength",__updateSignalStrength);
        function __updateSignalStrength(ss) /* : void */  {
            if (_s._networkInfo != null && ss <= 0) {
                _s.buildDataSampleEvent();
            }
        }
        defPubMeth(_s,"UpdateLinkEncryption",__updateLinkEncryption);
        function __updateLinkEncryption(le) /* : void */  {
            if (_s._networkInfo != null && le != null) {
                var newState /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
                var oldState /* : DictionaryCS(string, object) */ = null; //No old values available
                newState.SetValue("le", le);
                _s.declareStateChange(newState, oldState);
            }
        }
        if(_s != STAT_INIT) _constr.apply(_s, arguments);
    }
statInit(Monitor,"Monitor");

// DO NOT EDIT! THIS FILE WAS GENERATED BY Slash from ../../csClient/CwsClient/session/EventQueue.cs
// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-



// namespace session
    function EventQueue() {
        var _s = this;
        //NOTE(henry): For speed, we implement _events as a native data
        // structure rather than a ListCS.
        if(_s != STAT_INIT) _s._events /* : ListCS(object) */ = null;
        if(_s != STAT_INIT) _s._nextSeqNumber /* : int */ = 0;

        function _constr() {
            _s._events = NativeLang.makeList();
        }

        defPubMeth(_s,"enqueueEvent",__enqueueEvent);
        function __enqueueEvent(type /* : String */, data /* : DictionaryCS(string, object) */, timeSinceSessionStart /* : int */) /* : void */  {
            data.SetValue("t", type);
            data.SetValue("st", timeSinceSessionStart);
            data.SetValue("seq", _s._nextSeqNumber);
            _s._nextSeqNumber++;
            NativeLang.addListValue(_s._events, Lang.StringDictionaryToRepr(data));
        }

        //NOTE(henry): Not really a DictionaryCS - native dictionary.
        defPubMeth(_s,"flushEvents",__flushEvents);
        function __flushEvents() /* : ListCS(object) */  {
            var currentEvents /* : ListCS(object) */ = _s._events;
            _s._events = NativeLang.makeList();
            return currentEvents;
        }
        if(_s != STAT_INIT) _constr.apply(_s, arguments);
    }
statInit(EventQueue,"EventQueue");

// DO NOT EDIT! THIS FILE WAS GENERATED BY Slash from ../../csClient/CwsClient/session/Session.cs
// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-



// namespace session
    function Session() {
        var _s = this;
        //@owner
        if(_s != STAT_INIT) _s._contentInfo /* : ConvivaContentInfo */ = null;
        if(_s != STAT_INIT) _s._networkInfo /* : NetworkInfo */ = null;
        // A copy of tags from _contentInfo, in native dictionary form for
        // faster encoding.
        if(_s != STAT_INIT) _s._nativeReprTags /* : Object */ = null;
        if(_s != STAT_INIT) _s._utils /* : Utils */ = null;
        if(_s != STAT_INIT) _s._settings /* : Settings */ = null;
        //@owner
        if(_s != STAT_INIT) _s._monitor /* : Monitor */ = null; // May be null for a non-video session
        //@owner
        if(_s != STAT_INIT) _s._eventQueue /* : EventQueue */ = null;

        if(_s != STAT_INIT) _s._clientIdWaiter /* : Function */ = null;
        if(_s != STAT_INIT) _s._heartbeatTimer /* : Cleanable */ = null;
        if(_s != STAT_INIT) _s._encodeHeartbeatTimer /* : Cleanable */ = null;

        // Whether we are sending logs. We keep this setting global because when
        // we send the first HB in the session we want to inherit the log-sending behavior.
        // This makes sense because the logs are accumulated and sent globally also.
        if(_s == STAT_INIT) Session._sendLogs /* : Boolean */ = false;

        if(_s != STAT_INIT) _s._sessionId /* : int */ = 0;

        if(_s != STAT_INIT) _s._startTimeMs /* : Number */ = 0;
        if(_s != STAT_INIT) _s._heartbeatSequenceNumber /* : int */ = 0;

        function _constr(streamer /* : Object */, contentInfo /* : ConvivaContentInfo */, options /* : Object */, global /* : Boolean */, networkInfo /* NetworkInfo */) {
            _s._contentInfo = contentInfo;
            _s._networkInfo = networkInfo;
            _s._utils = Utils.getInstance();
            _s._settings = _s._utils.getSettings();
            _s._sessionId = _s._utils.randInt();
            /* Some sanity checking for tags. The tags are represented as a native dictionary */
            var langTags /* : DictionaryCS(string, string) */ = Lang.DictionaryFromRepr/*string, string*/(_s._contentInfo.tags);
            var keysToCorrect /* : ListCS(string) */ = new ListCS/*string*/(); // Cannot modify the tags while iterating
            var _for_array_1 =  langTags.Keys;
            for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
              var tkey /* : String */ = _for_array_1[_for_idx_2];

                if(langTags.GetValue(tkey) == null) {
                    keysToCorrect.Add(tkey);
                }
            }
            var _for_array_3 =  keysToCorrect.Values;
            for(var _for_idx_4=0; _for_idx_4 < _for_array_3.length; _for_idx_4++) {
              var tkey1 /* : String */ = _for_array_3[_for_idx_4];

                _s.log("WARNING: correcting null value for tag "+tkey1);
                NativeLang.setDictValue/*string, string*/(_s._contentInfo.tags, tkey1, "null");
            }
            _s._nativeReprTags = Lang.StringDictionaryToRepr(_s._contentInfo.tags);

            _s._eventQueue = new EventQueue();

            if (!global) { // Global session does not have a monitor
                _s._streamer = streamer;//Keep track of streamer to get PHT for all events.
                _s._monitor = new Monitor(streamer, _s._eventQueue, _s._contentInfo, options, _s._sessionId, _s._networkInfo);
            }
        }

        defPubMeth(_s,"start",__start);
        function __start() /* : void */  {
            if (_s._monitor != null) {
                _s.log("Session.start(): assetName=" + _s._contentInfo.assetName);
            }
            _s._startTimeMs = _s._utils.epochTimeMs();
            if (_s._monitor != null) {
                _s._monitor.start(_s._startTimeMs);
            }
            _s._heartbeatSequenceNumber = 0;

            if (_s._utils.clientIdLoadingDone == null) {
                //we've got a client id, so send out heartbeat immediately
                _s.sendHeartbeat();
            } else {
                //we should always listen to clientIdAvailable in case that
                //the current client id is 0. The listener will be removed
                //in onClientIdAvailable once a valid client id is received
                _s._clientIdWaiter = _s.onClientIdLoaded;
                _s._utils.clientIdLoadingDone.AddHandler(_s._clientIdWaiter);
            }
            _s._heartbeatTimer = null;
            _s.resetHeartbeatTimer();
        }

        defPubMeth(_s,"cleanup",__cleanup);
        function __cleanup() /* : void */  {
            _s.log("Session.cleanup()" + _s.sessionTypeTag());
            if (_s._heartbeatTimer != null) {
                _s._heartbeatTimer.cleanup();
            }
            _s._heartbeatTimer = null;
            _s._utils.logSession("Schedule the last hb before session cleanup" + _s.sessionTypeTag(), _s._sessionId);

            // PD-10965: CWS 1.6 graceful session end, only for video sessions
            if (_s._monitor != null) {
                _s.enqueueSessionEndEvent();
            }

            var urgentHb /* : Object */ = _s.makeHeartbeat();
            if (urgentHb != null) {
                _s.encodeAndPostHeartbeat(urgentHb,
                    function () {
                        //cleanup the rest of the session
                        _s.cleanupAll();
                    });
            } else {
                //no hb to send
                _s.cleanupAll();
            }
        }

        defPrivMeth(_s,"enqueueSessionEndEvent",__enqueueSessionEndEvent);
        function __enqueueSessionEndEvent() /* : void */  {
            var eventData /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
            if(_s._streamer != null) {
                if(typeof(_s._streamer.GetPlayheadTimeMs) == "function" && _s._streamer.GetPlayheadTimeMs() >= 0) {
                    eventData.SetValue("pht", Math.round(_s._streamer.GetPlayheadTimeMs()));
                }
            }
            _s._eventQueue.enqueueEvent("CwsSessionEndEvent", eventData, slint.Cast(_s._utils.epochTimeMs() - _s._startTimeMs));
        }


        /// <summary>
        /// Suspend the accumulation of join time. Use, e.g., when an ad is starting and the time should not
        /// be counted as part of the join time.
        /// </summary>
        defPubMeth(_s,"pauseJoinTime",__pauseJoinTime);
        function __pauseJoinTime() /* : void */  {
            if (_s._monitor != null) {
                _s._monitor.pauseJoinTime();
            }
        }

        /// <summary>
        /// Resume the accumulation of join time.
        /// </summary>
        defPubMeth(_s,"resumeJoinTime",__resumeJoinTime);
        function __resumeJoinTime() /* : void */  {
            if (_s._monitor != null) {
                _s._monitor.resumeJoinTime(true);
            }
        }

        /// <summary>
        /// Suspend the accumulation of join time. Use, e.g., when an ad is starting and the time should not
        /// be counted as part of the join time.
        /// </summary>
        defPubMeth(_s,"adStart",__adStart);
        function __adStart() /* : void */  {
            // Currently makes sure we stop discounting ad time from join time.
            // Eventually it should send an ad event and let backend decide what to do with it.
            _s.pauseJoinTime();
        }

        /// <summary>
        /// Resume the accumulation of join time.
        /// </summary>
        defPubMeth(_s,"adEnd",__adEnd);
        function __adEnd() /* : void */  {
            // Currently makes sure we start discounting ad time from join time.
            // Eventually it should send an ad event and let backend decide what to do with it.
            _s.resumeJoinTime();
        }

        /// <summary>
        /// Pause monitoring and detach streamer
        /// Typically used for mid-roll advertisement
        /// </summary>
        defPubMeth(_s,"detachStreamer",__detachStreamer);
        function __detachStreamer() /* : void */  {
            _s._monitor.detachStreamer();
        }

        /// <summary>
        /// Resume monitoring if paused and attach new streamer
        /// </summary>
        defPubMeth(_s,"attachStreamer",__attachStreamer);
        function __attachStreamer(streamer /* : Object */) /* : void */  {
            _s._monitor.attachStreamer(streamer);
        }

        /* Restart the heartbeat timer using the current settings */
        defPrivMeth(_s,"resetHeartbeatTimer",__resetHeartbeatTimer);
        function __resetHeartbeatTimer() /* : void */  {
            if (_s._heartbeatTimer != null) {
                _s._heartbeatTimer.cleanup();
            }
            _s._heartbeatTimer = _s._utils.createTimer(_s.sendHeartbeat, _s._settings.heartbeatIntervalMs, "sendHeartbeat");
        }

        defPrivMeth(_s,"cleanupAll",__cleanupAll);
        function __cleanupAll() /* : void */  {
            if (_s._clientIdWaiter != null) {
                _s._utils.clientIdLoadingDone.DeleteHandler(_s._clientIdWaiter);
                _s._clientIdWaiter = null;
            }
            if (_s._monitor != null) {
                _s._monitor.cleanup();
                _s._monitor = null;
            }
            if (_s._encodeHeartbeatTimer != null) {
                _s._encodeHeartbeatTimer.cleanup();
                _s._encodeHeartbeatTimer = null;
            }
            if (_s._eventQueue != null) {
                _s._eventQueue.flushEvents();
                _s._eventQueue = null;
            }
            _s._contentInfo = null;
            _s._nativeReprTags = null;
            _s._settings = null;
            _s._utils = null;
        }

        defPrivMeth(_s,"log",__log);
        function __log(message /* : String */) /* : void */  {
            _s._utils.logSession(message, _s._sessionId);
        }

        // The API uses this to report StreamErrors
        defPubMeth(_s,"reportError",__reportError);
        function __reportError(err /* : StreamerError */) /* : void */  {
            _s.log("Session.reportError()");
            if (_s._monitor != null) {
                // Push to monitor
                _s._monitor.OnError(err);
            }
        }

        // The API uses this for manual bitrate reporting
        defPubMeth(_s,"setBitrate",__setBitrate);
        function __setBitrate(bitrateKbps /* : int */) /* : void */  {
            _s.log("Session.setBitrate(): bitrateKbps=" + bitrateKbps);
            if (_s._monitor != null) {
                _s._monitor.setBitrate(bitrateKbps);
            }
        }

        // The API uses this to update the stream metadata
        defPubMeth(_s,"setCurrentStreamMetadata",__setCurrentStreamMetadata);
        function __setCurrentStreamMetadata(metadata /* : Object */) /* : void */  {
            _s.log("Session.setCurrentStreamMetadata()");
            if (_s._monitor != null && _s._monitor.streamer != null) {
                // Push it directly into the proxy
                _s._monitor.streamer.SetMetadata(metadata);
            }
        }

        // The API uses this to update the mid-stream metadata
        defPubMeth(_s,"updateContentMetadata",__updateContentMetadata);
        function __updateContentMetadata(cci /* : ConvivaContentInfo <Object> */) /* : void */  {
            _s.log("Session.updateContentMetadata()");
            if (_s._monitor != null && _s._monitor.streamer != null) {
                var newState /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
                var oldState /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();

                //Clone already existing content info - assetName & tags for Q1-2017 release.
                var oldCci={};
                var makeStrMetadata = false;//Flag used to check if there are changes in string-string metadata to construct "strMetadata" in HB
                oldCci.assetName = _s._contentInfo.assetName;
                oldCci.streamUrl = _s._contentInfo.streamUrl;
                oldCci.defaultReportingCdnName = _s._contentInfo.defaultReportingCdnName;
                oldCci.defaultReportingResource = _s._contentInfo.defaultReportingResource;
                oldCci.viewerId = _s._contentInfo.viewerId;
                oldCci.playerName = _s._contentInfo.playerName;
                oldCci.isLive = _s._contentInfo.isLive;
                oldCci.duration = _s._contentInfo.duration;
                oldCci.encodedFps = _s._contentInfo.encodedFps;

                //Javascript "=" operator passes object reference so, every value needs to be assigned to the new object instead of directly assigning.
                //Loop through each tag and assign to oldCci
                oldCci.tags = {};
                for(var key in _s._contentInfo.tags) {
                    oldCci.tags[""+key] = _s._contentInfo.tags[""+key];
                }

                //Update if there is a change in assetName
                if(cci.assetName != null && oldCci.assetName != cci.assetName) {
                    oldState.SetValue("an", oldCci.assetName);
                    newState.SetValue("an", cci.assetName);
                    _s._contentInfo.assetName = cci.assetName;
                }

                //Update if there is a change in streamUrl
                if(cci.streamUrl != null && oldCci.streamUrl != cci.streamUrl) {
                    oldState.SetValue("url", oldCci.streamUrl);
                    newState.SetValue("url", cci.streamUrl);
                    _s._contentInfo.streamUrl = cci.streamUrl;
                    _s._monitor._externalStreamUrlReporting = true;
                }

                //Update if there is a change in cdnName & Resource.
                if(cci.defaultReportingCdnName != null || cci.defaultReportingResource != null) {
                    var newStream /* : StreamInfo */ = new StreamInfo(-2, cci.defaultReportingCdnName, cci.defaultReportingResource, -1, -1, -1);
                    if (_s._monitor != null) {
                        _s._monitor.SetStream(newStream);
                        if(oldCci.defaultReportingCdnName != cci.defaultReportingCdnName) {
                            _s._contentInfo.defaultReportingCdnName = cci.defaultReportingCdnName;
                        }
                        if(oldCci.defaultReportingResource != cci.defaultReportingResource) {
                            _s._contentInfo.defaultReportingResource = cci.defaultReportingResource;
                        }
                    }
                }

                //For fields not part of cwsStateChangeEvent, send them part of convivatags in HB.
                //Only covers fields that have a "String" to "string" key value pairs. (viewerId & PlayerName)
                var oldStrMetadataHb = {};
                var newStrMetadataHb = {};
                if(cci.viewerId != null && oldCci.viewerId != cci.viewerId) {
                    makeStrMetadata = true;
                    oldStrMetadataHb.vid = oldCci.viewerId;
                    newStrMetadataHb.vid = cci.viewerId;
                    _s._contentInfo.viewerId = cci.viewerId;
                }
                if(cci.playerName != null && oldCci.playerName != cci.playerName) {
                    makeStrMetadata = true;
                    oldStrMetadataHb.pn = oldCci.playerName;
                    newStrMetadataHb.pn = cci.playerName;
                    _s._contentInfo.playerName = cci.playerName;
                }

                //Construct strMetadata Dict in HB with changes in viewerId & playerName
                if(makeStrMetadata) {
                    oldState.SetValue("strmetadata", oldStrMetadataHb);
                    newState.SetValue("strmetadata", newStrMetadataHb);
                }

                //For fields not part of cwsStateChangeEvent & not "string" to "string" key value pairs. (isLive, Duration & encodedFps) Send them as individual fields in statechangeEvent

                //isLive is defaulted to false if null is set.
                console.log("live value is", cci.isLive);
                if(oldCci.isLive != cci.isLive) {
                    oldState.SetValue("lv", oldCci.isLive);
                    newState.SetValue("lv", cci.isLive);
                    _s._contentInfo.isLive = cci.isLive;

                }

                //Duration & encodedFps is defaulted to -1 if null is set or no value is set
                if(cci.duration != -1 || cci.encodedFps != -1) {
                    var curStrMetadata = {};
                    if(oldCci.duration != cci.duration && cci.duration != -1) {
                        oldState.SetValue("cl", oldCci.duration);
                        newState.SetValue("cl", cci.duration);
                        _s._contentInfo.duration = cci.duration;
                        _s._monitor._contentLengthSec = slint.Cast(_s._utils.parseNumber(cci.duration, -1));
                        _s._monitor._externalDurationReporting = true;
                        curStrMetadata.duration = cci.duration;
                    }
                    if(oldCci.encodedFps != cci.encodedFps && cci.encodedFps != -1) {
                        oldState.SetValue("efps", oldCci.encodedFps);
                        newState.SetValue("efps", cci.encodedFps);
                        _s._contentInfo.encodedFps = cci.encodedFps;
                        _s._monitor._encodedFps = slint.Cast(_s._utils.parseNumber(cci.encodedFps, -1));
                        _s._monitor._externalFpsReporting = true;
                        curStrMetadata.framerate = cci.encodedFps;//current stream metadata expects encodedFps to be set in "framerate" key
                    }
                    _s.setCurrentStreamMetadata(curStrMetadata);
                }


                //Check if new tags are set and replace old ones.
                if(cci.tags) {
                    /* Some sanity checking for tags. The tags are represented as a native dictionary */
                    var langTags /* : DictionaryCS(string, string) */ = Lang.DictionaryFromRepr/*string, string*/(cci.tags);

                    //Correct the tags dictionary in case of errors.
                    var keysToCorrect /* : ListCS(string) */ = new ListCS/*string*/(); // Cannot modify the tags while iterating
                    var _for_array_1 = langTags.Keys;
                    for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
                      var tkey /* : String */ = _for_array_1[_for_idx_2];

                        if(langTags.GetValue(tkey) == null) {
                            keysToCorrect.Add(tkey);
                        }
                    }
                    var _for_array_3 =  keysToCorrect.Values;
                    for(var _for_idx_4=0; _for_idx_4 < _for_array_3.length; _for_idx_4++) {
                      var tkey1 /* : String */ = _for_array_3[_for_idx_4];

                        _s.log("WARNING: correcting null value for tag "+tkey1);
                        NativeLang.setDictValue/*string, string*/(cci.tags, tkey1, "null");
                    }

                    //Check for changed values, otherwise append new tags to old.
                    langTags /* : DictionaryCS(string, string) */ = Lang.DictionaryFromRepr/*string, string*/(cci.tags);
                    //Collect keys to check
                    var keysToCheck = langTags.Keys;
                    var valuesToCheck = langTags.Values;

                    for(var keyIndex=0; keyIndex < keysToCheck.length; keyIndex++) {
                      var tagKey /* : String */ = keysToCheck[keyIndex];
                        //update/append the tag to old tags
                        _s._contentInfo.tags[tagKey] = valuesToCheck[keyIndex];
                    }

                    //Update tags
                    //Update tags only if there is any change
                    if (JSON.stringify(_s._contentInfo.tags) != JSON.stringify(oldCci.tags)) {
                        _s._nativeReprTags = Lang.StringDictionaryToRepr(_s._contentInfo.tags);
                        oldState.SetValue("tags", oldCci.tags);
                        newState.SetValue("tags", cci.tags);
                    }
                }

                //Fire state change event
                var data /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
                var newStateNative = Lang.StringDictionaryToRepr(newState);
                var oldStateNative = Lang.StringDictionaryToRepr(oldState);
                data.SetValue("new", newStateNative);
                if (oldState != null) {
                    data.SetValue("old", oldStateNative);
                }
                if(_s._streamer) {
                    if(typeof(_s._streamer.GetPlayheadTimeMs) == "function" && _s._streamer.GetPlayheadTimeMs() >= 0) {
                        data.SetValue("pht", Math.round(_s._streamer.GetPlayheadTimeMs()));
                    }
                }
                _s._eventQueue.enqueueEvent("CwsStateChangeEvent", data, slint.Cast(_s._utils.epochTimeMs() - _s._startTimeMs));
                //Update Monitor's content info
                _s._monitor._contentInfo = _s._contentInfo;
            }
        }

        defPubMeth(_s,"setCdnNameOrResource",__setCdnNameOrResource);
        function __setCdnNameOrResource(resource /* : String */) /* : void */  {
            _s.log("Session.setCdnNameOrResource()");
            if (_s._monitor != null) {
                var newStream /* : StreamInfo */ = new StreamInfo(-2, resource, resource, -1, -1, -1);
                _s._monitor.SetStream(newStream);
            }
        }

        defPubMeth(_s,"sendSeekEvent",__sendSeekEvent);
        function __sendSeekEvent(actType /* : LivePass.SEEK_ACTIONS_TYPE */, seekToPos /* : int */) /* : void */  {
            if (_s._monitor != null) {
                _s.log("Session.sendSeekEvent()");
                var eventData = new DictionaryCS();
                eventData.SetValue("act", actType);
                if(seekToPos >= 0) {
                    eventData.SetValue("skto", seekToPos);
                }
                _s._monitor.OnSeekEvent(eventData);
            }
        }

        defPubMeth(_s,"sendCustomEvent",__sendCustomEvent);
        function __sendCustomEvent(name /* : String */, eventAttrs /* : DictionaryCS(string, object) */) /* : void */  {
            _s.log("Session.sendEvent(): eventName=" + name + _s.sessionTypeTag());
            var eventData /* : DictionaryCS(string, object) */ = new DictionaryCS/*<string, object>*/();
            eventData.SetValue("name", name);
            // We construct a native dictionary for the attributes
            var eventAttrsNative = Lang.StringDictionaryToRepr(eventAttrs);

            eventData.SetValue("attr", eventAttrsNative);
            if(_s._streamer) {
                if(typeof(_s._streamer.GetPlayheadTimeMs) == "function" && _s._streamer.GetPlayheadTimeMs() >= 0) {
                    eventData.SetValue("pht", Math.round(_s._streamer.GetPlayheadTimeMs()));
                }
            }
            _s._eventQueue.enqueueEvent("CwsCustomEvent", eventData, slint.Cast(_s._utils.epochTimeMs() - _s._startTimeMs));
        }

        defPrivMeth(_s,"sendHeartbeat",__sendHeartbeat);
        function __sendHeartbeat() /* : void */  {
            var heartbeat /* : Object */ = null;
            if (_s._encodeHeartbeatTimer != null) {
                _s._encodeHeartbeatTimer.cleanup();
            }
            _s._encodeHeartbeatTimer = _s._utils.scheduleAction(
                function () {
                    heartbeat = _s.makeHeartbeat();
                    if (heartbeat != null) {
                        _s._encodeHeartbeatTimer = _s._utils.scheduleAction(
                            function () {
                                _s.encodeAndPostHeartbeat(heartbeat, null);
                                _s._encodeHeartbeatTimer = null;
                            }, 1, "encodeAndSendHeartbeat");
                    }
                }, 1, "makeHeartbeat");
        }

        //NOTE(henry): Not really a DictionaryCS - a native dictionary.  Any
        // structures contained in the heartbeat are also native.  This is the
        // simplest and fastest way to ensure that the Slash data structures
        // are not actually encoded when it is time to convert the heartbeat to
        // JSON.  However, it means that this object cannot be interacted with
        // after its creation, except by the JSON encoder.
        defPrivMeth(_s,"makeHeartbeat",__makeHeartbeat);
        function __makeHeartbeat() /* : Object */  {
            var heartbeat = {};
            NativeLang.setDictValue(heartbeat, "t", "CwsSessionHb");
            NativeLang.setDictValue(heartbeat, "cid", _s._settings.customerKey);
            NativeLang.setDictValue(heartbeat, "clid", _s._utils.clientId);
            NativeLang.setDictValue(heartbeat, "sid", _s._sessionId);
            NativeLang.setDictValue(heartbeat, "seq", _s._heartbeatSequenceNumber);
            NativeLang.setDictValue(heartbeat, "pver", _s._settings.protocolVersion);
            NativeLang.setDictValue(heartbeat, "clv", _s._settings.clientVersion);
            NativeLang.setDictValue(heartbeat, "iid", _s._settings.clientInstanceId);
            var platformMetadata /* : Object */ = Lang.StringDictionaryToRepr/*string*/(_s._settings.platformApi.getPlatformMetadata());
            if (platformMetadata != null) {
                NativeLang.setDictValue(heartbeat, "pm", platformMetadata);
            }
            if (_s._contentInfo.viewerId != null) {
                NativeLang.setDictValue(heartbeat, "vid", _s._contentInfo.viewerId);
            }
            if (_s._contentInfo.streamUrl != null) {
                NativeLang.setDictValue(heartbeat, "url", _s._contentInfo.streamUrl);
            }
            if (_s._contentInfo.playerName != null) {
                NativeLang.setDictValue(heartbeat, "pn", _s._contentInfo.playerName);
            }
            NativeLang.setDictValue(heartbeat, "tags", _s._nativeReprTags);
            // Call the monitor.updateHeartbeat before we package the events
            if (_s._monitor != null) {
                NativeLang.setDictValue(heartbeat, "an", _s._contentInfo.assetName);
                NativeLang.setDictValue(heartbeat, "lv", _s._contentInfo.isLive);
                _s._monitor.updateHeartbeat(heartbeat);
            } else {
                // Global session
                NativeLang.setDictValue(heartbeat, "sf", 0);
	    }
            // always set to 0 for Insights
            NativeLang.setDictValue(heartbeat, "caps", 0);

            var currentEvents /* : ListCS(object) */ = _s._eventQueue.flushEvents();
            NativeLang.setDictValue(heartbeat, "evs", currentEvents);
            // If this is a global session, with no events, suppress this HB
            // Do this check before we consume the logs, or increase the heartbeatSequenceNumber
            if (_s._monitor == null && NativeLang.listCount(currentEvents) == 0) {
                return null;
            }

            if (Session._sendLogs) {
                NativeLang.setDictValue(heartbeat, "lg", Lang.ListToRepr/*string*/(_s._utils.getLogs(_s._sessionId)));
            }
            // Put the timestamps last
            var currentTime /* : Number */ = _s._utils.epochTimeMs(); // base "st" and "cts" on the same timestamp value to be consistent
            NativeLang.setDictValue(heartbeat, "st", slint.Cast(currentTime - _s._startTimeMs));
            NativeLang.setDictValue(heartbeat, "sst", _s._startTimeMs);
            _s._heartbeatSequenceNumber++;
            return heartbeat;
        }

        defPrivMeth(_s,"sessionTypeTag",__sessionTypeTag);
        function __sessionTypeTag() /* : String */  {
            if (_s._monitor == null)
                return " (global session)";
            return "";
        }

        /* Encode and POST a heartbeat asynchronously.
         * afterPostCbk - callback to call after encoding and posting
         */
        defPrivMeth(_s,"encodeAndPostHeartbeat",__encodeAndPostHeartbeat);
        function __encodeAndPostHeartbeat(heartbeat /* : Object */, afterPostCbk /* : Function */) /* : void */  {
            var jsonHeartbeat /* : String */ = _s._utils.jsonEncode(heartbeat);
            var url /* : String */ = _s._settings.gatewayUrl + _s._settings.gatewayPath;
            var contentType /* : String */ = "application/json";
            _s.log("Send HB[" + (_s._heartbeatSequenceNumber - 1) + "]" + _s.sessionTypeTag());
            _s._utils.httpRequest(true, url, jsonHeartbeat, contentType, _s.onHeartbeatResponse);
            if (afterPostCbk != null) {
                afterPostCbk();
            }
        }



        defPrivMeth(_s,"onHeartbeatResponse",__onHeartbeatResponse);
        function __onHeartbeatResponse(isSuccess /* : Boolean */, jsonResponse /* : String */) /* : void */  {
            if (_s._utils != null) {
                _s._utils.runProtected(
                    function () {
                        if (isSuccess) {
                            var decodedResponse /* : DictionaryCS(string, object) */ = _s._utils.jsonDecode(jsonResponse);
                            if (decodedResponse != null) {
                                if (decodedResponse.ContainsKey("clid")) {
                                    _s._utils.setClientIdFromServer(Lang.ToString((decodedResponse.GetValue("clid"))), false);
                                }
                                var cfg = decodedResponse.GetValue("cfg");
                                var newSendLogs /* : Boolean */ = (cfg.slg && Boolean(cfg.slg));
                                if (newSendLogs != Session._sendLogs) {
                                    _s.log("Turning " + (newSendLogs ? "on" : "off") +" sending of logs");
                                    Session._sendLogs = newSendLogs;
                                }
                                if (cfg.hbi) {
                                    var heartbeatIntervalSec /* : int */ = slint.Cast(cfg.hbi);
                                    if(1000 * heartbeatIntervalSec !=  _s._settings.heartbeatIntervalMs) {
                                         _s.log("Received hbInterval from server " + heartbeatIntervalSec);
                                         _s._settings.heartbeatIntervalMs = 1000 * heartbeatIntervalSec;
                                         if (_s._heartbeatTimer != null) {
                                              _s.resetHeartbeatTimer();
                                         }
                                    }
                                }
                                if (cfg.gw) {
                                    var gatewayUrl /* : String */ =  (cfg.gw);
                                    if(gatewayUrl != _s._settings.gatewayUrl) {
                                        _s.log("Received gatewayUrl from server "+gatewayUrl);
                                        _s._settings.gatewayUrl = gatewayUrl;
                                    }
                                }
                            } else {
                                _s.log("Decoded heartbeat response is null.");
                            }
                        } else {
                            _s.log("Received no response (or a bad response) to heartbeat POST request.");
                        }
                    }, "onHeartbeatResponse");
            }
        }

        defPrivMeth(_s,"onClientIdLoaded",__onClientIdLoaded);
        function __onClientIdLoaded() /* : void */  {
            // This is fired on loading of the clientId from the local storage
            _s._utils.clientIdLoadingDone.DeleteHandler(_s._clientIdWaiter);
            _s._clientIdWaiter = null;
            _s.sendHeartbeat();
        }

        defPubMeth(_s,"initialResourceBitrateSelection",__initialResourceBitrateSelection);
        function __initialResourceBitrateSelection() /* : void */  {
            var proxy /* : ConvivaStreamerProxy */ = _s._monitor.streamer;
            throw new Error("Not implemented");
        }

        defPubMeth(_s,"midStreamResourceBitrateSelection",__midStreamResourceBitrateSelection);
        function __midStreamResourceBitrateSelection(switchTriggers /* : String */) /* : void */  {
            // TODO: get the target stream
            throw new Error("Not implemented");
        }
        defPubMeth(_s,"setConnectionType",__setConnectionType);
        function __setConnectionType(connectionType /* : String */) /* : void */  {
            if(_s._monitor != null) {
                _s._monitor.UpdateConnectionType(connectionType);
            }
        }
        defPubMeth(_s,"setSsid",__setSsid);
        function __setSsid(ssid /* : String */) /* : void */  {
            if(_s._monitor != null) {
                _s._monitor.UpdateSsid(ssid);
            }
        }
        defPubMeth(_s,"setSignalStrength",__setSignalStrength);
        function __setSignalStrength(ss /* : double */) /* : void */  {
            if(_s._monitor != null) {
                _s._monitor.UpdateSignalStrength(ss);
            }
        }
        defPubMeth(_s,"setLinkEncryption",__setLinkEncryption);
        function __setLinkEncryption(le /* : String */) /* : void */  {
            if(_s._monitor != null) {
                _s._monitor.UpdateLinkEncryption(le);
            }
        }
        if(_s != STAT_INIT) _constr.apply(_s, arguments);
    }
statInit(Session,"Session");// DO NOT EDIT! THIS FILE WAS GENERATED BY Slash from ../../csClient/CwsClient/session/SessionFactory.cs
// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-



// namespace session
    /** A factory for Session objects. */
    function SessionFactory() {
        var _s = this;
        if(_s != STAT_INIT) _s.lastSessionId /* : int */ = 0;

        if(_s != STAT_INIT) _s._utils /* : Utils */ = null;
        if(_s != STAT_INIT) _s._settings /* : Settings */ = null;
        if(_s != STAT_INIT) _s._nextSessionId /* : int */ = 0; // Should be positive
        if(_s != STAT_INIT) _s._sessionsById /* : DictionaryCS(int, Session) */ = null;

        function _constr() {
            _s._utils = Utils.getInstance();
            _s._settings = _s._utils.getSettings();
            _s._nextSessionId = 0;
            _s._sessionsById = new DictionaryCS/*<int, Session>*/();
            _s.lastSessionId = 0;
        }

        defPubMeth(_s,"cleanup",__cleanup);
        function __cleanup() /* : void */  {
            _s._utils = null;
            _s._settings = null;
            if (_s._sessionsById != null) {
                var _for_array_1 =  _s._sessionsById.KeyValuePairs;
                for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
                  var sessionPair /* : KeyValuePairCS */ = _for_array_1[_for_idx_2];

                    var sess /* : Session */ = sessionPair.Value;
                    sess.cleanup();
                }
            }
            _s._sessionsById = null;
            _s._nextSessionId = 0;
        }

        // Generate a new session id
        defPubMeth(_s,"newSessionId",__newSessionId);
        function __newSessionId() /* : int */  {
            var sessionId /* : int */ = _s._nextSessionId;
            _s._nextSessionId++;
            return sessionId;
        }

        defPubMeth(_s,"makeSession",__makeSession);
        function __makeSession(streamer /* : Object */, contentInfo /* : ConvivaContentInfo */, options /* : Object */, sessionId /* : int */, global /* : Boolean */, networkInfo /* NetworkInfo */) /* : Session */  {
            var session /* : Session */ = new Session(streamer, contentInfo, options, global, networkInfo);
            _s.addSession(sessionId, session);
            _s.lastSessionId = sessionId;
            session.start();
            return session;
        }

        defPubMeth(_s,"getSession",__getSession);
        function __getSession(sessionId /* : int */) /* : Session */  {
            if (_s._sessionsById.ContainsKey(sessionId)) {
                return _s._sessionsById.GetValue(sessionId);
            }
            if (sessionId == -1) { // default sessionId.
                _s._utils.err("LivePass: invalid sessionId. LivePass not properly initialized yet?");
            } else { // session that has already been cleaned up most likely.
                _s._utils.err("LivePass: invalid sessionId. Did you cleanup that session previously?");
            }
            return null;
        }

        defPubMeth(_s,"addSession",__addSession);
        function __addSession(sessionId /* : int */, session /* : Session */) /* : void */  {
            _s._sessionsById.SetValue(sessionId, session);
        }

        defPubMeth(_s,"removeSession",__removeSession);
        function __removeSession(sessionId /* : int */) /* : void */  {
            _s._sessionsById.Remove(sessionId);
        }

        defPubMeth(_s,"cleanupSession",__cleanupSession);
        function __cleanupSession(sessionId /* : int */) /* : void */  {
            var session /* : Session */ = _s.getSession(sessionId);
            if (session != null) {
                _s.removeSession(sessionId);
                session.cleanup();
            }
        }
        if(_s != STAT_INIT) _constr.apply(_s, arguments);
    }
statInit(SessionFactory,"SessionFactory");

// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-
// Copyright Conviva Inc 2010
// Author: George Necula (necula@conviva.com)

function ArrayCS() {
    var _s = this;

    if(_s != STAT_INIT) _s.arr = undefined;
    function _constr(size) {
        if(size == undefined) size = 0;
        _s.arr = new Array(size);
    }

    defStatMeth(_s,ArrayCS,"Create",__Create);
    function __Create() {
        var res = new ArrayCS();
        var l = [ ];
        // it seems that we have to copy the arguments array instead
        // of using it directly
        for (var i = 0; i < arguments.length; i++) {
            l.push(arguments[i]);
        }
        res.arr = l;
        return res;
    }

    defStatMeth(_s,ArrayCS,"FromRepr",__FromRepr);
    function __FromRepr(a) {
        if (a == null) return null;
        var res = new ArrayCS();
        res.arr = a;
        return res;
    }

    defPubMeth(_s,"ToRepr",__ToRepr);
    function __ToRepr() {
        return _s.arr;
    }


    defGet(_s,"Length",__Length);
    function __Length() {
        return _s.arr.length;
    }


    defPubMeth(_s,"GetValue",__GetValue);
    function __GetValue(idx) {
        if(idx >= _s.arr.length) {
            throw new Error("Index out of bounds: "+idx+" (length "+_s.arr.length+")");
        } else if(idx < 0) {
            throw new Error("Index out of bounds: "+idx);
        }
        return _s.arr[idx];
    }

    defPubMeth(_s,"SetValue",__SetValue);
    function __SetValue(idx, v) {
        if(idx >= _s.arr.length) {
            throw new Error("Index out of bounds: "+idx+" (length "+_s.arr.length+")");
        } else if(idx < 0) {
            throw new Error("Index out of bounds: "+idx);
        }
        _s.arr[idx] = v;
    }

    defGet(_s,"Values",__Values);
    function __Values() {
        return _s.arr;
    }

    if(_s != STAT_INIT) _constr.apply(this, arguments);

}
statInit(ArrayCS,"ArrayCS");

// DO NOT EDIT! THIS FILE WAS GENERATED BY Slash from ../../csClient/CwsClient/utils/Cleanable.cs
// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-

// Copyright (c) 2011, 2012 Conviva Inc. All Rights Reserved.
// Author: George Necula (necula@conviva.com), Henry Milner (henry@conviva.com), Yan Li (yan@conviva.com)



// namespace utils
    /// <summary>
    /// A class to manage cleanable objects. A Cleanable object is a wrapper for a cleanup Action,
    /// along with management of a collection of Cleanables.
    /// </summary>
    function Cleanable() {
        var _s = this;

        // The actual cleanup action
        if(_s != STAT_INIT) _s._cleanupAction /* : Function */ = null;

        // Each Cleanable is stored in a collection, indexed by its unique id
        if(_s == STAT_INIT) Cleanable._nextCleanupId /* : int */ = 0;
        if(_s != STAT_INIT) _s._id /* : int */ = 0;
        if(_s != STAT_INIT) _s._cleanupCollection /* : DictionaryCS(int, Cleanable) */ = null;

        // Construct a cleanable object, and add it to a collection of Cleanables
        function _constr(cleanupCollection /* : DictionaryCS(int, Cleanable) */) {
            _s._cleanupCollection = cleanupCollection;
            _s._id = Cleanable._nextCleanupId;
            Cleanable._nextCleanupId++;
            _s._cleanupCollection.SetValue(_s._id, _s);
        }

        defPubMeth(_s,"setCleanupAction",__setCleanupAction);
        function __setCleanupAction(cleanupAction /* : Function */) /* : void */  {
            _s._cleanupAction = cleanupAction;
        }


        /// <summary>
        /// Cleanup the object
        /// </summary>
        defPubMeth(_s,"cleanup",__cleanup);
        function __cleanup() /* : void */  {
            if (_s._cleanupAction != null) {
                _s._cleanupAction();
            }
            _s._cleanupCollection.Remove(_s._id);
        }



        /// <summary>
        /// Cleanup an entire collection
        /// </summary>
        /// <param name="collection"></param>
        defStatMeth(_s,Cleanable,"cleanupCollection",__cleanupCollection);
        function __cleanupCollection(collection /* : DictionaryCS(int,Cleanable) */) /* : void */  {
            // Copy first the cleanable objects
            Utils.getInstance().log("cleanupCollection");
            var toClean /* : ListCS(Cleanable) */ = new ListCS/*Cleanable*/ ();
            var _for_array_1 =  collection.Values;
            for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
              var o /* : Cleanable */ = _for_array_1[_for_idx_2];

                toClean.Add(o);
            }
            var _for_array_3 =  toClean.Values;
            for(var _for_idx_4=0; _for_idx_4 < _for_array_3.length; _for_idx_4++) {
              var o /* : Cleanable */ = _for_array_3[_for_idx_4];

                o.cleanup ();
            }
            collection.Clear();
        }

        if(_s != STAT_INIT) _constr.apply(_s, arguments);
    }
statInit(Cleanable,"Cleanable");

// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-
// Copyright Conviva Inc 2010
// Author: George Necula (necula@conviva.com)

function DictionaryCS() {
    var _s = this;

    if(_s != STAT_INIT) _s.obj = undefined;
    function _constr(size) {
        _s.obj = { };
    }

    defStatMeth(_s,DictionaryCS,"FromRepr",__FromRepr);
    function __FromRepr(o) {
        if(o == null) return null;
        if(o instanceof DictionaryCS) {
            return o;
        }
        if(o.hasOwnProperty(__id("ToObject"))) { // It is a DictionaryCS from the module
            o = o.ToObject ();
        }
        var res = new DictionaryCS ();
        // It must be an Object
        slForEachProp(o, function (k) {
            res.obj[k] = o[k];
        });
        return res;
    }

    defPubMeth(_s,"ToObject",__ToObject);
    function __ToObject() {
        return _s.obj;
    }

    // Create a dictionary from a string of key, values, key ...
    defStatMeth(_s,DictionaryCS,"Create",__Create);
    function __Create() {
        var res = new DictionaryCS ();
        for(var i = 0; i + 1 < arguments.length; i += 2) {
            res.obj[arguments[i]] = arguments[i + 1];
        }
        return res;
    };

    /* Copy a dictionary to an object. Fails if called on a dictionary whose keys are not string */
    defPubMeth(_s,"CopyToObject",__CopyToObject);
    function __CopyToObject(obj) {
        slForEachProp(_s.obj, function (k) {
                obj[k] = _s.obj[k];
            });
    }

    defPubMeth(_s,"GetValue",__GetValue);
    function __GetValue (key) {
        return _s.obj[key];
    }

    defPubMeth(_s,"SetValue",__SetValue);
    function __SetValue (key, v) {
        _s.obj[key] = v;
    }

        /* Dictionary<>.Clear () */
    defPubMeth(_s,"Clear",__Clear);
    function __Clear( ) {
        slForEachProp(_s.obj, function (p) {
                delete _s.obj[p];
            });
    }

    /* Dictionary<>.ContainsKey */
    defPubMeth(_s,"ContainsKey",__ContainsKey);
    function __ContainsKey( key ) {
        return (_s.obj[key] !== undefined);
    }

    defPubMeth(_s,"Contains",__Contains);
    function __Contains( key ) {
        return ContainsKey(key);
    }

    /* Dictionary<>.Keys  is the collection of Keys, represented as KeyCollection */
    defGet(_s,"Keys",__Keys);
    function __Keys () {
        var res = new Array ();
        slForEachProp(_s.obj, function (p) {
                res.push(p);
            });
        return res;
    }

    /* Dictionary<>.Values  is the collection of values */
    defGet(_s,"Values",__Values);
    function __Values () {
        var res = new Array ();
        slForEachProp(_s.obj, function (p) {
                res.push(_s.obj[p]);
            });
        return res;
    }


    defGet(_s,"KeyValuePairs",__KeyValuePairs);
    function __KeyValuePairs () {
        var res = new Array ();
        slForEachProp(_s.obj, function (p) {
                res.push( new KeyValuePairCS( p, _s.obj[p] ));
            });
        return res;
    }


    defGet(_s,"Count",__Count);
    function __Count () {
        var res = 0;
        slForEachProp(_s.obj, function (p) {
                res ++;
            });
        return res;
    }


    /** Dictionary<>.Add: add an item */
    defPubMeth(_s,"Add",__SetValue);

        /** Dictionary<>.Remove: delete an item, return if removed */
    defPubMeth(_s,"Remove",__Remove);
    function __Remove(key) {
        if(_s.ContainsKey(key)) {
            delete _s.obj[key];
            return true;
        } else
            return false;
    }

    if(_s != STAT_INIT) _constr.apply(this, arguments);

}
statInit(DictionaryCS,"DictionaryCS");

// DO NOT EDIT! THIS FILE WAS GENERATED BY Slash from ../../csClient/CwsClient/utils/Eventer.cs
// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-

// Copyright (c) 2009, Conviva Inc. All Rights Reserved.
// Author: George Necula (necula@conviva.com)

// namespace utils
    // The type of an event dispatcher with event handlers
    function Eventer() {
        var _s = this;
        if(_s != STAT_INIT) _s._handlers /* : ListCS(Action) */ = undefined;

        function _constr() {
            _s._handlers = new ListCS/*Action*/();
        }

        /// <summary>
        /// Deletes all event handlers
        /// </summary>
        defPubMeth(_s,"Cleanup",__Cleanup);
        function __Cleanup() /* : void */  {
            _s._handlers = new ListCS/*Action*/();
        }

        defPubMeth(_s,"AddHandler",__AddHandler);
        function __AddHandler(handler /* : Function */) /* : void */  {
            _s._handlers.Add(handler);
        }

        defPubMeth(_s,"DeleteHandler",__DeleteHandler);
        function __DeleteHandler(handler /* : Function */) /* : void */  {
            _s._handlers.Remove(handler);
        }

        defPubMeth(_s,"DispatchEvent",__DispatchEvent);
        function __DispatchEvent() /* : void */  {
            var _for_array_1 =  _s._handlers.Values;
            for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
              var h /* : Function */ = _for_array_1[_for_idx_2];

                h();
            }
        }
        if(_s != STAT_INIT) _constr.apply(_s, arguments);
    }
statInit(Eventer,"Eventer");

// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-
// Copyright Conviva Inc 2010
// Author: George Necula (necula@conviva.com)

function KeyValuePairCS() {
    var _s = this;

    if(_s != STAT_INIT) _s.key = undefined;
    if(_s != STAT_INIT) _s.val = undefined;
    function _constr(key, val) {
        _s.key = key;
        _s.val = val;
    }


    defGet(_s,"Key",__Key);
    function __Key() {
        return _s.key;
    }

    defGet(_s,"Value",__Value);
    function __Value() {
        return _s.val;
    }
    if(_s != STAT_INIT) _constr.apply(this, arguments);

}
statInit(KeyValuePairCS,"KeyValuePairCS");

// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-
// Copyright Conviva Inc 2010
// Author: George Necula (necula@conviva.com)

function Lang() {
    Lang.StringIndexOf = function (s1, s2) {
        return s1.indexOf(s2);
    };

    Lang.StringStartsWith = function (s1, s2) {
        return (0 == s1.indexOf(s2));
    };

    Lang.StringContains = function (s1, s2) {
        return (0 <= s1.indexOf(s2));
    };

    Lang.StringGetChar = function (s, where) {
        if(where < 0 || where >= s.length) {
            throw new Error("ArgumentOutOfRange");
        }
        return s[where];
    };

    Lang.StringSubstring = function (str, startIndex, count) {
        if(startIndex < 0 || startIndex >= str.length || (count != undefined && (count < 0 || startIndex + count > str.length))) {
            throw new Error("ArgumentOutOfRange");
        }
        if(count == undefined) {
            return str.substr(startIndex);
        } else {
            return str.substr(startIndex, count);
        }
    };

    Lang.StringSplit = function (s1, sep) {
        var res = s1.split(sep);
        return ArrayCS.FromRepr(res);
    };

    Lang.StringEnumerator = function (s) {
        return s.split("");
    };

    Lang.StringCompareTo = function (str1, str2) {
        if(str1 == null) {
            if(str2 == null) return 0;
            return -1;
        }
        if(str2 == null) return 1;
        // both are non-null
        if(str1 < str2) return -1;
        if(str1 == str2) return 0;
        return 1;
    };

    Lang.StringTrim = function (s) {
        return s.replace(/^\s*/, "").replace(/\s*$/, "");
    };

    Lang.StringReplace = function (str1, strsearch, strreplace) {//NO_RENAME:substr,indexOf,length
        if(strsearch == null || strsearch == "" || strreplace == null) {
            throw new Error("InvalidArgument");
        }
        // We cannot use replace because we want to replace all occurrences
        var searchIdx = str1.indexOf(strsearch);
        if (searchIdx >= 0) {
            var searchLen = strsearch.length;
            // We have at least one occurrence
            return str1.substr(0, searchIdx) + strreplace + Lang.StringReplace(str1.substr(searchIdx + searchLen), strsearch, strreplace);
        } else {
            return str1;
        }
    };

    Lang.StringLastIndexOf = function (str1, strsearch) {//NO_RENAME:lastIndexOf
        if(strsearch == null || strsearch == "") {
            throw new Error("InvalidArgument");
        }
        return str1.lastIndexOf(strsearch);
    }

    Lang.ListFromRepr = function (a) {
        return ListCS.FromRepr(a);
    };

    /** Convert from a language-specific representation of an T[] to a T[] **/
    Lang.ArrayFromRepr = function (repr) {
        return ArrayCS.FromRepr(repr);
    };



    /** Convert from a T[] to a language-specific representation **/
    Lang.ArrayToRepr = function (a) {
        if(a == null) return null;
        return a.ToRepr();
    };

    Lang.ListFromRepr = function (repr) {
        return ListCS.FromRepr(repr);
    };

    /** Convert from a List<> to a language-specific representation **/
    Lang.ListToRepr = function (l) {
        if(l == null) return null;
        return l.ToRepr();
    };

    /** Convert from a language-specific representation of a T[] to the array **/
    Lang.DictionaryFromRepr = function (repr) {
	var tmp = DictionaryCS.FromRepr(repr);
        //return DictionaryCS.FromRepr(repr);
        return tmp;
    };

    /** Convert from a T[] to a language-specific representation. For AS3 this is a Object, to be indexed with strings **/
    Lang.StringDictionaryToRepr = function (dict) {
        if(dict == null) return null;
        if(dict.hasOwnProperty(__id("ToObject"))) {
            return dict.ToObject();
        } else {
            return dict; // already an Object
        }
    };

    Lang.DictionaryCopyToObject = function (dict, obj) {
        if(dict == null) return;
        dict.CopyToObject(obj);
    };

    /**
     * Convert from a string to a language-independent representation.
     * For JS this does nothing, since there is only one kind of string.
     */
    Lang.StringFromRepr = function (s) {
        return s;
    }


    Lang.StringToXml = function (str) {
        try {//NO_RENAME:DOMParser,parseFromString,documentElement,ActiveXOBject,async,loadXML
            if (window.DOMParser) {
                var xmlobject = (new DOMParser()).parseFromString(str, "text/xml");
                return xmlobject.documentElement;
            } else {
                // IE
                var xmlobject = new ActiveXObject("Microsoft.XMLDOM");
                xmlobject.async="false";
                xmlobject.loadXML(str);
                return xmlobject.documentElement;
            }
        } catch(e) {
            return null;
        }
    };

    Lang.XmlToString = function (oXML) {
        try {//NO_RENAME:XMLSerializer,serializeToString,xml
            if (window.XMLSerializer) {
                return (new XMLSerializer()).serializeToString(oXML);
            } else { // IE
                return oXML.xml;
            }
        } catch(e) {
            return null;
        }
    };

    Lang.ToString = function (o) {
        if(o == null) return null;
        // Perhaps we find the ToString method
        if(typeof(o.ToString) == "function") {
            return o.ToString ();
        } else {
            return o.toString ();
        }
    }

    Lang.StringToLower = function (s) {
        return s.toLowerCase();
    }

    Lang.StringToInt = function (s) {
        return parseInt(s);
    }

    Lang.AsDouble = function (v) {
        if (v instanceof Int64) {
            return v.asNumber;
        } else if(v instanceof UInt64) {
            return v.asNumber;
        } else {
            return Number(v);
        }
    }

    // First, recognize the
    Lang.doubleRegex = new RegExp("^([+-]?[0-9]*\\.?[0-9]+)((e|E)[+-]?[0-9]+)?$");
    Lang.parseDouble = function (v) {
        // This function needs to parse the same strings that C# double.Parse parses
        // In Javascript parsing an invalid string return NaN
        Lang.parseChecker(v, Lang.doubleRegex, "double");
        return parseFloat(v);
    }

    Lang.parseChecker = function (s, pattern, what) {
        if (!pattern.test(s)) {
            throw new Error("Invalid string for "+what+": "+s);
        }
    }
}
statInit(Lang,"Lang");

// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-
// Copyright Conviva Inc 2010
// Author: George Necula (necula@conviva.com)

function ListCS() {
    var _s = this;

    if(_s != STAT_INIT) _s.arr = undefined;
    function _constr() {
        // Inherit from ArrayCS
        if (arguments.length > 1) {
            Ping.Send("Error: Instantiate ListCS with too many arguments");
        } else if (arguments.length == 0) {
                ArrayCS.call(_s, 0);
        } else if (arguments[0] instanceof Number) {
                ArrayCS.call(_s, arguments[0]);
        } else  if (arguments[0] instanceof Array) {
                ArrayCS.call(_s, arguments[0].length);
                _s.arr = arguments[0];
        } else   if (arguments[0] instanceof ArrayCS) {
                ArrayCS.call(_s, arguments[0].length);
                _s.arr = arguments[0].arr;
        } else {
            Ping.Send("Error: Instantiate ListCS with inappropriate arguments");
        }
    }

    defStatMeth(_s,ListCS,"Create",__Create);
    function __Create(a) {
        var res = new ListCS();
        for(var i=0;i<arguments.length;i++) {
            res.arr.push(arguments[i]);
        }
        return res;
    }

    defStatMeth(_s,ListCS,"FromRepr",__FromRepr);
    function __FromRepr(a) {
        if (a == null) {
            return a;
        }
        if (a instanceof ListCS) {
            return a;
        }
        var res = new ListCS();
        res.arr = a;
        return res;
    }

    defPubMeth(_s,"ToRepr",__ToRepr);
    function __ToRepr() {
        return _s.arr;
    }

    defGet(_s,"Count",__Count);
    function __Count() {
        return _s.arr.length;
    }

    defGet(_s,"Values",__Values);
    function __Values() {
        return _s.arr;
    }

    defPubMeth(_s,"Add",__Add);
    function __Add(e) {
        _s.arr.push(e);
    }

    defPubMeth(_s,"Clear",__Clear);
    function __Clear(e) {
        _s.arr.length = 0;
    }

    defPubMeth(_s,"IndexOf",__IndexOf);
    function __IndexOf(e) {
        var startIndex = arguments[1];
        if (startIndex == null) {
            startIndex = 0;
        } else if (startIndex < 0 || startIndex >= _s.arr.length) {
            throw new Error("Starting index out of bound");
        }

        for(var i=startIndex;i<_s.arr.length;i++) {
            if(_s.arr[i] == e) return i;
        }
        return -1;
    }

    defPubMeth(_s,"Contains",__Contains);
    function __Contains(e) {
        return _s.IndexOf(e) >= 0;
    }

    defPubMeth(_s,"Insert",__Insert);
    function __Insert(idx, e) {
        _s.arr.splice(idx, 0, e);
    }

    defPubMeth(_s,"Remove",__Remove);
    function __Remove(e) {
        var idx = _s.IndexOf(e);
        if(idx < 0) return false;
        _s.RemoveAt(idx);
        return true;
    }

    defPubMeth(_s,"RemoveRange",__RemoveRange);
    function __RemoveRange(where, count) {
        _s.arr.splice(where, count);
    }

    defPubMeth(_s,"RemoveAt",__RemoveAt);
    function __RemoveAt(where) {
        _s.arr.splice(where, 1);
    }

    defPubMeth(_s,"GetRange",__GetRange);
    function __GetRange(startidx, len) {
        var res = new ListCS();
        res.arr = _s.arr.slice(startidx, startidx + len);
        return res;
    }

    defPubMeth(_s,"Sort",__Sort);
    function __Sort() {
        _s.arr.sort.apply(_s.arr, arguments);
    }

    defPubMeth(_s,"ToArray",__ToArray);
    function __ToArray() {
        return ArrayCS.FromRepr(_s.arr.slice());
    }

    if(_s != STAT_INIT) _constr.apply(this, arguments);

}
statInit(ListCS,"ListCS");

// DO NOT EDIT! THIS FILE WAS GENERATED BY Slash from ../../csClient/CwsClient/utils/NativeLang.cs
// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-


// namespace utils
    /**
     * Utilities for interfacing with native language objects.  This should be
     * used only when speed is critical and Slash data structures are too slow.
     */
    function NativeLang() {
        var _s = this;

        //NOTE(henry): We should have Slash find these calls and translate them
        // directly to native dictionary accesses.  This would save a method
        // call.

        defStatMeth(_s,NativeLang,"setDictValue",__setDictValue);
        function __setDictValue(dict /* : Object */, key /* : Object */, value /* : Object */) /* : void */  {
            dict[key] = value;
        }

        defStatMeth(_s,NativeLang,"makeList",__makeList);
        function __makeList() /* : Object */  {
            return [];
        }

        defStatMeth(_s,NativeLang,"listCount",__listCount);
        function __listCount(lst /* : Object */) /* : int */  {
            return lst.length;
        }

        defStatMeth(_s,NativeLang,"addListValue",__addListValue);
        function __addListValue(list /* : Object */, value /* : Object */) /* : void */  {
            list.push(value);
        }

        defStatMeth(_s,NativeLang,"removeListValueAt",__removeListValueAt);
        function __removeListValueAt(list /* : Object */, idx /* : int */) /* : void */  {
            list.splice(idx, 1);
        }

        defStatMeth(_s,NativeLang,"GetField",__GetField);
        function __GetField(propName /* : String */, obj /* : Object */) /* : Object */  {
            return obj[propName];
        }

        defStatMeth(_s,NativeLang,"GetStringField",__GetStringField);
        function __GetStringField(propName /* : String */, obj /* : Object */) /* : String */  {
            var o /* : Object */ = NativeLang.GetField(propName, obj);
            if (o) {
                return o.toString();
            }
            return null;
        }
    }
statInit(NativeLang,"NativeLang");

// DO NOT EDIT! THIS FILE WAS GENERATED BY Slash from ../../csClient/CwsClient/utils/Settings.cs
// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-


// namespace utils
    function Settings() {
        var _s = this;
        // The interval between heartbeats.
        if(_s != STAT_INIT) _s.heartbeatIntervalMs /* : int */ = 20000;
        // The API key (corresponding to a customer name) used for heartbeats.
        if(_s != STAT_INIT) _s.customerKey /* : String */ = null;

        if(_s != STAT_INIT) _s.gatewayUrl /* : String */ = "https://cws.conviva.com";
        if(_s != STAT_INIT) _s.gatewayPath /* : String */ = "/0/wsg";

        if(_s != STAT_INIT) _s.protocolVersion /* : String */ = "2.4";

        // The next line will be modified by set_versions.pl
        if(_s != STAT_INIT) _s.clientVersion /* : String */ = "2.134.0.34932";

        // The next field will be changed by LivePass upon "init"
        if(_s != STAT_INIT) _s.clientInstanceId /* : int */ = 0;

        // The maximum length of time we wait when loading from local storage.
        if(_s != STAT_INIT) _s.loadDataTimeoutMs /* : int */ = 10000;

        //  Enable logging to device console
        if(_s != STAT_INIT) _s.enableLogging /* : Boolean */ = false;

        // An instance of PlatformApi with methods for access to low-level services
        if(_s != STAT_INIT) _s.platformApi /* : PlatformApi */ = null;

        // Whether to try/catch exceptions or not (may interfere with some debuggers)
        if(_s != STAT_INIT) _s.allowUncaughtExceptions /* : Boolean */ = false;

        if(_s != STAT_INIT) _s.pingComponentName /* : String */ = "jscws";
        if(_s != STAT_INIT) _s.pingUrl /* : String */ = "https://pings.conviva.com/ping.ping";


        // Change the settings based on the dictionary of keys
        defPubMeth(_s,"changeSettings",__changeSettings);
        function __changeSettings(settings /* : Object */) /* : void */  {
            if (settings == null) return;
            var sobj /* : DictionaryCS(string, object) */ = Lang.DictionaryFromRepr/*string, object*/(settings);
            var _for_array_1 =  sobj.Keys;
            for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
              var key /* : String */ = _for_array_1[_for_idx_2];

                var v /* : Object */ = sobj.GetValue(key);
                switch (key) {
                    case "platformApi":
                        _s.platformApi = (v);
                        break;
                    case "gatewayUrl":
                        _s.gatewayUrl = (sobj.GetValue(key));
                        break;
                    case "heartbeatIntervalMs":
                        _s.heartbeatIntervalMs = slint.Cast(sobj.GetValue(key));
                        break;
                    case "enableLogging":
                        _s.enableLogging = Boolean(sobj.GetValue(key));
                        break;
                    case "allowUncaughtExceptions":
                        _s.allowUncaughtExceptions = Boolean(sobj.GetValue(key));
                        break;
                    default:
                        throw new Error("Unsupported settings: " + key);
                }
            }
        }
    }
statInit(Settings,"Settings");

// DO NOT EDIT! THIS FILE WAS GENERATED BY Slash from ../../csClient/CwsClient/utils/Utils.cs
// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-






// namespace utils
    function Utils() {
        var _s = this;

        // The unique instance of the Utils module
        if(_s == STAT_INIT) Utils._instance /* : Utils */ = null;
        if(_s != STAT_INIT) _s._referenceCount /* : int */ = 0; // We refcount the Utils instance (AutoTouch also uses it)

        // The dependencies of the unique instance of Utils
        if(_s != STAT_INIT) _s._settings /* : Settings */ = null;

        if(_s == STAT_INIT) Utils.DEFAULT_CLIENT_ID /* : String */ = "0"; // This is the default client id if we do not have one

        /* The client ID goes through the following states:
         * - loading from disk:
         *      clientId == DEFAULT_CLIENT_ID
         *      clientIdLoadingDone != null (Eventer fires when loading from storage, or loading timeout)
         *      _loadClientIdTimeout != null
         *
         * - loaded from disk:
         *      clientId != DEFAULT_CLIENT_ID
         *      clientIdLoadingDone == null
         *      _loadClientIdTimeout == null
         *
         * - loading from disk timed out:
         *      clientId == DEFAULT_CLIENT_ID
         *      clientIdLoadingDone == null
         *      _loadClientIdTimeout == null
         *
         * - set from server response
         *      clientID != DEFAULT_CLIENT_ID
         *      written to local storage (best effort)
         *      clientIdLoadingDone == null
         *      _loadClientIdTimeout == null
         *
         */
        if(_s != STAT_INIT) _s._loadClientIdTimeout /* : Cleanable */ = null;
        if(_s != STAT_INIT) _s.clientId /* : String */ = Utils.DEFAULT_CLIENT_ID;
        if(_s != STAT_INIT) _s.clientIdLoadingDone /* : Eventer */ = null; // To signal when we are done loading the client id

        //@owner
        if(_s != STAT_INIT) _s._pingUrl /* : String */ = null;
        if(_s != STAT_INIT) _s._cachedPingUrl /* : Boolean */ = false;
        if(_s != STAT_INIT) _s._isSendingPing /* : Boolean */ = false;

        if(_s != STAT_INIT) _s.protocolVersion /* : String */ = null;

        // @deprecated for pure CWS 1.7 clients
        if(_s != STAT_INIT) _s.device /* : String */ = null;
        if(_s != STAT_INIT) _s.os /* : String */ = null;
        if(_s != STAT_INIT) _s.osVersion /* : String */ = null;
        if(_s != STAT_INIT) _s.deviceVersion /* : String */ = null;
        if(_s != STAT_INIT) _s.deviceType /* : String */ = null;
        if(_s != STAT_INIT) _s.platform /* : String */ = null;

        // We keep a list of Cleanable, indexed by some id
        if(_s != STAT_INIT) _s._cleanables /* : DictionaryCS(int, Cleanable) */ = null;


        /* We accumulate a circular list of logs in the log buffer */
        if(_s == STAT_INIT) Utils.MAX_SIZE_LOGBUFFER /* : int */ = 32;
        if(_s == STAT_INIT) Utils.logBuffer /* : ListCS(string) */ = new ListCS/*string*/();



        function _constr(settings /* : Settings */) {
            _s._settings = settings;
            _s._referenceCount = 1;
            _s._pingUrl = null;
            _s._isSendingPing = false;
            _s.protocolVersion = _s._settings.protocolVersion;

            _s._cleanables = new DictionaryCS/*<int, Cleanable>*/();

            // See if we need to create the _settings object
            if (_s._settings.platformApi == null) {
                if (typeof PlayStationWebmafApi !== "undefined") {
                    _s._settings.platformApi = new PlayStationWebmafApi();
                } else if (typeof PlayStationTouchFactorApi !== "undefined") {
                    _s._settings.platformApi = new PlayStationTouchFactorApi();
                } else if (typeof PlayStationLibjscriptApi !== "undefined") {
                    _s._settings.platformApi = new PlayStationLibjscriptApi();
                } else if (typeof ConvivaVideojsPlatformApi != "undefined") {
                    _s._settings.platformApi = new ConvivaVideojsPlatformApi();
                } else if (typeof Html5PlatformApi !== "undefined") {
                    _s._settings.platformApi = new Html5PlatformApi();
                } else if (typeof PlayStationTrilithiumApi !== "undefined") {
                    _s._settings.platformApi = new PlayStationTrilithiumApi();
                } else if (typeof Xbox1PlatformApi !== "undefined") {
                    _s._settings.platformApi = new Xbox1PlatformApi();
                }
                // Could do the same for SamsungTV, would need to change integration code though.
            }
            if (_s._settings.platformApi == null) {
                throw new Error("PlatformApi is null");
            }

            // @deprecated for pure CWS 1.7 clients
            _s.device = _s._settings.platformApi.getDevice();
            _s.deviceVersion = _s._settings.platformApi.getDeviceVersion();
            _s.deviceType = _s._settings.platformApi.getDeviceType();
            _s.os = _s._settings.platformApi.getOS();
            _s.osVersion = _s._settings.platformApi.getOSVersion();

            // @deprecated in pure CWS 1.7 clients. Moved to backend as well as part of the platform metadata field.
            _s.platform = "Js";

        }

        /// <summary>
        /// Call this function once to initialize the Utils module.
        /// For every instance of CreateUtils, there must be a call to cleanup()
        /// </summary>
        /// <param name="platformApi"></param>
        /// <param name="settings"></param>
        defStatMeth(_s,Utils,"CreateUtils",__CreateUtils);
        function __CreateUtils(settings /* : Object */) /* : Utils */  {
            if (Utils._instance == null) {
                var s /* : Settings */ = new Settings();
                s.changeSettings(settings);
                Utils._instance = new Utils(s);
                Utils._instance._start();
            } else {
                Utils._instance.getSettings().changeSettings(settings);
                Utils._instance._referenceCount++;
            }
            return Utils._instance;
        }


        /// <summary>
        /// Call this function to get the singleton instance of the Utils module
        /// </summary>
        /// <returns></returns>
        defStatMeth(_s,Utils,"getInstance",__getInstance);
        function __getInstance() /* : Utils */  {
            if (Utils._instance == null) {
                throw new Error("CreateUtils module has not been called");
            }
            return Utils._instance;
        }

        defPubMeth(_s,"getPlatformApi",__getPlatformApi);
        function __getPlatformApi() /* : PlatformApi */  {
            return _s._settings.platformApi;
        }

        defPubMeth(_s,"getSettings",__getSettings);
        function __getSettings() /* : Settings */  {
            return _s._settings;
        }

        defPrivMeth(_s,"_start",___start);
        function ___start() /* : void */  {
            // Called only once to initialize the Utils module
        }


        defPubMeth(_s,"cleanup",__cleanup);
        function __cleanup() /* : void */  {
            _s._referenceCount--;
            if (_s._referenceCount > 0) {
                return;
            }
            if (_s.clientIdLoadingDone != null) {
                _s.clientIdLoadingDone.Cleanup();
                _s.clientIdLoadingDone = null;
            }
            if (_s._cleanables != null) {
                Cleanable.cleanupCollection(_s._cleanables);
                _s._cleanables = null;
            }
            if (_s._settings != null && _s._settings.platformApi != null) {
                _s._settings.platformApi.cleanup();
            }
            _s._settings = null;
            Utils._instance = null; // weird, static member reset by non-static method
        }

        defPubMeth(_s,"logNoBuffer",__logNoBuffer);
        function __logNoBuffer(msg /* : String */) /* : String */  {
            var timeMsec /* : Number */ = _s.epochTimeMs();
            var theTime /* : String */ = undefined;
            theTime = (timeMsec / 1000.0).toFixed(3).toString();

            msg = "[" + theTime + "] " + msg;

            var isError /* : Boolean */ = Lang.StringContains(msg, "ERROR:");

            if (_s._settings.enableLogging) {
                if(isError) {
                    _s._settings.platformApi.consoleErr(msg);
                } else {
                    _s._settings.platformApi.consoleLog(msg);
                }
            }
            return msg;
        }

        /***
         * Record (or show) a log message. The log message can optionally start with "ERROR: " to signal an error.
         * The log message can also contain "sid=sessionId" when the log message can be associated with the given session.
         */
        defPubMeth(_s,"log",__log);
        function __log(msg /* : String */) /* : void */  {
            msg = _s.logNoBuffer(msg);
            // We add to the buffer, independent of whether enableLogging is set
            if (Utils.logBuffer.Count >= Utils.MAX_SIZE_LOGBUFFER) {
                Utils.logBuffer.RemoveAt(0);
            }
            Utils.logBuffer.Add(msg);
        }

        defPubMeth(_s,"logSession",__logSession);
        function __logSession(msg /* : String */, sessionId /* : int */) /* : void */  {
            _s.log("sid=" + sessionId + " " + msg);
        }

        defPubMeth(_s,"err",__err);
        function __err(message /* : String */) /* : void */  {
            _s.log("ERROR: " + message);
        }


        /**
         * Retrieve the log messages for the given session
         */
        defPubMeth(_s,"getLogs",__getLogs);
        function __getLogs(sessionId /* : int */) /* : ListCS(string) */  {
            // Send all logs in the same session
            var res /* : ListCS(string) */ = Utils.logBuffer;
            Utils.logBuffer = new ListCS/*string*/();
            return res;
        }



        defPubMeth(_s,"assert",__assert);
        function __assert(condition /* : Boolean */, msg /* : String */) /* : void */  {
            if (!condition) {
                throw new Error("Assertion failure: " + msg);
            }
        }




        /// <summary>
        /// Run a function with try/catch protection
        /// </summary>
        /// <param name="func"></param>
        /// <param name="message"></param>
        defPubMeth(_s,"runProtected",__runProtected);
        function __runProtected(func /* : Function */, message /* : String */) /* : void */  {
            _s.runProtectedSync(func, message);
        }

        /// <summary>
        /// Run a function with try/catch protection. This function is guaranteed to be synchronous
        /// </summary>
        /// <param name="func"></param>
        /// <param name="message"></param>
        defPubMeth(_s,"runProtectedSync",__runProtectedSync);
        function __runProtectedSync(func /* : Function */, message /* : String */) /* : void */  {
            var allowUncaughtExceptions /* : Boolean */ = _s._settings.allowUncaughtExceptions;

            if (allowUncaughtExceptions) {
                func();
            } else {
                try {
                    func();
                } catch(e /* : Error */) {
                    _s.onUncaughtException(message, e);
                }
            }
        }


        defPrivMeth(_s,"onUncaughtException",__onUncaughtException);
        function __onUncaughtException(msg /* : String */, e /* : Error */) /* : void */  {
            try {
                _s.ping("Uncaught exception: " + msg + ": " + Lang.ToString(e));
            } catch(eping /* : Error */) {
                _s.err("Caught exception while sending ping: " + Lang.ToString(eping));
            }
        }

        defPubMeth(_s,"ping",__ping);
        function __ping(msg /* : String */) /* : void */  {
            if (_s._isSendingPing) {
                return;
            }
            _s._isSendingPing = true;
            _s.initPing();
            var pingUrl /* : String */ = _s._pingUrl + "&d=" + _s.urlEncodeString(Lang.ToString(msg));
            _s.err("Ping: " + pingUrl);
            _s.httpRequest(false, pingUrl, null, null, null);
            _s._isSendingPing = false;

        }

        defPrivMeth(_s,"initPing",__initPing);
        function __initPing() /* : void */  {
            // Alban: keeping this logic here. Don't want to spread Slash directives to yet more files.
            // Plus Utils might absorb Settings in the future.
            if (!_s._cachedPingUrl) { // Prepare the ping URL.

                var componentName /* : String */ = "jscws";

                var metadataSchema /* : String */ = null;

                try { // Can't send pings from here.
                    var platformMetadata /* : DictionaryCS(string, string) */ = Lang.DictionaryFromRepr/*string, string*/(_s._settings.platformApi.getPlatformMetadata());
                    if (platformMetadata != null && platformMetadata.ContainsKey("sch")) {
                        metadataSchema = platformMetadata.GetValue("sch");
                    }
                } catch(e /* : Error */) {
                }

                _s._pingUrl = _s._settings.pingUrl + "?"
                    + "comp=" + componentName
                    + "&clv=" + _s._settings.clientVersion
                    + "&cid=" + _s._settings.customerKey // sending bad values could be useful (can't ping before LivePass.init)
                    + "&uuid=" + _s.clientId;

                if (metadataSchema != null) {
                    _s._pingUrl += "&sch=" + metadataSchema;
                }

                if (_s.clientId != Utils.DEFAULT_CLIENT_ID && metadataSchema != null) { // All the data is available, we can reuse the same url for later pings.
                    _s._cachedPingUrl = true;
                }
            }
        }

        defPrivMeth(_s,"urlEncodeString",__urlEncodeString);
        function __urlEncodeString(rawString /* : String */) /* : String */  {
            return escape(rawString);
        }

        /// <summary>
        /// Return the current time in milliseconds since Unix epoch
        /// </summary>
        /// <returns></returns>
        defPubMeth(_s,"epochTimeMs",__epochTimeMs);
        function __epochTimeMs() /* : Number */  {
            return _s._settings.platformApi.epochTimeMs();
        }

        /// <summary>
        /// Create a periodic timer
        /// </summary>
        /// <param name="timerAction"></param>
        /// <param name="intervalMs"></param>
        /// <param name="actionName"></param>
        /// <returns></returns>
        defPubMeth(_s,"createTimer",__createTimer);
        function __createTimer(timerAction /* : Function */, intervalMs /* : int */, actionName /* : String */) /* : Cleanable */  {
            var cleanable /* : Cleanable */ = new Cleanable(_s._cleanables);
            var wrappedAction /* : Function */ = null;
            wrappedAction = (
                 function () {
                     _s.runProtected(timerAction, actionName);
                 });
            cleanable.setCleanupAction(_s._settings.platformApi.createTimer(wrappedAction, intervalMs, actionName));
            return cleanable;
        }

        /// <summary>
        /// Schedule an action after an interval
        /// </summary>
        /// <param name="action"></param>
        /// <param name="delayMs"></param>
        /// <param name="actionName"></param>
        /// <returns></returns>
        defPubMeth(_s,"scheduleAction",__scheduleAction);
        function __scheduleAction(action /* : Function */, delayMs /* : int */, actionName /* : String */) /* : Cleanable */  {
            var cleanable /* : Cleanable */ = new Cleanable(_s._cleanables);
            var actionHappened /* : Boolean */ = false;
            var wrappedAction /* : Function */ = null;
            wrappedAction = (
                 function () {
                     if (cleanable != null) {
                         cleanable.cleanup();
                     }
                     action();
                     actionHappened = true;
                 });
            cleanable.setCleanupAction(_s._settings.platformApi.createTimer(wrappedAction, delayMs, actionName));
            // This is necessary because makeTimer() might have already caused
            // wrappedAction() to be called (e.g. it might call the action
            // synchronously if delayMs=0).  In that case, theTimer was null
            // when wrappedAction was called, so theTimer couldn't be cleaned
            // up.
            if (actionHappened) {
                cleanable.cleanup();
            }
            return cleanable;
        }


        defPubMeth(_s,"parseInt",__parseInt);
        function __parseInt(decimalInt /* : String */, defaultResult /* : int */) /* : int */  {
            var result /* : int */ = defaultResult;
            try {
                result = slint.Parse(decimalInt);
            } catch(e /* : Error */) {
            }
            return result;
        }

        defPubMeth(_s,"parseNumber",__parseNumber);
        function __parseNumber(numberStr /* : String */, defaultResult /* : float */) /* : Number */  {
            var result /* : Number */ = defaultResult;
            try {
                result = Lang.parseDouble(numberStr);
            } catch(e /* : Error */) {
            }
            return result;
        }

        defPubMeth(_s,"startFetchClientId",__startFetchClientId);
        function __startFetchClientId() /* : void */  {
            //  Called on LivePass.init
            _s.clientId = Utils.DEFAULT_CLIENT_ID;
            _s.clientIdLoadingDone = new Eventer(); // This means we do not yet have a clientId

            _s._loadClientIdTimeout = _s.scheduleAction(
                 function () {
                     _s.log("Timeout in reading clientId. Using " + Utils.DEFAULT_CLIENT_ID + ".");
                     _s.ping("Timeout in reading clientId. IGNORE waited " + _s._settings.loadDataTimeoutMs + "ms.");
                     if (_s.clientIdLoadingDone != null) {
                         _s.clientIdLoadingDone.DispatchEvent();
                     }
                     _s._loadClientIdTimeout = null;
                 },
                 _s._settings.loadDataTimeoutMs,
                 "utils.readClientId timeout callback");

            var onLoad /* : Function(Action(bool, string)) */ = undefined;
            onLoad = (
                function (fSuccess /* : Boolean */, loadedData /* : String */) {
                    _s.runProtected(
                        function () {
                            if (_s._loadClientIdTimeout != null) {
                                _s._loadClientIdTimeout.cleanup();
                                _s._loadClientIdTimeout = null;
                            }
                            var result /* : DictionaryCS(string, object) */ = null;
                            if (fSuccess) { // don't try and decode random/null values.
                                try {
                                    result = _s.jsonDecode(loadedData);
                                } catch(e /* : Error */) {
                                    result = null;
                                }
                            }
                            var loadedClientId /* : String */ = null;
                            if(fSuccess && result != null && result.ContainsKey("clId")) {
                                    loadedClientId = result.GetValue("clId");
                            }
                            if (loadedClientId != null && loadedClientId != Utils.DEFAULT_CLIENT_ID && loadedClientId != "null") {
                                _s.clientId = loadedClientId;
                                _s.log("Setting the client id to " + loadedClientId + " (from local storage)");
                            } else {
                                _s.log("Failed to load the client id from local storage");
                            }
                            if (_s.clientIdLoadingDone != null) {
                                _s.clientIdLoadingDone.DispatchEvent();
                                _s.clientIdLoadingDone = null;
                            }
                        },
                        "utils.fetchClientId onLoad");
            });
             _s._settings.platformApi.loadLocalData(onLoad);
        }

        /*
        * This function is used to set the client id from a server response
        */
        defPubMeth(_s,"setClientIdFromServer",__setClientIdFromServer);
        function __setClientIdFromServer(newClientId /* : String */, fromStorage /* : Boolean */) /* : void */  {

            if (_s._loadClientIdTimeout != null) {
                _s._loadClientIdTimeout.cleanup();
                _s._loadClientIdTimeout = null;
            }
            _s.clientIdLoadingDone = null;
            if (_s.clientId != newClientId) {
                _s.clientId = newClientId;
                _s.log("Setting the client id to " + newClientId + " (from server)");
                _s.writeClientId();
            }
        }

        // Write the current client ID to local storage, so that it can be
        // retrieved later by startFetchClientId() above.
        defPrivMeth(_s,"writeClientId",__writeClientId);
        function __writeClientId() /* : void */  {
            var dataToSave /* : DictionaryCS(string, string) */ = new DictionaryCS/*<string, string>*/();
            dataToSave.SetValue("clId", _s.clientId);
            var onSaved /* : Function(Action(bool)) */ = undefined;
            onSaved = (
                function (fSuccess /* : Boolean */) {
                    _s.runProtected(
                        function () {
                            if (!fSuccess) {
                                _s.err("An error occurred while saving the clientId.");
                            }
                        }, "utils.writeClientId onSaved");
            });
            var dataObject /* : Object */ = Lang.StringDictionaryToRepr(dataToSave);
            var dataStr /* : String */ = _s.jsonEncode(dataObject);
            _s._settings.platformApi.saveLocalData(dataStr, onSaved);
        }




        // Used for Session._sessionId (gateway expects int32)
        defPubMeth(_s,"randInt",__randInt);
        function __randInt() /* : int */  {
            // Returns a random signed 32-bit integer. Range should be -2147483648 to 2147483647
            return Math.floor(Math.random()*4294967295) - 2147483648;
        }

        // Used for Settings.clientInstanceId (gateway expects uint32)
        defPubMeth(_s,"randUInt",__randUInt);
        function __randUInt() /* : int */  {
            // Returns a random unsigned integer. Range should be 0 to 2147483647
            // Weird flow for easier Slashing
            var uInt /* : int */ = _s.randInt();
            uInt = Math.abs(uInt);
            if (uInt < 0) uInt = 0;
            return uInt;
        }

        /// <summary>
        /// Send HTTP request
        ///
        /// The callback function must be invoked after the operation
        /// </summary>
        /// <param name="isPOST">true if this is a POST request; false for GET</param>
        /// <param name="url">URL of the request</param>
        /// <param name="data">The data to be sent (ignored for GET)</param>
        /// <param name="contentType">The content type (if null, the default will be "application/json")</param>
        /// <param name="callback">Callback function to be invoked. May be null. The callback will receive the following parameters:
        ///               * a boolean representing success of the operation
        ///               * a String representing data in the response
        /// </param>
        defPubMeth(_s,"httpRequest",__httpRequest);
        function __httpRequest(isPOST /* : Boolean */, url /* : String */, data /* : String */, contentType /* : String */, callback /* : Function(Action(bool, string)) */) /* : Cleanable */  {
            var cleanable /* : Cleanable */ = new Cleanable(_s._cleanables);
            cleanable.setCleanupAction(_s._settings.platformApi.httpRequest(isPOST, url, data, contentType,
                                                      function (isSuccess /* : Boolean */, response /* : String */) {
                                                           //log("httpRequest  response from " + url + " success=" + isSuccess.ToString());
                                                           cleanable.cleanup ();
                                                           if(callback != null) {
                                                                callback(isSuccess, response);
                                                               }
                                                      }));
            return cleanable;
        }

        /**
         * @obj must be a JSON encodable data structure in the native language
         * (i.e. not a Slash data structure like a DictionaryCS).  It must have
         * one of the following types:
         *   - dictionary
         *   - array or list
         *   - string
         *   - number
         *   - boolean
         *   - null
         * @callback is called with the JSON result when encoding is done. This
         * asynchronous interface is provided because encoding may take too
         * long for a single handler on some platforms.
         */
        defPubMeth(_s,"jsonEncode",__jsonEncode);
        function __jsonEncode(obj /* : Object */) /* : String */  {
            var res /* : String */ = null;
            _s.runProtectedSync(
                function () {
                    res = _s._settings.platformApi.jsonEncode(obj);
                },
                "utils.jsonEncode");
            return res;
        }


        defPubMeth(_s,"jsonDecode",__jsonDecode);
        function __jsonDecode(json /* : String */) /* : DictionaryCS(string, object) */  {
            var res /* : DictionaryCS(string, object) */ = null;
            _s.runProtectedSync(
                function () {
                    var decodedJson /* : Object */ = _s._settings.platformApi.jsonDecode(json);
                    res = Lang.DictionaryFromRepr/*string, object*/(decodedJson);
                },
                "utils.jsonDecode");
            return res;
        }

       //JSRENAME:constant:_s:Utils:DEFAULT_CLIENT_ID
       //JSRENAME:constant:_s:Utils:MAX_SIZE_LOGBUFFER
        if(_s != STAT_INIT) _constr.apply(_s, arguments);
    }
statInit(Utils,"Utils");

// Copyright Conviva Inc 2013-2014
// Author: Alban Nicolas (anicolas@conviva.com)

function DataLoader() {
    var _s = this;

    if(_s == STAT_INIT) {
        DataLoader.frameId = 'conviva_iframe';
        DataLoader.frameUrl = '/cws_iframe.html';
        DataLoader.TESTAPI_forTouchstone = true;

        DataLoader.referenceCount = 0;

        DataLoader.nextConvivaRequestId = 0;
        DataLoader.callbacks = {}; // Map from request id to pair (domain, callback)
        DataLoader.communicationFramesIds = {}; // Map domain URL to the communication frames IDs

        if (typeof window !== 'undefined') {
            if (window.addEventListener){
                window.addEventListener('message', handleResp, false);
            } else if (window.attachEvent) {
                window.attachEvent('onmessage', handleResp);
            }
        }
    }

    function _constr() {
        DataLoader.referenceCount++;
    }

    this.cleanup = function() {
        DataLoader.referenceCount--;
        if (DataLoader.referenceCount == 0) {
            // static cleanup
            DataLoader.nextConvivaRequestId = 0;
            DataLoader.callbacks = {};
            slForEachPropValue(DataLoader.communicationFramesIds,
                function (communicationFrameId) {
                    _s.removeIFrame(communicationFrameId);
                }
            );
            DataLoader.communicationFramesIds = {};
        }
    }

    this.findFrameById = function (remoteFrameId) {
        return (remoteFrameId ? document.getElementById(remoteFrameId) : null);
    }

    this.findFrameForDomain = function (forDomain) {
        // PD-12338: extra safe due to potential id="undefined" DOM elements
        var remoteFrameId = DataLoader.communicationFramesIds[forDomain];
        return _s.findFrameById(remoteFrameId);
    }

    this.makeRequest = function(isPOST, url, data, contentType, callback) {
        // Extract the host and protocol from the url
        var m = url.match(/^(https?:\/\/[^\/]*)(\/.*)$/);
        if(!m) {
            Utils.getInstance().log("ERROR: UrlLoader: cannot parse url: "+url);
            return null;
        }
        var forDomain = m[1]; // The destination domain

        var remoteFrame = _s.findFrameForDomain(forDomain);
        if(remoteFrame && remoteFrame.loaded) {
            // Prep message parameters
            var convivaRequestId = DataLoader.nextConvivaRequestId++;
            var method = isPOST ? "POST" : "GET";
            var evt = { 'url' : url,
                        'method' : method,
                        'data' : data,
                        'contentType' : contentType,
                        'requestId' : convivaRequestId, // Backward compatibility for 2.79 and prior clients (none in production)
                        'convivaRequestId' : convivaRequestId };
            // Register callback
            DataLoader.callbacks[convivaRequestId] = [ forDomain, callback ];
            // Post to iframe
            remoteFrame.contentWindow.postMessage(evt, DataLoader.TESTAPI_forTouchstone ? "*" : forDomain);
        } else if (remoteFrame && !remoteFrame.loaded) {
            // iframe not ready, try again in 500ms
            setTimeout(function () { _s.makeRequest(isPOST, url, data, contentType, callback); }, 500);
        } else {
            // no iframe for this domain, create one and queue http request
            _s.insertIFrame(forDomain,
                function () {
                    var remoteFrame = _s.findFrameForDomain(forDomain);
                    if (remoteFrame) {
                        remoteFrame.loaded = true;
                        _s.makeRequest(isPOST, url, data, contentType, callback);
                    }
                }
            );
        }
        return null; // No way to cancel the request
    }

    this.insertIFrame = function(forDomain, callback) {
        //NO_RENAME:id,height,src,onload,document,body,createElement,getElementsByTagName,appendChild
        var remoteFrame = document.createElement("iframe");
        remoteFrame.id = "_conviva_iframe_"+forDomain+"_"+DataLoader.frameId;
        // PD-14200 remove iframe pixel that appears on screen
        remoteFrame.style.height="0px";
        remoteFrame.style.width="0px";
        remoteFrame.style.top="-50px";
        remoteFrame.style.left="-50px";
        remoteFrame.style.borderWidth="0px";
        remoteFrame.style.display = "none";
        remoteFrame.height = 0;
        remoteFrame.width = 0; // PlayStation WebMAF needs this
        remoteFrame.src = forDomain + DataLoader.frameUrl;
        remoteFrame.onload = callback;
        DataLoader.communicationFramesIds[forDomain] = remoteFrame.id;
        var body = document.body || document.getElementsByTagName('body')[0];
        if (body) {
            body.appendChild(remoteFrame);
        }
    }

    this.removeIFrame = function (communicationFrameId) {
        var remoteFrame = _s.findFrameById(communicationFrameId);
        if (remoteFrame != null) {
            var body = document.body || document.getElementsByTagName('body')[0];
            body.removeChild(remoteFrame);
        }
    }

    function handleResp (e) { //NO_RENAME:data,convivaRequestId,post_err,origin,bytes,requestId
        // Can't use Utils.getInstance().runProtected(), Utils may not have been instantiated yet
        try {
            var d = e.data;

            // Message may not be from our iframe. Could be from any component on the page.
            // Differentiate our messages further by using convivaRequestId instead of requestId
            if (typeof d !== 'object') return;
            if (typeof d.convivaRequestId === 'undefined') {
                // Backward compatibility for 2.79 and prior clients (none in production still)
                if (typeof d.requestId !== 'undefined') {
                    d.convivaRequestId = d.requestId;
                } else {
                    return;
                }
            }

            var domain_callback = DataLoader.callbacks[d.convivaRequestId];
            if(!domain_callback) {
                Utils.getInstance().log('Received response for unknown request');
                return;
            }
            if (!DataLoader.TESTAPI_forTouchstone && e.origin != domain_callback[0]) {
                Utils.getInstance().log('ERROR: Bad origin:' + e.origin);
                return;
            }

            delete DataLoader.callbacks[d.convivaRequestId];
            var bytes = d.bytes;
            if (!d.post_err || d.post_err != 'ok') {
                Utils.getInstance().log('ERROR: Error posting to ' + e.origin + ' (' + bytes + ')');
                domain_callback[1] (false, d.post_err);
            } else {
                domain_callback[1] (true, bytes);
            }
        } catch (e) {}
    }

    if(_s != STAT_INIT) _constr.apply(_s, arguments);
}
statInit(DataLoader,"DataLoader");
// DO NOT EDIT! THIS FILE WAS GENERATED BY Slash from ../../csClient/CwsClient/utils/Infer.cs
// -*- Mode: java; tab-width: 4; indent-tabs-mode: nil -*-


// namespace utils

    function Infer() {
        var _s = this;

        if(_s == STAT_INIT) Infer.MOVING_STATE /* : String */ = "MOVING";
        if(_s == STAT_INIT) Infer.NOT_MOVING_STATE /* : String */ = "NOT_MOVING";

        if(_s != STAT_INIT) _s.movingMinimumSamples /* : int */ = 3;
        if(_s != STAT_INIT) _s.notMovingMinimumSamples /* : int */ = 3;

        if(_s != STAT_INIT) _s.movingExpectedSpeed /* : Number */ = 1;
        if(_s != STAT_INIT) _s.notMovingExpectedSpeed /* : Number */ = 0;
        if(_s != STAT_INIT) _s.movingSpeedTolerance /* : Number */ = 0.25;

        if(_s != STAT_INIT) _s.resetAfter /* : Boolean */ = false;

        if(_s != STAT_INIT) _s._lastPlayHeadTimeSpeeds /* : ListCS(double) */ = undefined;
        if(_s != STAT_INIT) _s._lastPlayHeadTime /* : Number */ = 0;
        if(_s != STAT_INIT) _s._lastPollTime /* : Number */ = 0;

        function _constr() {
            _s.Reset();
        }

        defPubMeth(_s,"Update",__Update);
        function __Update(phtNow /* : int */) /* : String */  {
            var now /* : Number */ = Utils.getInstance().epochTimeMs();
            if (_s._lastPollTime > 0 && now > _s._lastPollTime)
            {
                _s._lastPlayHeadTimeSpeeds.Insert(0, (Lang.AsDouble(phtNow - _s._lastPlayHeadTime)) / (now - _s._lastPollTime));
            }
            _s._lastPollTime = now;
            _s._lastPlayHeadTime = Lang.AsDouble(phtNow);
            if (_s._lastPlayHeadTimeSpeeds.Count > Math.max(_s.movingMinimumSamples, _s.notMovingMinimumSamples))
            {
                _s._lastPlayHeadTimeSpeeds.RemoveAt(_s._lastPlayHeadTimeSpeeds.Count - 1);
            }
            return _s.InferState();
        }

        defPrivMeth(_s,"InferState",__InferState);
        function __InferState() /* : String */  {
            var inferredState /* : String */ = null;
            var numPhSpeedSamples /* : int */ = _s._lastPlayHeadTimeSpeeds.Count;
            if (numPhSpeedSamples >= Math.min(_s.movingMinimumSamples, _s.notMovingMinimumSamples))
            {
                var avgSpeed /* : Number */ = 0.0;
                var _for_array_1 =  _s._lastPlayHeadTimeSpeeds.Values;
                for(var _for_idx_2=0; _for_idx_2 < _for_array_1.length; _for_idx_2++) {
                  var phSpeed /* : Number */ = _for_array_1[_for_idx_2];

                    avgSpeed += phSpeed;
                }
                avgSpeed /= numPhSpeedSamples;

                if (numPhSpeedSamples >= _s.movingMinimumSamples
                    && Math.abs(avgSpeed - _s.movingExpectedSpeed) < _s.movingSpeedTolerance)
                {
                    inferredState = Infer.MOVING_STATE;
                }
                if (numPhSpeedSamples >= _s.notMovingMinimumSamples
                    && avgSpeed == _s.notMovingExpectedSpeed)
                {
                    inferredState = Infer.NOT_MOVING_STATE;
                }
            }
            if (_s.resetAfter && inferredState != null)
            {
                _s.Reset();
            }
            return inferredState;
        }

        defPubMeth(_s,"Reset",__Reset);
        function __Reset() /* : void */  {
            _s._lastPlayHeadTimeSpeeds = new ListCS/*double*/();
            _s._lastPlayHeadTime = -1;
            _s._lastPollTime = 0;
        }

       //JSRENAME:constant:_s:Infer:MOVING_STATE
       //JSRENAME:constant:_s:Infer:NOT_MOVING_STATE
        if(_s != STAT_INIT) _constr.apply(_s, arguments);
    }
statInit(Infer,"Infer");


// Copyright Conviva Inc. 2014-2016
// Author: Swapna Iyer <siyer@conviva.com>

// Subclass of the ConvivaStreamerProxy for VideoJS

/* needs reliable pht inference logic for buffering detection ?? TBD: [siyer] */

function ConvivaVideojsStreamerProxy() {
  var _s = this;

  if (_s != STAT_INIT) {
    _s._capabilities = ConvivaStreamerProxy.CAPABILITY_VIDEO +
        ConvivaStreamerProxy.CAPABILITY_QUALITY_METRICS +
        ConvivaStreamerProxy.CAPABILITY_BITRATE_METRICS;
    _s._duration = -1;

  }

  function _constr(vjsPlayer) {

    ConvivaStreamerProxy.call(_s);
    _s.Log('ConvivaVideojsStreamerProxy._constr()');
    _s._vjsPlayer = vjsPlayer;
    _s._infer = new Conviva.Infer();

    _s._setAllEventListeners();
    _s._startPolling();
    _s.firstPlay = true;
    _s.videoWidth = -1;
    _s.videoHeight = -1;
    _s.tech = null;
    var requestTech = new Object();
    requestTech.IWillNotUseThisInPlugins = true;
    _s.requestTech = requestTech;
    if ((_s.tech = _s._vjsPlayer.tech(_s.requestTech)) !== null) {
      // _s.Log('Found TECH...');
    } else {
      // _s.Log('DID NOT FIND TECH !!');
    }
    if (_s.tech.hls) {
      var bandW = Math.round(_s.tech.hls.bandwidth/1024);
      var updatedStream = new StreamInfo(bandW, null, null, -1, -1, -1);
      _s.SetStream(updatedStream);
      // _s.Log('Ctor : BANDWIDTH: ' + bandW);
    } else {
      // _s.Log('Ctor : Player is not ready! ');
      _s.updateBitrate();
    }
    // _s.SetPlayerState(Conviva.ConvivaStreamerProxy.STOPPED);
  }


  defPubMeth(_s,"SetMonitoringNotifier",__SetMonitoringNotifier);
  function __SetMonitoringNotifier(notifier /* : Function(Action(String, object)) */){
    _s.Log("SetMonitoringNotifier from overridden method");
    _s.notifier = notifier;
    if (_s.notifier != null && !_s._polling) {
      _s.Log("start polling to be called inside SetMonitoringNotifier method");
      _s._setAllEventListeners();
      _s._startPolling();
    }
    _s.super_SetMonitoringNotifier(notifier);
  }

  defPubMeth(_s, 'Cleanup', __Cleanup);
  function __Cleanup() {
    //Utils.getInstance().runProtected(function () {
    _s.Log('ConvivaVideojsStreamerProxy.Cleanup()');
    //if (_s._infer != null) {
    //  _s._infer = null;
    //}
    _s.notifier = null;
    _s._stopPolling();

    _s._removeAllEventListeners();

    _s._duration = -1;
    //_s._vjsPlayer = null;

    _s.super_Cleanup();
    //}, "ConvivaVideojsStreamerProxy.Cleanup");
  }

  defPubMeth(_s, 'GetCapabilities', __GetCapabilities);
  function __GetCapabilities() {
    //_s.Log('ConvivaVideojsStreamerProxy.GetCapabilities()');
    return _s._capabilities;
  }

  // GETTERS
  this.GetDuration = function() {
    return _s._duration;
  };

  this.GetBufferLengthMs = function() {
    return _s._bufferLengthMs;
  };

  this.GetEncodedFrameRate = function() {
    return _s._encodedFrameRate;
  };

  this.GetPlayheadTimeMs = function() {
    return _s._vjsPlayer.currentTime() * 1000;
  };


  //SETTERS
  this.SetDuration = function(duration) {
    // Set duration only during PLAYING state to resolve issue of setting previous content duration until onDurationChange
    if (_s.GetPlayingState() == Conviva.ConvivaStreamerProxy.PLAYING && _s.notifier != null && _s.notifier != undefined && isFinite(duration) && duration > 0) {
      var durationSec = Math.floor(duration);
      // Need to convert to integer as there is change in the decimal values, which sets metadata even without any change
      // push to metadata only if there is a change ? [TBD] siyer
      if (_s.GetDuration() != durationSec) {
        _s._duration = durationSec;
        var meta = {};
        meta[ConvivaStreamerProxy.METADATA_DURATION] = _s._duration;
        _s.SetMetadata(meta);
      }
    }
  };

  this.SetPlayheadTimeMs = function(pht) {
    // Inference need to be invoked even during start of playback to report Buffering
    if (isFinite(pht) && pht >= 0) {
      var phtMs = pht * 1000;
      if (_s._playheadTimeMs != phtMs) {
        _s._playheadTimeMs = phtMs;
      }
      _s.InferState();
    }
  };

  this.SetPlayerState = function(convivaState) {
    if (_s.GetPlayingState() !== convivaState) {
      _s.SetPlayingState(convivaState);
      _s._infer.Reset();
    }
  };

  this.updateBitrate = function() {
    var totalBitrate = 0;
    var audioBitrate = 0;
    var videoBitrate = 0;
    if(_s._vjsPlayer && _s._vjsPlayer.dash) {
        // http://players.brightcove.net/videojs-dash/videojs-dash.min.js https://github.com/videojs/videojs-contrib-quality-levels
      if(_s._vjsPlayer.dash.mediaPlayer) {
        if(typeof _s._vjsPlayer.dash.mediaPlayer.getQualityFor == 'function' && typeof _s._vjsPlayer.dash.mediaPlayer.getBitrateInfoListFor == 'function') {
          var audioQuality = _s._vjsPlayer.dash.mediaPlayer.getQualityFor('audio');
          var audioBitrateList = _s._vjsPlayer.dash.mediaPlayer.getBitrateInfoListFor('audio');
          if( typeof audioQuality !== 'undefined' && audioBitrateList && audioBitrateList[audioQuality] &&
            audioBitrateList[audioQuality].bitrate) {
            audioBitrate = audioBitrateList[audioQuality].bitrate;
          }
          var videoQuality = _s._vjsPlayer.dash.mediaPlayer.getQualityFor('video');
          var videoBitrateList = _s._vjsPlayer.dash.mediaPlayer.getBitrateInfoListFor('video');
          if( typeof videoQuality !== 'undefined' && videoBitrateList && videoBitrateList[videoQuality] &&
            videoBitrateList[videoQuality].bitrate) {
            videoBitrate = videoBitrateList[videoQuality].bitrate;
          }
          totalBitrate = audioBitrate + videoBitrate;
        }
        //http://players.brightcove.net/videojs-drm/4/videojs-drm.min.js
      } else if(_s._vjsPlayer.dash.shakaPlayer) {
        if(typeof _s._vjsPlayer.dash.shakaPlayer.getStats == 'function' && _s._vjsPlayer.dash.shakaPlayer.getStats().streamBandwidth) {
          totalBitrate = _s._vjsPlayer.dash.shakaPlayer.getStats().streamBandwidth;
        }
      }
      if(totalBitrate) {
          var updatedStream = new StreamInfo(Math.round(totalBitrate / 1024), null, null, -1, -1, -1);
          _s.SetStream(updatedStream);
      }
    }
  }

  this.InferState = function() {
    if (_s._infer) {
      var newState = _s._infer.Update(_s._playheadTimeMs);
      if (newState) {
        if (newState === Conviva.Infer.MOVING_STATE &&
            _s.GetPlayingState() !== Conviva.ConvivaStreamerProxy.PLAYING) {
          _s.Log('ConvivaVideojsStreamerProxy.InferState(): PLAYING');
          _s.triggeredPlayEvent = false;
          _s.SetPlayerState(Conviva.ConvivaStreamerProxy.PLAYING);
        }
        // Buffering state should be set when current state is UNKNOWN during NOT_MOVING state
        // Also when playback is paused and resumed during Buffering, acheived with triggeredPlayEvent
        // Safari browser needs triggeredPlayEvent check for BUFFERING state
        if (newState === Conviva.Infer.NOT_MOVING_STATE &&
            (_s.GetPlayingState() === Conviva.ConvivaStreamerProxy.PLAYING || _s.GetPlayingState() === Conviva.ConvivaStreamerProxy.UNKNOWN || _s.triggeredPlayEvent)) {
          _s.Log('ConvivaVideojsStreamerProxy.InferState(): BUFFERING');
          _s.triggeredPlayEvent = false;
          _s.SetPlayerState(Conviva.ConvivaStreamerProxy.BUFFERING);
        }
      }
    }
  };

  this._startPolling = function() {
    _s._polling = true;
    _s._cancelTimer =
        Utils.getInstance()._settings.platformApi.createTimer(
        _s._poll, 100, 'ConvivaVideojsStreamerProxy._poll');
  };

  this._poll = function() {
     Utils.getInstance().runProtected(function() {
         if (!_s._polling || !_s._vjsPlayer) {
             _s.SetPlayheadTimeMs(0);
             return;
         }
         _s.SetPlayheadTimeMs(_s._vjsPlayer.currentTime());
         _s.SetDuration(_s._vjsPlayer.duration());
         if (_s.videoWidth != _s._vjsPlayer.videoWidth() || _s.videoHeight != _s._vjsPlayer.videoHeight()) {
             _s.videoWidth = _s._vjsPlayer.videoWidth();
             _s.videoHeight = _s._vjsPlayer.videoHeight();
             _s.SetDisplaySize(_s.videoWidth, _s.videoHeight);
         }
     }, 'ConvivaVideojsStreamerProxy._poll');
 };

  this._stopPolling = function() {
    if (_s._polling && typeof _s._cancelTimer === 'function') {
      _s._cancelTimer();
      _s._cancelTimer = null;
    }
    _s._polling = false;
  };

  this._declareError = function(errMsg) {
    _s.Log('ConvivaVideojsStreamerProxy._declareError: ' + errMsg);
    _s.SetError(StreamerError.makeUnscopedError(
        errMsg, StreamerError.SEVERITY_FATAL));
  };

  this._setAllEventListeners = function() {
    _s.Log('ConvivaVideojsStreamerProxy._setAllEventListeners()');

    if (_s._vjsPlayer) { //NO_RENAME:on
      _s._vjsPlayer.on('ended', _s.onEnded);
      _s._vjsPlayer.on('loadedmetadata', _s.onLoadedMetadata);
      _s._vjsPlayer.on('loadstart', _s.onLoadstart); //HTML5 does nothing
      _s._vjsPlayer.on('pause', _s.onPause);
      _s._vjsPlayer.on('durationchange', _s.onDurationchange);
      _s._vjsPlayer.on('emptied', _s.onEmptied);

      _s._vjsPlayer.on('stalled', _s.onStalled);
      _s._vjsPlayer.on('waiting', _s.onWaiting);
      _s._vjsPlayer.on('play', _s.onPlay);

      _s._vjsPlayer.on('seeking', _s.onSeeking);
      _s._vjsPlayer.on('seeked', _s.onSeeked);

      _s._vjsPlayer.on('error', _s.onError);
      _s._vjsPlayer.on('mediachange', _s.onMediaChange);
      _s._vjsPlayer.on('progress', _s.onProgress);
      // "firstplay", *not part of HLS spec
      // "fullscreenchange",
      // "loadedalldata", *finished downloading source data
      // "loadeddata", *finished downloading data at current playback position
      // "progess", *user agent is downloading media data
      // "resize",
      // "seeked", *has finished jumping to new time
      // "seeking", *is jumping to a new time
      // "timeupdate", *playhead time update every 3 seconds
      // "volumechange",
      // "waiting" *media is waiting
    }
  };

  this._removeAllEventListeners = function() {
    _s.Log('ConvivaVideojsStreamerProxy._removeAllEventListeners()');

    if (_s._vjsPlayer) { //NO_RENAME:off
      _s._vjsPlayer.off('ended', _s.onEnded);
      _s._vjsPlayer.off('loadedmetadata', _s.onLoadedMetadata);
      _s._vjsPlayer.off('loadstart', _s.onLoadstart);
      _s._vjsPlayer.off('pause', _s.onPause);
      _s._vjsPlayer.off('durationchange', _s.onDurationchange);
      _s._vjsPlayer.off('emptied', _s.onEmptied);
      _s._vjsPlayer.off('stalled', _s.onStalled);
      _s._vjsPlayer.off('waiting', _s.onWaiting);
      _s._vjsPlayer.off('play', _s.onPlay);

      _s._vjsPlayer.off('seeking', _s.onSeeking);
      _s._vjsPlayer.off('seeked', _s.onSeeked);

      _s._vjsPlayer.off('error', _s.onError);
      _s._vjsPlayer.off('mediachange', _s.onMediaChange);
    }
  };


  this.onPause = function(event, p1, p2) {
    Utils.getInstance().runProtected(function() {
      _s.Log('ConvivaVideojsStreamerProxy.onPause');
      _s.triggeredPlayEvent = false;
      _s.SetPlayerState(Conviva.ConvivaStreamerProxy.PAUSED);
    }, 'ConvivaVideojsStreamerProxy.onPause');
  };

  this.onLoadedMetadata = function(event, p1, p2) {
    Utils.getInstance().runProtected(function() {
      _s.Log('ConvivaVideojsStreamerProxy.onLoadedMetadata');
      if (!_s._vjsPlayer.duration()) {
          return;
      }
      if (_s._vjsPlayer) {
        _s.SetDuration(_s._vjsPlayer.duration());
      }
      /*
      if (_s._vjsPlayer && _s._vjsPlayer.tech(_s.requestTech).hls) {
	  var bandWidth= Math.round(_s._vjsPayer.tech(_s.requestTech).hls.playlists.media().attributes.BANDWIDTH/1024);
	  console.log('onLoadedMetadata: BANDWIDTH: ' + bandWidth);
	  var updatedStream = new StreamInfo(bandWidth, null, null, -1, -1, -1);
	  _s.SetStream(updatedStream);
      }
      */
    }, 'ConvivaVideojsStreamerProxy.onLoadedMetadata');
  };

  this.onEnded = function(event, p1, p2) {
    Utils.getInstance().runProtected(function() {
      _s.Log('ConvivaVideojsStreamerProxy.onEnded');
      if (_s._vjsPlayer) { //Ignore 'ended' callback after player is destroyed
        _s.SetPlayerState(Conviva.ConvivaStreamerProxy.STOPPED);
      }
    }, 'ConvivaVideojsStreamerProxy.onEnded');
  };

  this.onDurationchange = function(event, p1, p2) {
    Utils.getInstance().runProtected(function() {
      _s.Log('ConvivaVideojsStreamerProxy.onDurationchange');
      if (_s._vjsPlayer) {
        _s.SetDuration(_s._vjsPlayer.duration());
      }
    }, 'ConvivaVideojsStreamerProxy.onDurationchange');
  };

  this.onLoadstart = function(event, p1, p2) {
    Utils.getInstance().runProtected(function() {
      _s.Log('ConvivaVideojsStreamerProxy.onLoadstart');
      // _s.SetPlayerState(Conviva.ConvivaStreamerProxy.STOPPED);
    }, 'ConvivaVideojsStreamerProxy.onLoadstart');
  };

  this.onPlay = function(event, p1, p2) {
      Utils.getInstance().runProtected(function() {
      _s.Log('ConvivaVideojsStreamerProxy.onPlay');
      _s.triggeredPlayEvent = true;
    }, 'ConvivaVideojsStreamerProxy.onPlay');
  };

  this.onSeeking = function() {
    Utils.getInstance().runProtected(function() {
      if (!_s.isSeekStarted) {
          _s.Log('ConvivaVideojsStreamerProxy.onSeeking');
          _s.isSeekStarted = true;
          _s.SendSeekEvent(Conviva.LivePass.SEEK_ACTIONS_TYPE.SEEK_START, -1);
      }
    }, 'ConvivaVideojsStreamerProxy.onSeeking');
  };

  this.onSeeked = function() {
    Utils.getInstance().runProtected(function() {
      _s.Log('ConvivaVideojsStreamerProxy.onSeeked');
      _s.isSeekStarted = false;
      _s.SendSeekEvent(Conviva.LivePass.SEEK_ACTIONS_TYPE.SEEK_END, -1);
    }, 'ConvivaVideojsStreamerProxy.onSeeked');
  };

  this.onStalled = function(event, p1, p2) {
    Utils.getInstance().runProtected(function() {
      // _s.Log('ConvivaVideojsStreamerProxy.onStalled NO STATE CHANGE');
      // DE-20 & CSR-964 - Do not use 'stalled' event for state change to Buffering
      //_s.SetPlayerState(Conviva.ConvivaStreamerProxy.BUFFERING);
    }, 'ConvivaVideojsStreamerProxy.onStalled');
  };


  this.onEmptied = function(event, p1, p2) {
    Utils.getInstance().runProtected(function() {
      _s.Log('ConvivaVideojsStreamerProxy.onEmptied');
      // _s.SetPlayerState(Conviva.ConvivaStreamerProxy.STOPPED);
    }, 'ConvivaVideojsStreamerProxy.onEmptied');
  };


  this.onWaiting = function(event, p1, p2) {
    Utils.getInstance().runProtected(function() {
      _s.Log('ConvivaVideojsStreamerProxy.onWaiting');
      // Rely completely on Inference logic as onWaiting() is trigerred immediately after onPlay()
      // Removed this call as Buffering is reported during skip of playlist item
      //_s.triggeredPlayEvent = false;
      //_s.SetPlayerState(Conviva.ConvivaStreamerProxy.BUFFERING);
    }, 'ConvivaVideojsStreamerProxy.onWaiting');
  };



  this.onError = function() {
    Utils.getInstance().runProtected(function() {
      _s.Log('ConvivaVideojsStreamerProxy.onError');
      // Error should be reported only for Main Content not for Ads
      if (_s._vjsPlayer && _s.notifier != null && _s.notifier != undefined ) {
          var errorEvent = _s._vjsPlayer.error();
          var reportedError = _s._convertError(
               errorEvent ? errorEvent.code : 99);
          _s.Log("MediaError: " + errorEvent.message);
          _s._declareError(reportedError);

      }
    }, 'ConvivaVideojsStreamerProxy.onError');
  };

  this.onProgress = function() {
    Utils.getInstance().runProtected(function() {
      //_s.Log('ConvivaVideojsStreamerProxy.onProgress');
      if (_s._vjsPlayer && _s._vjsPlayer.tech(_s.requestTech).hls && _s._vjsPlayer.tech(_s.requestTech).hls.playlists.media() && _s._vjsPlayer.tech(_s.requestTech).hls.playlists.media().attributes) {
        var updatedStream = new StreamInfo(Math.round(_s._vjsPlayer.tech(_s.requestTech).hls.playlists.media().attributes.BANDWIDTH / 1024), null, null, -1, -1, -1);
        _s.SetStream(updatedStream);
      } else {
        _s.updateBitrate();
      }
    }, 'ConvivaVideojsStreamerProxy.onProgress');
  };

  this.onMediaChange = function() {
    Utils.getInstance().runProtected(function() {
      _s.Log('ConvivaVideojsStreamerProxy.onMediaChange');
      if (_s._vjsPlayer && _s._vjsPlayer.tech(_s.requestTech).hls && _s._vjsPlayer.tech(_s.requestTech).hls.playlists.media() && _s._vjsPlayer.tech(_s.requestTech).hls.playlists.media().attributes) {
         var updatedStream = new StreamInfo(Math.round(_s._vjsPlayer.tech(_s.requestTech).hls.playlists.media().attributes.BANDWIDTH / 1024), null, null, -1, -1, -1);
         _s.SetStream(updatedStream);
      }  else {
         _s.updateBitrate();
      }
    }, 'ConvivaVideojsStreamerProxy.onMediaChange');
  };

  this._convertError = function(code) {
    var errorCode = ' (code ='+code+')';
    switch (code) {
      case 0:
      errStr = 'MEDIA_ERR_CUSTOM'; break; // find way to get str desc of error
      case 1:
        errStr = 'MEDIA_ERR_ABORTED'; break;
      case 2:
        errStr = 'MEDIA_ERR_NETWORK'; break;
      case 3:
        errStr = 'MEDIA_ERR_DECODE'; break;
      case 4:
        errStr = 'MEDIA_ERR_SRC_NOT_SUPPORTED'; break;
      case 5:
        errStr = 'MEDIA_ERR_ENCRYPTED'; break;
      case -1:
        errStr = 'PLAYER_ERR_NO_SRC'; break;
      case -2:
        errStr = 'PLAYER_ERR_TIMEOUT'; break;
      default:
        errStr = 'MEDIA_ERR_UNKNOWN';
    }
    errStr = errStr + errorCode;
    _s.Log("MediaError: code " + code+ " " + errStr);
    return errStr;
  };

  if (_s != STAT_INIT) _constr.apply(_s, arguments);

}

statInit(ConvivaVideojsStreamerProxy, 'ConvivaVideojsStreamerProxy');
// Copyright (c) 2009-2014, Conviva Inc. All Rights Reserved.
// Implementation of the Platform API for HTML5
// Author: George Necula (necula@conviva.com)
// Changes: Alban Nicolas (anicolas@conviva.com)

function Html5PlatformApi () {
    var _s = this;
    var _persistentData = null;
    var _convivaKey = "convivaPersistent";

    function _constr() {
        _s._dataLoader = new DataLoader();

        // @deprecated in CWS 1.7
        _s.platform = (navigator && navigator.platform && (navigator.platform.toString ? navigator.platform.toString() : null));
    }

    /// <summary>
    /// Cleanup internal and external objects used by the implementation.
    /// </summary>
    this.cleanup = function() {
        if (_s._dataLoader != null) {
            _s._dataLoader.cleanup();
            _s._dataLoader = null;
        }
    }

    /// <summary>
    /// Save data on persistent storage
    /// callback must be invoked after the operation.
    /// </summary>
    /// <param name="data">a string representing data to be saved</param>
    /// <param name="callback">Callback function to be invoked. Pass in true if success, false otherwise</param>
    this.saveLocalData = function(data, callback) {
        try {//NO_RENAME:localStorage,setItem
            localStorage.setItem(_convivaKey, data);
        } catch(e) {
            callback(false);
            return;
        }
        callback(true);
    }

    /// <summary>
    /// Retrieve data from persistent storage
    /// callback must be invoked after the operation.
    /// </summary>
    /// <param name="callback">callback function to be invoked.
    /// Two parameters are required:
    /// * a boolean representing success of the operation
    /// * a string representing the retrieved data
    /// </param>
    this.loadLocalData = function(callback) {
        try {//NO_RENAME:localStorage,getItem
            var data = localStorage.getItem(_convivaKey);
            callback(true, data);
        } catch(e) {
            callback(false, "");
        }
    }

    this.deleteLocalData = function() {
        try {//NO_RENAME:localStorage,clear
            var data = localStorage.clear();
        } catch(e) {
        }
    }

    /// <summary>
    /// Send HTTP request
    ///
    /// The callback function must be invoked after the operation
    /// </summary>
    /// <param name="isPOST">true if this is a POST request; false for GET</param>
    /// <param name="url">URL of the request</param>
    /// <param name="data">The data to be sent (ignored for GET)</param>
    /// <param name="contentType">The content type (if null, the default will be "application/json")</param>
    /// <param name="callback">Callback function to be invoked
    /// Two parameters are required:
    /// * a boolean representing success of the operation
    /// * a String representing data in the response
    /// </param>
    /// Returns a function that can be called to cancel and cleanup the request. The function may be called
    /// multiple times.
    this.httpRequest = function (isPOST, url, data, contentType, callback) {
        if(typeof(data) !== "string") {
            data = _s.jsonEncode(data, null);
        }
        return _s._dataLoader.makeRequest(isPOST, url, data, contentType, callback);
    }

    /// <summary>
    /// Return the current time in milliseconds since Unix epoch
    /// </summary>
    /// <returns></returns>
    this.epochTimeMs = function () {
        var d = new Date();
        return d.getTime();
    }

    /// <summary>
    /// Start a periodic timer
    ///
    /// <param name="timerAction">The Action to run periodicaly</param>
    /// <param name="intervalMs">The interval in ms</param>
    /// <param name="actionName">The name of the action (for debugging)</param>
    /// </summary>
    /// <returns>A function that can be called to cancel/cleanup the timer</returns>
    this.createTimer = function (timerAction, intervalMs, actionName) {
        // var wrapperAction = function () {
        //     Utils.getInstance().log("timer tick for action: " + actionName);
        //     Utils.getInstance().runProtected(timerAction, actionName);
        // };
        // var timerId = setInterval(wrapperAction, intervalMs);
        var timerId = setInterval(timerAction, intervalMs);
        return (function () {
            if(timerId != -1) {
                clearInterval(timerId);
                timerId = -1;
            }});
    }


    /// <summary>
    /// Encode an object to JSON (asynchronously). This
    /// asynchronous interface is provided because encoding may take too
    /// long for a single handler on some platforms.
    /// </summary>
    /// <param name="obj">must be a JSON encodable data structure in the native language
    /// (i.e. not a Slash data structure like a DictionaryCS).  It must have
    /// one of the following types:
    ///   - dictionary
    ///   - array or list
    ///   - string
    ///   - number
    ///   - boolean
    ///   - null</param>
    /// <returns>A string of JSON-encoded data.</returns>
    this.jsonEncode = function (obj) { //NO_RENAME:JSON,stringify
        var jsonString = null;
        jsonString = JSON.stringify(obj);
        return jsonString;
    }

    /// <summary>
    /// Decode a string to an object. The values in the object will be the same
    /// type as the JSON encodable values documented in jsonEncode.
    /// </summary>
    /// <param name="json"></param>
    /// <returns>An object representing the JSON-decoded data.</returns>
    this.jsonDecode = function (json) { //NO_RENAME:JSON,parse
        var parsedJson = null;
        parsedJson = JSON.parse(json);
        return parsedJson;
    }

    /// <summary>
    /// Debugging message logging
    /// </summary>
    /// <param name="message"> message to be logged</param>
    this.consoleLog = function(message) {
        if (typeof console != 'undefined' && console.log) {
            console.log(message);
        }
    }


    /// <summary>
    /// Error message logging
    /// </summary>
    /// <param name="errMsg">error message to be logged</param>
    this.consoleErr = function(errMsg) {
        if (typeof console != 'undefined' && console.error) {
            console.error(errMsg);
        }
    }

    /// <summary>
    /// @deprecated in CWS 1.7
    /// Return a string that names the device.
    /// Maximum length is 64 bytes.
    /// Return null if not available
    /// </summary>
    this.getDevice = function() {
        return 'browser';
    }

    /// <summary>
    /// @deprecated in CWS 1.7
    /// Return a string representing the version number of the device.
    /// Maximum length is 64 bytes.
    /// Return null if not available
    /// </summary>
    this.getDeviceVersion = function() {
        return null;
    }

    /// <summary>
    /// @deprecated in CWS 1.7
    /// Return a string representing the type of the device.
    /// Maximum length is 64 bytes. Should be selected from the following list:
    /// * PC
    /// * Mobile
    /// * Console
    /// * Settop
    /// </summary>
    this.getDeviceType = function() {
        return "PC";
    }

    /// <summary>
    /// @deprecated in CWS 1.7
    /// Return a string naming the operating system in which the session is running.
    /// Maximum length is 64 bytes. Must be in upper case.
    /// Should be selected from the following list:
    /// * MAC
    /// * WIN
    /// * IOS
    /// * XBOX
    /// * SAMSUNG
    /// * PS3
    /// * AND (Android)
    /// * UNIX (for any *nix other than Android, including Linux).
    /// If none of these options apply, choose an appropriate name.
    /// </summary>
    this.getOS = function() {
        return _s._getPlatformName();
    }

    /// <summary>
    /// @deprecated in CWS 1.7
    /// A string indicating the full version number of the operating system indicated under "os", if any.
    /// null if not available
    /// </summary>
    this.getOSVersion = function () {
        return null;
    }

    /// <summary>
    /// Returns a dictionary with platform metadata.
    /// Schemas are per-platform, and defined in the backend.
    /// </summary>
    defPubMeth(_s,"getPlatformMetadata",__getPlatformMetadata); // defining it that way for inheritance
    function __getPlatformMetadata() { //NO_RENAME:navigator,platform,userAgent,toString
        var res = { "sch" : "html5.1" };
        res['np'] = (navigator && navigator.platform && (navigator.platform.toString ? navigator.platform.toString() : null));
        res['nua'] = (navigator && navigator.userAgent && (navigator.userAgent.toString ? navigator.userAgent.toString() : null));
        return res;
    }

    // TODO: move to backend
    // @deprecated in CWS 1.7
    this._getPlatformName = function () {
        if (_s.platform == null) {
            return null;
        }
        var stringContains = function (haystack, needle) {
            return haystack.indexOf(needle) >= 0;
        };
        if (stringContains(_s.platform, "iPad")
            || stringContains(_s.platform, "iPhone")
            || stringContains(_s.platform, "iPod")) {
            return "IOS";
        } else if (stringContains(_s.platform, "Mac")) {
            return "MAC";
        } else if (stringContains(_s.platform, "Win")) {
            return "WIN";
        } else if (stringContains(_s.platform, "Linux")
                   || stringContains(_s.platform, "SunOS")
                   || stringContains(_s.platform, "HP-UX")
                   || stringContains(_s.platform, "BSD")) {
            return "UNIX";
        } else if (stringContains(_s.platform, "PLAYSTATION 3")) {
            return "PS3";
        } else if (stringContains(_s.platform, "XBOX")) {
            return "XBOX";
        } else {
            return null;
        }
    }

    if(_s != STAT_INIT) _constr.apply(_s, arguments);
}
statInit(Html5PlatformApi, 'Html5PlatformApi');
// Copyright (c) 2015, Conviva Inc. All Rights Reserved.
// Implementation of the Platform API for Videojs
// Author: Alban Nicolas <anicolas@conviva.com>

function ConvivaVideojsPlatformApi() {
    var _s = this;

    function _constr() {
        Html5PlatformApi.call(_s);
    }

    this.getPlatformMetadata = function() {
        var res = _s.super_getPlatformMetadata();
        res['sch'] = 'videojs.1';
        res['fw'] = 'Video JS';
	if(typeof(videojs)!="undefined"){
        res['fwv'] = videojs.VERSION;
       }
        return res;
    };

    //if(_s != STAT_INIT)
    _constr.apply(_s, arguments);
}
statInit(ConvivaVideojsPlatformApi, 'ConvivaVideojsPlatformApi');
})();
var Conviva = (typeof Conviva !== 'undefined') ? Conviva : (function () { });
Conviva.LivePass = ConvivaPrivateLoader.LivePass; Conviva.ConvivaContentInfo = ConvivaPrivateLoader.ConvivaContentInfo; Conviva.StreamerError = ConvivaPrivateLoader.StreamerError; Conviva.ConvivaStreamerProxy = ConvivaPrivateLoader.ConvivaStreamerProxy; Conviva.Settings = ConvivaPrivateLoader.Settings; Conviva.StreamInfo = ConvivaPrivateLoader.StreamInfo; Conviva.Utils = ConvivaPrivateLoader.Utils; Conviva.ConvivaVideojsStreamerProxy = ConvivaPrivateLoader.ConvivaVideojsStreamerProxy; Conviva.ConvivaVideojsPlatformApi = ConvivaPrivateLoader.ConvivaVideojsPlatformApi; Conviva.Infer = ConvivaPrivateLoader.Infer;
}
